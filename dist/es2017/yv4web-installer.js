/* Yocto-Visualization-4web installer (version 1.10.51840) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (!(data[0].x < end) && data[count - 1].x > start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 30 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.currPos = 0;
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    if (!this._hubAdded) {
      await this.signalHubConnected();
    }
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    this.notbynOpenTimeout = null;
    if (this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().catch((e) => {
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open");
                  this.imm_disconnectNow();
                }
              }, 6e4);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: multipart/form-data, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("WS: closing stalled connection");
        hub.imm_disconnectNow();
      }
    }, 6e4);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      hub.notifCarryOver = "";
    }
    nrows--;
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        hub.notifPos = -1;
      }
      hub.currPos += ev.length + 1;
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.51840";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(0, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    await this.HandleEvents(errmsg);
    while (this.GetTickCount() < end) {
      await this._microSleep_internal();
      await this.HandleEvents(errmsg);
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    this._setTimeout_internal(callback, this.GetTickCount() + ms_timeout, args);
    return YAPI_SUCCESS;
  }
  _setTimeout_internal(callback, endtime, args) {
    let delay = endtime - YAPI.GetTickCount();
    if (delay < 0) {
      callback.apply(null, args);
    } else if (delay < 100) {
      this.Sleep(delay).then(() => {
        this._setTimeout_internal(callback, endtime, args);
      });
    } else {
      this.UpdateDeviceList().then(() => {
        this.Sleep(90).then(() => {
          this._setTimeout_internal(callback, endtime, args);
        });
      });
    }
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos > 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                }
                let newlen = xmlHttpRequest.responseText.length;
                if (newlen > this.currPos) {
                  this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.currPos = 0;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.51840";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = true;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.dataLoggerFeature = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.globalDataLoadProgress = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  getGetaLoadProgress() {
    return this.globalDataLoadProgress;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    this.globalDataLoadProgress = this.recordedDataLoadProgress;
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows )");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = 0;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.globalDataLoadProgress = 100;
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (this.globalDataLoadProgress != this.recordedDataLoadProgress) {
        this.globalDataLoadProgress = this.recordedDataLoadProgress;
        this.reportDataloggerLoadProgress(this.globalDataLoadProgress);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
        this.load_ProgressChanged();
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        console.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec");
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      this.globalDataLoadProgress = 100;
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows )");
    this.loadDone = true;
    this.globalDataLoadProgress = 100;
    if (this.previewMinData.length <= 0) {
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].DataLoggerProgress();
        }
      }
      return;
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
        this.FormsToNotify[i].DataLoggerProgress();
      }
    }
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this.preloadDone = false;
    this.loadDone = false;
    this._loadProcessIsBusy = false;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  load_ProgressChanged() {
    for (let i = 0; i < this.FormsToNotify.length; i++)
      if (this.FormsToNotify[i] instanceof graphWidget)
        this.FormsToNotify[i].DataLoggerProgress();
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    if (this.curData.length > 0) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.loadDatalogger(start, end);
      }
    } else {
      this.loadDatalogger(0, await dt.get_timeUTC());
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    if (M != null) {
      this._online = true;
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorValuecallback(this, M);
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("--> Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
      logForm.log("UpdateDeviceList failed :" + err.msg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeWidth / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  showRecordedDatachanged() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  preLoadSensorData(value, index) {
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    this.dataloggerProgress.enabled = true;
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    debugger;
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  showRecordedDatachanged() {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      this.SourceChanged(s.DataSource_source, i);
    }
  }
  DataLoggerProgress() {
    let progress = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData) {
      this.dataloggerProgress.enabled = false;
      return;
    }
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (!(s.DataSource_source instanceof NullYSensor)) {
          progress += s.DataSource_source.getGetaLoadProgress();
          sensorCount++;
        }
      }
    }
    if (progress < 100 * sensorCount && sensorCount > 0) {
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (progress / sensorCount).toFixed(0) + "%)";
    } else {
      this.dataloggerProgress.enabled = false;
    }
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    this.dataloggerProgress.enabled = false;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (s.DataSource_source == Source) {
          let index = parseInt(name.substring(12));
          this.SourceChanged(Source, index);
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(0, 50, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(0, 50, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this.ownerForm.showRecordedDatachanged();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    let installerURL = "https://www.yoctopuce.com/FR/downloads/yoctovisualization4web/yoctovisualization4web.999.installer.js";
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static CheckForNewVersion() {
    if (!constants.mustCheckForUpdate)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion();
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let HubData = null;
    let res = await YoctoHubFileHandler.makeRequest("GET", url, this._srvusername, this._srvpassword);
    if (res.data != null) {
      let data = new TextDecoder().decode(res.data);
      HubData = JSON.parse(data);
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    } else {
      if (this._protocol == "https") {
        this._protocol = "wss";
      } else {
        this._protocol = "ws";
      }
    }
    return false;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onload = function() {
        if (this.status >= 200 && this.status < 300) {
          resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
        } else {
          resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "XML Export", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub / YoctoHub / Yocto-Visualization server IP addresses this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web). It can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.DEFAULT_PROTOCOL = YV4W_installer.HTTPS;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "443";
    this.DEFAULTPATH = "";
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string")
          this.DEFAULTADDR = options["addr"];
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._nextButton.tabIndex = 101;
    this._okButton.tabIndex = 102;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = constants.WindowHeaderFontSize.toString() + "px";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that will allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "On VirtualHub (for web), the recommended setting is HTTPS, typically on port 443, and the instance path is required as well.\n\nOn VirtualHubs and YoctoHubs, it is recommended to use WebSockets (WS), typically on port 4444.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this._history.pop();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    if (!await info.makeRequest()) {
      let err = "Cannot connect to Hub\n\n" + url + '.\n\nMake sure the server is up, protocol, path, username and password are correct then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._history.pop();
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this._history.pop();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < 43805) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version 43805";
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHub_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    p.innerText = 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this._history.pop();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
