/* Yocto-Visualization-4web installer (version 1.10.52602) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 30 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.stalledTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._isHubWorking = false;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    await this.signalHubConnected();
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub connected");
    }
    this.notbynOpenTimeout = null;
    this._isHubWorking = true;
    if (!this._hubAdded && this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this._isHubWorking = false;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled");
      }
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Hub connection failed (timeout)");
        }
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s");
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Retry hub connection now");
        }
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
    this._isHubWorking = false;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        let TryOpenID = (Date.now() % 6e5).toString();
        if (mstimeout) {
          this.stalledTimeoutMs = mstimeout;
          this.notbynOpenTimeoutObj = setTimeout(() => {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("WebSocket connection timeout [" + TryOpenID + "]");
            }
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("WebSocket connect cancelled (disconnecting) [" + TryOpenID + "]");
            }
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("Opening websocket connection [" + TryOpenID + "]");
            }
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Failed to open WebSocket connection [" + TryOpenID + "]");
              }
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  if (this._yapi._logLevel >= 4) {
                    this._yapi.imm_log("WebSocket connection established [" + TryOpenID + "]");
                  }
                  this.signalHubConnected().catch((e) => {
                    if (this._yapi._logLevel >= 4) {
                      this._yapi.imm_log("Exception in signalHubConnected [" + TryOpenID + "]");
                    }
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed [" + TryOpenID + "]");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error [" + TryOpenID + "]: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error [" + TryOpenID + "]");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open [" + TryOpenID + "]");
                  this.imm_disconnectNow();
                }
              }, this.stalledTimeoutMs);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.disconnecting ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    super.imm_disconnectNow();
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (!hub._isHubWorking) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.52602";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(this._networkTimeoutMs, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.currPos = 0;
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos >= 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.stalledTimeoutMs = mstimeout;
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.currPos = 0;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, async () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                let newlen = xmlHttpRequest.responseText.length;
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                  if (newlen == 0)
                    return;
                }
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                }
                if (!this._isHubWorking) {
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (newlen > this.currPos) {
                  await this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                  this.currPos = newlen;
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.52602";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    if (M != null) {
      this._online = true;
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorValuecallback(this, M);
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.errorMsg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string")
          this.DEFAULTADDR = options["addr"];
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
