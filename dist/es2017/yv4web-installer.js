/* Yocto-Visualization-4web installer (version 1.10.51909) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (!(data[0].x < end) && data[count - 1].x > start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 30 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.currPos = 0;
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    if (!this._hubAdded) {
      await this.signalHubConnected();
    }
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    this.notbynOpenTimeout = null;
    if (this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().catch((e) => {
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open");
                  this.imm_disconnectNow();
                }
              }, 6e4);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: multipart/form-data, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("WS: closing stalled connection");
        hub.imm_disconnectNow();
      }
    }, 6e4);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      hub.notifCarryOver = "";
    }
    nrows--;
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        hub.notifPos = -1;
      }
      hub.currPos += ev.length + 1;
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.51909";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(0, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    await this.HandleEvents(errmsg);
    while (this.GetTickCount() < end) {
      await this._microSleep_internal();
      await this.HandleEvents(errmsg);
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    this._setTimeout_internal(callback, this.GetTickCount() + ms_timeout, args);
    return YAPI_SUCCESS;
  }
  _setTimeout_internal(callback, endtime, args) {
    let delay = endtime - YAPI.GetTickCount();
    if (delay < 0) {
      callback.apply(null, args);
    } else if (delay < 100) {
      this.Sleep(delay).then(() => {
        this._setTimeout_internal(callback, endtime, args);
      });
    } else {
      this.UpdateDeviceList().then(() => {
        this.Sleep(90).then(() => {
          this._setTimeout_internal(callback, endtime, args);
        });
      });
    }
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos > 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                }
                let newlen = xmlHttpRequest.responseText.length;
                if (newlen > this.currPos) {
                  this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.currPos = 0;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.51909";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.dataLoggerFeature = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.globalDataLoadProgress = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  getGetaLoadProgress() {
    return this.globalDataLoadProgress;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    this.globalDataLoadProgress = this.recordedDataLoadProgress;
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows )");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = 0;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.globalDataLoadProgress = 100;
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (this.globalDataLoadProgress != this.recordedDataLoadProgress) {
        this.globalDataLoadProgress = this.recordedDataLoadProgress;
        this.reportDataloggerLoadProgress(this.globalDataLoadProgress);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
        this.load_ProgressChanged();
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        console.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec");
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      this.globalDataLoadProgress = 100;
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows )");
    this.loadDone = true;
    this.globalDataLoadProgress = 100;
    if (this.previewMinData.length <= 0) {
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].DataLoggerProgress();
        }
      }
      return;
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
        this.FormsToNotify[i].DataLoggerProgress();
      }
    }
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this.preloadDone = false;
    this.loadDone = false;
    this._loadProcessIsBusy = false;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  load_ProgressChanged() {
    for (let i = 0; i < this.FormsToNotify.length; i++)
      if (this.FormsToNotify[i] instanceof graphWidget)
        this.FormsToNotify[i].DataLoggerProgress();
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    if (this.curData.length > 0) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.loadDatalogger(start, end);
      }
    } else {
      this.loadDatalogger(0, await dt.get_timeUTC());
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    if (M != null) {
      this._online = true;
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorValuecallback(this, M);
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("--> Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
      logForm.log("UpdateDeviceList failed :" + err.msg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeWidth / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  showRecordedDatachanged() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  preLoadSensorData(value, index) {
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    this.dataloggerProgress.enabled = true;
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    debugger;
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  showRecordedDatachanged() {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      this.SourceChanged(s.DataSource_source, i);
    }
  }
  DataLoggerProgress() {
    let progress = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData) {
      this.dataloggerProgress.enabled = false;
      return;
    }
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (!(s.DataSource_source instanceof NullYSensor)) {
          progress += s.DataSource_source.getGetaLoadProgress();
          sensorCount++;
        }
      }
    }
    if (progress < 100 * sensorCount && sensorCount > 0) {
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (progress / sensorCount).toFixed(0) + "%)";
    } else {
      this.dataloggerProgress.enabled = false;
    }
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    this.dataloggerProgress.enabled = false;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (s.DataSource_source == Source) {
          let index = parseInt(name.substring(12));
          this.SourceChanged(Source, index);
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(0, 50, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(0, 50, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this.ownerForm.showRecordedDatachanged();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response = await fetch(checkurl);
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    ;
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let HubData = null;
    let res = await YoctoHubFileHandler.makeRequest("GET", url, this._srvusername, this._srvpassword);
    if (res.data != null) {
      let data = new TextDecoder().decode(res.data);
      HubData = JSON.parse(data);
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    } else {
      if (this._protocol == "https") {
        this._protocol = "wss";
      } else {
        this._protocol = "ws";
      }
    }
    return false;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onload = function() {
        if (this.status >= 200 && this.status < 300) {
          resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
        } else {
          resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub / YoctoHub / Yocto-Visualization server IP addresses this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "H4sIAAAAAAACA+y9+3sbN64w/Hv/ionOOa2UyLIkX3JxnD6Ondv75uLXdrvxZvvlGUtjaVpJo52RL+o2//tH8AqS4MzIcZLu2e6zjSURAEGQBEEQBNfvRqfZYJGt/ZwWF/Ek/T1epNlsbfMqOYuaz4773d796PxiMol6nV63s9V72H3Yitaiq6urzhLw5heDpDPIptHd9e/W16Ps7Nd1AF8/SmbDJE/y9dODeBGrb/vZdJrNOr8W313GefRzwgjkG9FuNJjERRH967soGmSzYpFfQEEzbkdn7WjQ4gVRtBinRSdm0PGO+X7Gvp+h7wOgBt8/sf+KBWvNIHqeZ9P3p/tZlg+b1+1oqQjmyeIin0Wz5EqxwovbUa+lKEwvJot0Plk+Xb5pTkvwpoyxu4rDe9GU8XVXMQhfB+rroM2+DW3YxIY9t2BHNuzYhk01LMHy2+ashGVJ9G40ayuK5jPwO9Mk94bDn5uX1bTuRZeduG34u+ycaXrwzTB5fHHGujkeLGrRXbPorll01yy6i+wwS2eL502CqCwRNBU1FzOISON92uEj+U28yNPrjevKsdyOhu0oaUfn7WjUjsbtKGWfJ/GouNkgl9+H7PsQfU/Y9wR9P2ffz9H3Efs+Qt/H7PsYfU/Z91R8T8+jJqt+N+pG338fDfWnGD714FOiP6X600jDjfkn1bpINDb6Y9eIrPOc/fTx5Gjv7fHrvZNX797uSFCoeqAJnQtCsixM6NXBs7cnr05OBZVPqFHFSR7PiglXcKyBTUHh+xJOWtEdVicWTPFqmMwW6WJZQkBxYLCBi8EkmyV6dE2SBW9BpOlDa30+W0hsdaSGqChOK0jY8kKjXsM5I7+tlZMYe/JvIv+ey78j+Xcs/8qBrufbiElgmCySfJrOYjTvJuL3PSYZOZbvqkG5pkar/EUOaYnxVGEMPYwRjbHvYYw9jMSSi9aZnMN70ZpWnJyBe0Z5Annc1AX06TwrzBAo6SpZm+kp1h8KRvzYbNXtr6HTH2dOf42d/jw3/eWMlLfv3j4jVhmkwcvHcEi/D6x141ytGz2/id7SdckXHd0Jl3zV0X1waQapDZvYsOcW7MiGHduwqYBtOSYG4052TFDREwuL6bKS5aGsF0ztSt6JZCM7Py+Sxft2JD6cEoqnji6RZLQWltQsXXxzxdJrR13F4Xv+uacZ5l/FL5beME0+yhamvXuz0SQ5SEaqneq7aOe4c/iKdZz+cT3qPeiWMMZRBllhyLajNf5jkc7wj912RP28RhHooibV69TjQTxRDdzPkvPSIQQAqBLna+06XT1TVmXPrqCkMjUYoj/Klltji+0fH7tVN6aCo4aainFnkR2zn2YjBnovarR1yTBYchYsSYIlg2DJuVPSapgW6N/tRvwRWfw/T6+TYbPPsSOLS7pk4Jb8AUXuOhL9yEpeNaJHUaPBwf4xQ/UOg9STYMl5ab3YsIKqT0JVj4IVhEtSr+p/zBql+7PqlZVtyIQ5ZjTdNAwtJO8iEG1nCnJauvZZK7qrsvViODWLsdgQVi/2TLlN7bUQdploLZxqA0DAntmwiQ07tmAHNuy5DZuiNXZqr7GIh3OLh6HNQ2LzcG7xMLR5SGwezi0eRjYPY5uH1OJhZPMwtnlILR5GNg9jm4dU8VCmYcEITGeXSX7bJmAto6t04K0pA1B8UMNNWsnaSDbGuqmYlyNbYDHOsyulqqNBPJtli+gsES1fJMPGTk0jXztBxrSRf+ZhDGiMfQ/j3MNILIyD8EZCczWyMJ4pjDjMlY3x3MPwuRpaGC/Cm5WEruOlV4fGOKMxXnkYiYcxLNFFvEvXgRIbS7y35BfeD6jgABU8wwXPUcELXPASFbxSn8vm2yQziy84YrJJ0oHfeCPM8mz8OAQxsTsPmTK7Uc8rRNYMK+8L79Dps9nF1PIMSXPrPM+mkhHG4iJOZ0neji7jyUWC7fU5w3139ivb/HSYFnl3NTvMszmbTsu38TQpDKqct+dZHjUBL+X8sz+Po3lnksxGizH7du+e8cbAFJ5/SH+BOSyq1f4V2cGa+Ade/ovtVuGTnTcPlmsOwZfotIhg4sd8FdckeBEHajh2Z5GeTZgUcFtQ+/OkYC358MvOV5KIaTPI5hemvBibs0GSnYuufLVIpgYDRFV05hfF2EVsKU/WJyQ0KVeGY3kQNeGgB5ELjm0KL6bxLE/iYXw2YV89gfHx/VF0hexU5MD6aDpj1+BiAIs++AXxd9VtaOBao1U2jjemg4CcutUYtxwkAYsZtQdNW9uLVAzydA6rHo1MNgEw2bCT445sgB6VDvu27/fnNLk6zPLFcbJYAHSwA60eenX0+jqynYvsp6Xz0+9ZNr0mfnPhXk/jfJTOnF+PyF9PyF+fkr/+LR0uxs5vL5N0NF44P+7HcyY4GC/n8aRI7FbJwuNFnIMrgULkZadO2bs8ZSzFk/d712nxxmPOLo6vA8WEpFURLTZV+ncsfDNRn7NhEOzjeZwzG00dd7HVKs2Zkjrkv7bZePsdnDuMwP44no2S/XgyOYsHv9lz96JIcjg0Y5XMLiYTPDl9VAJoxnQg+7mxl6fxpIFL0kU8SQdEJ308yyZD6vdBNslAVZzuw4fO0wmrEpfHE2YUzpgpuS8BKY6Jn89ypi/hd2Y/nB5nk3T4FH5p4npaGMEWLMO0f8CgWOZwMIK+VsqS+PFH6sdHXougb2WDYDFiCoHpo3jS5L//yLueYfW6bau4c5RAydEFs06ev3r/7KAduUMIyMttCANmJhLjxtJ/arzQyk+V6hUXY1jK2xt9evHQmhaJkq7NFTZgaq6bRXaRD5z6vAECK7AAhPMT+N1sLvyR0DHSZOL8GTgWXTVUteEGwNSgGYcSLCIOSYhHTi53XTVt5AyHR24nT4Z5fGWvYOO4UEyTzAkZGSGZ9ev3QHOgpGP1X6HgrUaBsIWt8NjbxcFQPgKunuU5U22NYxjC04uCb+jiaJ4V6SK9TKRFJ9usDA/uAM2zi9mw2et2wWkuql1nU6DrzptOyFwhxao3vNQUJoeMD8cJrNpNQn3SAhdlWNgS2hO3pYrv7NrmvqepkUTKZFKjFYIz1RZQ+HRLoAS3g0MGWsGXjVAb5JrypVrAlya6CbwIt0HABhoh1rhQK9QK6DfDLGJad63cCHv9pFtjw+BmOdiB9jlrdKih3lL+ZVoMc1Fs3cKKmK2X6MsjbMro8cvNBWJECg4pLRCyOUJSAgqaE6f4ER4drR1iFgFpV1e/mvFQkqJKZzN12e3c33LRn2f5fjy7jOvg9zo9C3+8mE72s6G3XNjq6MeoIT8ZDz6e6qyc/zWlvNBizjkTmV8bVz5aZZU1DYvK86A5DYOFmc0Lew2+cgz2j+4W5SPbtlk+A/TrPluTFhQ8ua/5eJ7mxYIqhiHH12W14jjTycIBQC4l3jP9LXvu+HV4JMyA0CbSopOyyXb97rzZ+MeM9cVjHGbjCaJY/LJDlSlx9LSvIkrYHiBIiFVbzCfpQlRaShL9pHwtnj9EDU8ORQ9rXrTjwvJKShB4OcbiQn6tJRowtOyecGstQ6WxxiUYlnq4gp02DXeFVb6AIwzTK9dgL0z1BPjYBlfT8SS5lkqcTeCXaclOl6CprDhrAnmmHa/Mr6hzvCwWyfQgOY8vJgulpj2wZrdFY6dw0P40XRwm+WF6nUxe5OnweVpCqFeTUJhCn6awN1uke5M0LipZ2KggEMbcpDH3J0mcnyznSWXVWy2lgKdZxnpqNnrDVocv1dtWJZ1XbJlgq69einFhc433i43gDAoboevDv2Sj/nieJIEqejTG/4P4Zx7ZR+D0fZy32SyhgTd8YK9PbYxN3R186Xx6kU6Gwkdb7Ur8yH4Gf4+2j/bmc9bXoOuahQ95jylxcTDvIISAdyyje7ZIwhbMIndWd94aZhpM47AmGUzSuV0zE9RoNk38dRraFCw859U850GZTtFJnk6njBP3d6gaFr/tjQebxO/wB7deV003XxdjFWxwiDmE2+J5W6zG0jVaILhWG5eo2ZWkV/tzI82QU0ID4JoxHlGv3Uleraqj6CpVKa5PYxCVoW4n1jq1z6FHZVq8LCZtGbcJm5vBsh3lH8ftaPSxaEdnH1lhWhyyjU5yzmQ5tGoeF8zY5kfeaTY7EHrC9a3mo7NKGFy7M3Zz57s7ts+c766N7M6RiTs3lBvZ8iDDNmIgFgpxWJ1N5xeL5OXJm9did7FTLgQuVSug+uXxa9URbqHTevzV8mqjXuBU8NddwFPbWLCbeSWOsQ6yyT+OLasc5MN62voNZMQ63vqNtbLPulJvdW3zWXeVS35EkD8jyFOjxDTo06pds7ojdM6FWdcdis50RxoZeoL3cWFt2KWv/6MLpHfvWophyOhfn5S4JrJZRfnZsKCldy7U0TCnQh8PY84/cDjvhFjQRxhh/hEFdcRiftpZiUDH9BNYGPJnQ+NT+Cg6RJy4RUWd+YLw+A8/MStC+406i4x/348LrRX4yT3rjLcr9hJ5fK/olAQ2KBAmCJsdHe7Afwv0Lkav7GFLlDZqeR9oB7xsB7B2HwIJxY8FvyfVhJjalt+Gxn81DBs8UkIcjBXJK7XqKwq9dtRvMSrbLTxfRkH4DRL+LAi/5cGjCCEhliZf3RjcFgPOeYT7WWunQha9vt2prlg2KbEcvXj6qIE7aMKdpfNxHOR/0+O/SqLbAYywTB8EMMJSheNCDyUoWN5CV7R6SaotPbYi35b0xitLr1hZepPPlR4sp1p4zL5j1t2kLHQHn8JJ3ThOrs0tGNWMS+MJ1Rxwz50a3o/Z8HbiNBtdcJYWlkO5CAaVo9BPZUaZflMUeXeCH1fqeeDVM6/AVeuWj6kfC+rHSatF6XvHFrqp+r/RAiCqyxj8UXI+kfVIuu0IK2hnOMGhW7ZjLQiDjhz9KjqSf2M6egDnHPpn+Mx/HOVJMtM/i2+84Iw7R1Q8qhVup/sLs1YyCIWOu0m35tSPI+rHM6pb9YHE5Yg6T2iALawd/rl7dcIO+A8UnQWvVYyUJgofZVibhnVYbFr6AsGGe99FGu+gORbJdM4WSfjTF382rGkGP0RP2Iy933XmrEBljPb691uiyujJE+tep0CONp3FTPwOaoBhuhqKl/ZDZCPBYsQZgiBd+LbjjxPJ3F2Ofk8RFfC9Fvu9uQ2RvaK596KN/hasuOvR9la3b+oDknqjg9Qcp7Jjfe3bXzcqdrz25kztvKwrw3oPJXSNt40ifj7zfhbicK0NuauTPWBq5EJSJEBIQnpSA9I7PYmjaGpoKfs1Q00UWDs43km70Vavq8onspOkPFVvy/3qvejBlj++YLA7o0P8XYMix3mgZnv5FKBq/4yKRytWrDtpDHPvwZbdR0gga1ogRL9YgmPzxds8n92UrdxpvBKubrWGHBGQIxLyjIA8M5D8Mrnc2x+/tqbjkWpnbiahvjeAQv3NLQrz20vz8dh8fG0+TnmE5RFj7kX0I/v7KHqBCnkU5RFbl4nCQZZDVJi4dt9FNw7Sy7TIXEcW5TaytcRTxgPjRglIMPYUlz8GhnQ5502Wv4YpChj3+O9sOHDd6ihsTnKXE/E9RV3PT9T1vESvw3rHkoZhhWLjtaeZjgEH1MldgbomUO8hqkAIkzUknZkRpCXUlUMRVNMaJmxR9lu2YZMVcKbH+6zYwJsmH3G5s87VbL7EAoYR/kJ9eWG6Fe1xXpAUHmxhrCNM7ykpnZdiaXVXjCPQQy8w7XtGikessS/83lCtDvYEJyKkrki9YJ+PWl43EKQ0ay9tvfEyWnO0y7ENcOxqn9d2+Wtcrkf/S8eHfOz4kF9bx98X9mW3O/QMt1Qd1m1+YI0dUxOzgtgK/L+dWux4gws2gCHYcXnLtVixnDkK/jTkPZOpVeJ7xrRzTJtvQW6T+sgKxZqQvXxj4meetU96qt3jAMdVuQfUkTfEv8fuOE9sx4lLjfHbRO6BIDXpTLAdCTqAtMArNm6M2cDb8GyX58LfCSAk/7yIJ81BLd8A76UBLnJ3H+gkSm2C2WSGYCfRfcRVMQLFTFCNaX6qQ8DMPU3A/FSHgNir38E79zI0RzELGquJCdwAd4xLoA6KcBHcwQ6DOmjcnXCHdCfcnkCsoZqbUx47nxE12r4rd7h5k9hJSKMuPUxUQhp82LpTPplDtPNAMhyPtpmBpiAQ+I0gXPNcH70hGz1WtrfvqDCWcU4Y8iPCkD9zDHnkhIm5FybXCStG+tOZ/hQjz4jvaAmFjNrHjSbIR+yf9ibpIHkqooACvv/+JjhmNx/IrzAcWgZ/tkj/eZH8bZwuykhsAYkN+NTzSTBNGEbtahIk4jTO01lJzcwcVwR6fY/A7+ISXGnDA5U/TdJRKa7+p9/1cNPin6US5//0mcR7D7c95Im8RxaUl/i/hzUbjJPh3mSazYZVVfOe6vptLh0nXdNZPtrPaTZJFiX9tMFauwnHWH2/xXl2NStB3Wb/bPbFfw7mRT5Z/i3LyhrcZ1i9B5vAgsf5fgzX4ktb/RA42IKu2vaEvj+O80WeXBS1BiiBng0ySPxQwj0cmvSgpzZ89CyPJxU9zWt/QKHOzifZVZKXN77Xheo3H8KQuU8RKdLJb1WDjWsWf5Ls5+m0yGZlPQfDjf1HCH4Zz26kUg7i/Lc6o7y38ZBCrayX4wWQX2STYTLLywarHKfwT48kkcfLsonyEP9DofOTkDL+u5RyAdz/O45/S8s4h2ofbACJ+xT+m3iUzBZxmYZ4WCb6d5P0MqlowIMtWf0mycK7HO6cVc2YzZAE3uWDcVrWeVus9Xwh7G5S+EfJsLr1ZM3HMWj1EsY3QO5Qda/fJwkkcYXoeqCbew8eyE8ECVBU5VPnPqt7uxfsQU6hfARDv91/KP7zCZxc5P+8yNKifPb2u3CY3SUpVK5SoKuABjH9kmR+mM4qtR1XmPcp7OPflpWqp/ewR+utdFox97vWPw52NhxVqfoNzvgmWfvzNE/O8rTMLOndZ5IDxbXhjf3nE1ioKi1IbUZuenPgeZYnxaJiBHOtCSOP4OBiMC7SuKJ22rh5Eaez4izLs6qFSv/j4I+zYlHVeL5EBizwF+LeZqncepR5UWO96fceSPtqw9MbFeONW6/6Hxe1cp3pP6A4BrzTZMIsk7KRtoG0hU3gJdsEL4fJVS2b3x9nL7NFjSkuZplvVL2aDdN4Vqrluc39sC/+87FHJYPsvjIw/Hovs3xZObPoFles6kJaQjV4uK/jS36HpWxdUuh8ZtPoTC2Ze6BBG7Ird1sujatZ1cLW5zqtTwy31wlbVffH6fl56eJqNJOvWV/Dha4KG5qP1962lASBX2XIb3bDU00QKDVL+/3NsEHM8bWmqJp7Qgz8nx7dlnKtwddV8w+JX2GmQFs2HshPBIE6E/gBbAkfbpD4lbaWsLRpW0tQqDS2QNnyBbN3n5ZipanQEzv4bXpmcRLV1lavxzcr29J0pYgskmRSNby3pRujH5BH9aDawiPVpTBNqnd6XQqtohP0jKYEOEtmVbNAq0Ybt3KfU2JrvInzLJtVLLrUJuFNMkwvprX8Zd2+bDYx9gSZWl4gXxUK5MpN0oNtsU8jFICgcHiRzydlLYBlvwfOvn7vIU2iegby+Qu7jF5vI0Cjer/T6/PtrtJIJJU5xM1V20N8SPW2NmkqNTY+9/ty00NsPgURsfcp34Q+BAJ8B+dLJR3Oqhe7vvyv5ztj36SzxX6exNMqp6qeYi5+sVgeZUUtv2q/74/PbDCIi3RWyy37wBucb+PL+Nes1i6GexzvbxAUlpV+J3+FfzcZvo4HpZVuKNH56oi7TeqY8TTmQR6flSkTmIrglvVdq/WcLduU8hao5YY0n8QPSeRyBSS2PEJ9eDPlMJ4kdbZNMN37YhXvkjQqrBgwR/tbPfnJx68x4Xv3DSMPKBo15jtXoFwWhMviMJ7Hy5gN+HnlaQLXGt54P0ziwfjw4vy8cvfKZ9yWj59fVGyluJ7a9muuYQM+5ArTR51clCkorhy3u/KTg5pdDSsd6ve3lUHuz9XKlU/OU0JJVE8Wymxg2nRZdfiiXYKEX/AoW8YV5uG22jATGvk4Hg4nSRUDMLq4T/uhj19lquuNkz/Vj+PZsKrxfdhj9LbZP/4xXbWNsbktuX9wn0A+HjOzuHLbu0VO7+M0mc3KXOkwQmGT4++Yj9PJZdmWnc8L84+DvMK2xF8R6lhUgPqQti9rbWj6qsP93eHxrMYmhHZV1Lfi1JGbg1+9jbqvfDuEY+mkdHffU0iEi+YkKXMslLgVTsbM2pqUHkxuK291z5sbJ9k0XmQVwgZb876nRE90GAbtpu96m0YHv3rlhPksVHDXa3fVAYFwPQi3lof8t3ESL6qsW2EcPvRx67jH6TZz3ONp9lu9eAVfKdTfoXdp1Ep7ZzO416ZukYsrfTwrxFOZJS6QqwRS+haQRxriVGJI6OJciM9wppdgPt0BivlfzuFWsUsWQrQaFzPJacNNL2bX4yL7afcQfODevwHYWTnLos73orPqaQkm14tkNiyUYP+lYcHnEedMvw7Z4rKoQHJ6gc3igb5LVVzME/it5QkartQMet7PcE1n0Pda2StpZs+D7pdA922pHPKhGhhQ4kIiQx78NkuKomp8aUCTs61epuaKgVlAAu79eO6SZd1A/ArJzn7N+NYWWsf9V/+HfWd75oWdjBnzqz9TfBvAJ1E3+lEIOXoU+Wr632XqgJD+Fk7rZklDR7QvcqZVjxfLSVIyvjoqNG/nhvlQVW9TKT3QSPDyyYnRQGHpceLhqLFCYaFxZCfoaZ5fzPilhyaMLznVJzKxEYw0gDRA6letE/QPH8ynBh+cDci10YV/5PedMMLT5DKZcIQeRxDfSxCOIOExR+hzBPF9p4Kl/Uk6nycCb8Nwpn7mQmnpNso519eTLvrjj6jp/ASJUeBtE4bH1Y8C0QVcMR0lg0UM6e6C6km8h3zVjsZWx8GFq2s0i8FExjl5YGm/oh6Y1UqRJ0ItTzf3Xj4TcWpV/V6NlffoEgwvOVUlp+jeKq7u+efVR1Zl1TIQjxkcxnk8hdeSiuNkUS+Hm8SE1H3Qv/jNbPVEApR1jn9+seNhPc9ksrjGesMvVW849Lr9Tb9Upxyliw8O4U2gh9tWM18ksyRPB4fxjGdHLHsJwX4BofY7B8kMdDL5IsEcaoV8hjx7GVwHQ9x0dEHn9bPnJ9ZCxEq8dFZnI/1uQZUhynanLfvFhHwID5qXr7oCKrhoz+PhUOQn69lpFOHWzCCevFHvU9jF4yxPf4fXSEIAZ6OnXqZmWaMwm+u90lDzJYXA2wxUBSBlnvlbDQ/xugHb2ehU4P8uzxqM+HrIxymNJAvt9VPABzJ1q2EfStFtpgWRm9vJwD2AVKD7MYRoi0QbRfOmmdbtKUc31oaxEojZ2ETfeFMatc4TTqtuG/TDQoxwwAJjJZhTDknwJ1WH95ZSbYl/fiOkogpk7B95meEVPNEao/O8BlFq4xZ4N5oy9OKABrAfHjB4VDssBex3jqPobqsdWpeXtcWz7QsCP/QQh/ea4lOOiHZIwUc4ypeemw/gLyVSuf6FVAovtHWJgK8rOvcJk0O53la9YuKuzt9y6tu2QOB5NAsGS8zBpvI4u7bGrWpf11QJXCZzoKwc5i4FKpu5bxDdaiukYqTem1Aqk3xxwuhT8s0JqYrJ9yMEqjVZnDvcaFLSTxDMjYuUbf2antps05pCO0z9+5+K7I7zoEf42SJiR48NdrlhF1uIl7oXuSFwmBX6UUTtENS/mJc9V3wgUTkMaXCfB8cgsrjvlLC8W9KenZI2223lTEO9PiDf4sgODlfVbAAYpNd6nZwvhIIjaO0/e3vy7KgGNQEI9PbZrEnyIMWjVy9e1mGPwwG9I9iJCnJVQiaFa4T6s1Rp324YuRyUDqIgu7vBloTbGhg+Lljn5N2h7JxQHc0Gg4GOOcnmols8ItaoCdOhx4xH7em7k5N3byqpCTCg9jRbLLIpNWQ8qfiiNCLUW4+vP0501aUDxGdw12eaaE9gLNhOEilvjx6lOAym1fMELt3lBh9rBwK9Wing/SLad35qWesLd3w6/irjAH3DVrt4lNiOLCUzC2sV75bobxLCc2S9zH8n/VhBDe1R+DmnPWGBubrj7usVByXbegXi7eo1bmhTj5p3q/aY1fISzhWIx7nGDXGOxHpLnEvn6d5sli14/pNvM+wyZu9P+EmN71rle6Fs9u78nAkKHN9b3XD5qV/+lUc0W57woJAto4eDLMQDQcF7m8k7Yjf5/fd0u+o2zCFgmlVvpnrW/E1kYz8RYPr+s10BNeaoPZoCs9QGsuapg0/NVG/AfsuNujM96jT4NNzg0+oGn37rBn+Z9cOkENMDVuXD/3eefCUL4rfpudtfP1fpudBe4nO1LtlzKyxK3PIM9B5tFHzF3pM2xN9FVtTVn6CvfQDLhJKEjhCdSKMjccSl3YlpkZ5NqMeMPopErJbJIHK3Ok9Cf96xI34S/vNP+L7OKWQOLyLz0SLrUdXrfiA8f6iPKOej1YWk+zH4eK1G3bm995aDrymXDTjdWDmqVneeC7yA11wUWu5yCU/5yfXArpr7LiOMMIz9N/F1k/1p4+S0PNkwmxZWQmP67OINAxvEsHuAk4tRnsQLfigUz3gGZPvoQky1aTrzJxv7F2cCRyPvlmQ+DXn5p7Zjf5rOQgc5T3YRy2xFuGNHxAhh7o+TwW8HInxviNX+DaRnniyAKr33B1r+gjBNqWXgS4iTDRtanKIjtTgZXOhcbBcxfTviZDILiZPVgcWZzmqJk4/NLypOFQqWZ/OMJ6WNJ+UBYW3Qy+nvydEFuOrK1tW20uCTydN48JutOHgRsY7mybmOzXJ+N1FZTsHP8n1V/Dvn9XghkvjZL14b/lkRbjhbtVVJ5/mr988OdurZBaotVnNXXJSDb8WSXJsvq5sIoHiZ0HjwX+n+dW84fJtcYQGdZPAyORc3H2//dqFJnFRg3XNDdAXsJf2+72WFQI1BIgbHHcoY4UW+IE3n0pzana/YRVi+OMN9bg0rVwYIx5m8epK+iRfjDmjZXpseRRdcd/6UyqDvVmhS1yak3htvBbQA0Z36/EFM8OEhM6nY0N7PkvPmgP1jtc5ojs7cmIVCptRM5YznENPcZCa7eqnEcAQp/aGKdWPR33R0eO3I5r4JjPg3T2pVhIDsx7MfwNcyb0fJdL5YQiw8w2+QDfakBFx8XsNkUnExGHm35Hx5UQONfxId3wbm5Y/sk/hRu3uv0sVgHHFss1oP4iIJKvqjZ6/3Tl79/Ozk3d9eHZy8fES8iSbG+rrmZmc1ui+fwe6ZIiwH/7pp3Yqkn74jOBYzidmRZA1tqkVUXEMvNOqaJR2w6tSwmoi631VObUfztF0NQg+LW5l151k+SPbHMF1gcT9jY57YeK5C04r8wCKwIj9Mj3/9I1hTt3MGa3HbIVjcJfjeIdoUOIZ1TTC5T/dpNhu8HI5DebZuoavCE7uEkAPJT1iTScwj4BZZxEdVCXkxv2vRF6BuBePEnOcGp3kt+gBIsh/Fs2H0EtUT6ker//jJsbU1gJNjZ6+Ars7gDVRwF/HTq301FtvRJBs9lxPBNTFgl7IH11p5bHfvczYJueTpJIWHz0+yRew+7G1D7DOVtXC9cocxW1rMQaVSBcR+ADWKKI3ts87C25+EdxrDbHABT9P/DNu8dLJYCq30fEDspFytTQJ9HMGGxbmf44O9mx2cTfYnKdXadzMejRAo/ThF0QR+U48Hef/ZZMrWiTy9JrBZWZ/BhMoDexO/nrkGZJAcxtbn9KZu9V1invyTVb/Ym6VT3sPPQaavDgjyxSyeF+Nsoc67Q+VsQIpEEU45nxmHObPNmXySZCZ70fYw86MH260xmmRn8eRNxgbZm+wyOU4WZkFQw6sTD4fPLtmH12mxgJOBZmMKCFOGwLRLk5lWu0/Qo6KlNTQT82ys/lTFU+g9d6Q7GAj6tkPCdK6klhBPRLCxrkpezdg/cksSwB0rTUIjq21IeOKjbwhI7GqeZ/nUbkEnu2L/HsguWElhlM4x6bw6si6y0GNQPH4yHOIIoBKMjndFBSN23LCoMB11C02O4SGsWoNJOj/L4nzYqKgfnWJZ1dcKrSDooeMsi15J6BBNrfQaXVclKO/zPHrbvRIxQ8RwB1QOrGrbCI7rANGxb7Oj5JypLHs402tA05q+FGATtA26fcbmoHyqLqwhhL5stIM1t1wXJud4NkhAb1tsly5zNveg4TRTlwI+XSzZxhTyeMDD3dIlar3drZ4hQjNCvydc2VBTy4CzpZoc5try7rizmfbxuFCf4WgTW2t5BuG6tF0atmL+KPMAvDGIDtkiQNZyQVUSJU/+JsmIoRwms8I5/qNsFloWFCT2mZGUCGdkwEryHJOWIg6cT2AQt4+8lZMUIAKD6J6E6a2RuogdhDzVkKfmsaokznkKCbbDFfaKMLQcb99NjTS+d05nw2eTBObF3lmRTS4WyaEM12kmE+txeC6D5+AssI0Y/vST3M8EiofXzhuqS/P9apwyE45Vpvfm1tvrBWSVgIv5jNHsSizz/J2qocg3kZhX77k1ZXPy/feCQEfFIMGpc0M0pcEPlVCzsAbiHDPdnvGYJYglju7BqUCRPJ9k8aIpqIo7KFCKvTQcf4nxT7J5GJ0Vuti2rI2lpZSgaCvRMtX6BmwEifJY9nHDaeu9z23svc9orTt4qPZy+4ebAGCdyRFLOMVgKRdpE5rD6zbjzNLt1kwgfETOTKHGozHEPOtWAOzZs6hwz7hKR3xEoyNHd8WERWItEZkj17LmCFn4jShVCZVKQQCwpiTX+KHcUslMeBiXPDsLtWtlpYEUFCn6D5zJXzrvHYRlFcKpQYABJtr6ONC/8iBgDR52Ni3mU3OttB54C9pijs/GOjiIv09W06ZqneBS/NBYqBWo8YvdJAkIeYtm2czWKZjU8SLnERzwuTMFL01zXX67+49ms3Ov9Y/WeusD46mYM7OtCQ6y1g5JynMfiP8x7qImH1F8NLE/j6Nt9ufePZunyCIjZhXSU5rdD+kvLYuDTw437/J0lMrVWPz7NGFMJNbqa8D1Iq7XYPFh43qjwzSW1EeYtw/dX9oWsx/67g+b7g8994cN94etX3QGZU/AfpP2zheOa8Nde/TQEMiusOWMXRRqMLkIqsOd/pYMgZzeXkzPmKGEOokTZOKhMJYlGD0Xo6QPrd7hnQdZNWU3rb1jC8vau2UlOSW/UmpAzKH1yZF1kFHnMEP8DylsMcBD6C23T91RWo+8g+VRDcnlpsxz7BalvPhek7PdBfNnyF/f7eIKPPKlXSMNCHdJxXlieLWgU+/dc1dW2va2Knw1ZITYPlXZI4qEpc4wz2aZAB33ROi6tTVv6+xVS/zamV5MFul8sny6fNNElYDuc7bc/i7JooQtLGsvQlhYzl6FvgLubmj4rzbzKbzRTT/365NQDMbDoXORyXrkVmXwdmFEth99PBhy+8nlxHajYBeGZFBf50HuoWbJ4cramn88is9eKvNHnGQZWwZmS1xhNIgnk6LRKie9awUmOA1ymoA8XN+wLcCU41ENcyMmLW9HaSjVpTeOQwcbHa4M3p0DymNHdkEcPm4uTRAJfx0Ls+5EF7k9hDwmgTOw5kB+sIURPjFT8Ir03IZsgkdY0xLeYfjDxsd8Eg+SZuMf/5iBGcf+xUMMQJSEGv/dsGSkGinTG4kpaZJRHzC9rJ2QVI3/fbB3+t+szpkw+A/iZbOFYjhLUd+8e3vyEiG/YTuhcX3002d7Rwj7OVNpp0mc1yfw8t1PmMDL7AI8ZrW5f/X2p5NnmP10xkz/FSgcP9t/9/YAUThOBtlsSFIwUzc0fNwYC1llGY4YUHZQP8pzxU+3XmdsVOq9Llbcl/yiPBxeb3Se59n0/el+luXDZtgt1y5xxLXM8Jsqvr3lxKwYU7SQ/symMZOYF2k477yHoQ5Wybxzaj6+j57451rCiSLOzyVCEEqG0TiP1mt73V1x+E2oiqNW8gZf9fGs5Ws9DMAPmwUb2gMiiVxlDWTgTmVbZHXIQiFPGAk9G+iRICV13FiLlIkl4+sV6PpFOk2KRTyd+9fS0ILg9DRyqV7VO0UF0HHNM1Pg4AqCE7dgHPIwxS2agfBBJtQHbZZn4LNLkb5Ynd4MeAy+9OE0GwMOoJYMB08fFl/Rxfo8eGyqHqnTvRd5PB+ng6LpYIk0sfCaAmKYJxMGSz/Jued9Nkg6TDHq5Sdf2garUCPNkcw5K41StojyWEcU6DhMzi5GI+Ng49iTbNRsCBKQtysBQ+dRBHcRko48jbDC/4QXMp4XPO7G45HtDjj/yNsO9gITNOHpU0MAcgg2+kMleYUhLgRCwt2mcBug9mkY+PBqyrj0ZQtIrYo4H+455q0pD/dROyxoUXw5Uo2hSK4HiQgSIxir86ywTzUrT2tz1UdsEVowFTdgncNXRkvZds0hWQDcOiy73WByc3vmzq5HwNlmkfO1POw85Gsrt2/FrtVzx5UisV1ox+KBkoa33bZ2VDvfBQ+TP+kusuxsrnLrHlfbmrB8W/PENXMd8OC69Djqr4aol6EqzFAklOd4lz70AWiYiQ1eSsm/LhUOvpJ1kABNvDTiuAikhdWIthdSPUQITSxCHrNJItTvIL7QkZfWqKkOFzN7VXpM1qHxSVsozm0MQiOUre+YQolBUrru6/N9PDVhYsob4fxiG1zQgDBz73JGnRvkaF7fqQjdMx329dRO2WUU1WTfQVZPbOg+yP9acZnbJivLp+nl7P9fKKAmMqJcCXmwtjDKo8AIAs2CGyHtKPGlSkeW1IpMDIZwluyaKiM4y7ZJOCytdABxMEeJyvivsvtphOFA+jutDScfWvzqiCXc22dSeAV5fNPebHiQXc0mWTwUNjd6g6HN9hfn8cVk8TxlY5WtMu0Iv6agv6kLOea1BOxM4fsP9OYA31yizSMK+oGBU7XtVMZ4jb0mfr3B3u3b7zqg60JOgxUe7FfVMzs+BPnKjgcXNWStnQYOMLLevCh79OLw7QsryMaj7/5yL2rMZ6MGFelTu9Ljn1evtLh0K/3kdom8zOEJ1y0mJVvTM2FVqG6JhGo05WSVUW0fB1iHyaRIHFS7GvNki2rPOLorhz8uk9KzCV4ZckJOGOO2m3xF87VaE91BUO4DquMBOjAeiHquH4Xg+nz076SzZ8e6Y4omjXPVtHTSmuuavvNIVa+8RkiDmvFxxgB+26lXH5uvJfWx0htUKaf4I2d34p6kSULRo4vZbzN43xWGW8PzNM2E5evesUFXQevdgm2rxdG6H4quhyKryLjFhCdOstporWIKqC3KvrHXRVAadEP2G/mcnBXWTz/ng3adQE5bL6QPMMLVoQszxIZULbva5xfyEVoOQvjob7Tlllb07yCbzhmnyXBF8dmXxlU73GBIPntLpnVs9tTcFSmuzY1ALX8cSkMGxCzi5Xd0VCJHh7QIewtml55dLJJmY8xGS6PNaVRAKsoNzyTyEXlc0jAt5hP+Zq4IZdtxb1ydZcNlJ57P4cW4cToZNiW+R28A9+xMS2wCOb+iRRH4VM8xaSXZec5oFwELnw+BUQaJ7hmQORsfsYVQ4Bk35CQraFrKRxm4y0Y7LAPA2HsZokecPIWv0VkHTsME3iBcao602IXEb+eGSBXZ8hs2of2TCCd6mw0Ta3i4cAF0P9zfur9W425r1YVQt/xzbhsQ14pCeUvq3gi07hTX824Jt/t5ySuXOJEEwihxqX20MkSIi/JivRdnIR/5/VtqgjlwB9kFU4dBaO/2HxG/ZAEEgpesXrYjl9xDY7BA3lgXZ9gid5kmV4ds7ZCLufpqJ5sI+lic6knPivHvWMDgUVEpKN3gcH1M4GLYsdt7l3E6AQpqrFmNidaiPrOi5x31kM4a+0w8kGS4dOg9howWOOrQq09nvNAHjvL2oO1V5iWswDVWUKT8HVFuB94qaqPOmyQumLaUERxzfpGzzZoDNxbbDl9e4GaT05EW+JPdkOcHLppwQGmSU5BjOSy+/15WLq5LPmF7CSdkeG7dpkT5SXDB3eihSBxiRc3yTY5FTAsP3yhxI0altPxoVLy9MdHMbESpbsTyuecMmntlg0ZT0orLkuDKtKw7FGYDNLcv4Nqi5huTqgu58JbCI0ukUNW8Q718ZP5n7UZq13VkJ+FRlblzE/XA2uqceHsjVU0zXA8MtX4pXfv+xLK0N9T15areoNIz22wveVf4j2it1BGB50z8mmwNrwRkvq3GCNkPS9wPVD2r9MSow0z+iX4r+P3py7+xLpAPVLUj8USw6eS2VY+t373Zh89zpdnO1ki3LrZXqF8P1/XnOuktV9jPuW++2dveeLDZCg4o8xhLxYiyH1CxRV+c81eYebHc0XV3XIiS0hojzXlFpbL+fmn9/ZsMMKKWXmktvRWmvU4koMdB85qr7hI1DuOZu97YKFkB1l54em13+cCXe8TYFAOKB/K4VoBcWM/EvGDWZhE63uQRDe7teGYLupuKCuuwrd6wgMtJ6exnWYgt2XjAkyNZVk/QmPTi8MvNSRccG5RaapoBN8sJDxERpZQb9BaYLOEP7CeqWL+QsatES5nGBOaf3S6GkXqSHWjnjBi7JVHmONJcI9oh53BrxlaVbi02cnllBLbYhPvx8hqoFVIhIcPdwq5hv/9lqda0VMVsLplRbMJhHdV5PRUvdT7G8mUKt+vuYyIab9fFs/n59Ce1o1eW0xEtp36VnI5oOfVXk9N/lpW/cuec2J3zUs/lqt45sXsHIX7mMP46u5CVBfX0poJ6ejuC+vK7pJDBQZgRMIPukVZEx33Riud0ZQtD2XTDDC7rET71CZPtdx1Z1/iamVEGXRdu6cMtKbhrtv8radkKqtfn4EnpEG+tNCH+2hb/tS3+t90W19wRf+ZmOGBZ198Twzlr4V9nsxJN2q5lL2oGAzdRBmo7akR9OIArRGZnbAPxfBcncGNTxHXyTCmNLmxb0D8d9Uf/NR+6kOSlTj44sn4yUWgVJORIW+uVAJxKAJOS2wK1cnKj4Jqvn5QbVe5cNLEZ7lBc7lK871ANC2TmduKY5LwjiDYbrJi/RJ0upszsaUKootjUOrFJZTRYMdAQ926jJkQeChrhttpt9NvGjKZk8e26jVdfr+NsTnfpFgQaWNF9HKZzku1P0vlTSLDqdIJVBSRE0ID83Wr9xepPRRTCYKroAYzI2j5JSntUtMZpvNdosVwX36xbZf21+tXldTfQiFAjy7tWAnX+b5LM7U5wyDcbAAJ9wEEzngMnnvDzTKtfFUWeYL+CpEjCr7LxV9BSjqNKgiL3vqZ6JYy534BtHoc6i+JizlREuCrtWaqsS6bH15WNpTs5VFtpH3t9y3Pp2xnyIZm+mzMfZdNXYZrBTPoDdcVYSEXxO5ynzvuCVOJ34jcVDGulvdeRsPZrlPPU/SmF+wJUNvy4WBwms0BJ6D1NKHuezaic9ZAamt+25QKzeAB7S191fpmS6MU0y9in2ehNNgR+T4/xD50DYcLuOPITsnYlKMsD15wlHHcqP2WW+STlL5Q2Ftm8Qcn9yrnLYmQ/dm+qyA5g/6IYIiLikXyYsrPIoPSno9fNBu+1dbgYYMUvjVRIMp1XF6eESWZNK6kAPyewuj50UXTu3wZVIgNRKSUxN9/s7JC8DALzfkt43sUdhwgqokGdwHWq8q7/Kp8Z0DjxhXhD9AxL4syWBIcIyeIsStnEhkuw2Tl+ldQXzTnbYKs2nXX426Gd8WI62Wej12qWTxa2YXHO9MowZTsthz7IlLWc9fxQj+yRjLe1EeVl/W7bGqYmEFcQgdTZPOn5MRvvgCKZ7WluyzF6GqPvY1DCkFQCXati1GV4esqmM5Mx2+MxAV3MIU6ZqXy+IyMi1X19dYa6HvRU8xz3/Lnd81yRQTbg8844LmSukvCGbcS3h7C1cTrWU43nOIgOOun9aXPejq6Z7Jbsv2vY5vatydmZZXuzRcq223Fh9724E2fPN2gG/grnw9CQJv7xe8gqygB70Y9Rt7MVPTJuiuueHWV13YPHLkVNCmbpwCwJmOu+Q6dP0HFglh7MJ+tBPKG4bLmfJcwSOozdGNBRBwJnT7KmEKxTBpKAMiFsu0yoHBMbqvoJemnOiM377jt9N2Fr3uu8B3qdU5q1eZ+X971ylz22owYLvwmvJzop0DtFfJk06zIGBDiVzjW83cb+LuXfK/l37GDAqm5TQeu8yaTGL0RyHn2vCDYM6Dfv1N0UBjgHrw9/5k5cc2h4LSiYjZUEWRKp5oAl/zC1HQk/z5U4+bE7WGiLTIfmi1sjhXZCMsP5eVPgo6xVE/6AtHiWKIfbwqxnC5RzhN/0EuW7XtIzhqBib1EeG/hynubFAgakNJPvRr1On00bSYsnDL6rK8R+X5E01028nk7DgQqcpBORwBDQYjMVkgSfZVM3EieMFBXqpyLZf/Dk7FS455xH7ExCH/24sy0Or++On/u912ZjxHiFKWuoqvtVVZZjvKl8f+5EM5YEX51rTrdzSXu1KQdYTZo/7kw/w057a5NxmyxT5Mv4tJz+oEcpGdbSot9gQbT0I1qsRL+ZBasduYXLssKrlv/buNUqtXLrq+hPlUuacwhTOma+hRniWA+E8eDYDj7EFX7wVkBdWSeNY+slWwFhDefPMD/yehOF6hqhl5hdWCi1hKY1NW3Qqz8V0zuwmC0gSVbxu9Lrtn7UXOCEaDzbvUTzFhoy5g3BylXQXlew6uDLiYXBlhTZftP/99huemk78bD4npPyg5/wugBjW/tt2CYdDlMMFXugz4VPBNZ8ELt4IKpzlAxx9nSdd0gZ9/x0k63LW7x2OOrawu2g4eGwi6Nci2OvLe8abmV39ZJNpDVFq/Gh3S5+WoC/KsCEfaVma8/bmFIUdEYpC9+r1TlMtGpeSsyxeve2j66e+9V7pDQLNiF8Cb1yTvmz79AfPXN36HjECRxuxXdONapfk4/zdYcm5BzlI42zCd/uyW+VeBxKIctv7lC9NT3l6YfC1EqIlRsqrmgn8TK7WOil7+vpAmT9gOwcPr6MwL6AYldhbg7/naWdZ4Gaqk7Che6jkuwIPVPItXzTrQ9iZhSPYyrEyafZd2hWkySpGf17LR4iIKRx7ek/sRV5PolHBTN6+s6ip9Muee28bvuilmbj4StoMVoN14huYbPR/e1KW1iS/7VgAz7dfDHnC1TfGUk4vrx0Beu7A9OECkuu1c/OiCNGmz/evPAUd8zJuDavN64gkapc4ryQOopm36NZRjJI7VPIQgJBldtEpaPQTlgLz3TpgagVqvlJvH0BdztGJnGouJA6UyY0+9jEGk24QApVzD5axWV+Kv0uTJNhtaGSdrTG/+Xfnae8XPYdR5jlGVI752eTSTovki+7Z05kJWD2CdtKRzIZg6eNi/DPwmUPEfVyzldus1WjUExdaZP4niaZ/Tma426GoJcOs8lylM1UL80hkXpR3TF8y8ph1RMpj3fp/KelvgZOkt75Og5dfDGZ1/uh+0vnPWxK2c7W2uqb4lNZTD/z0hO61moFnWvQuI39atJyLlKCi09lPgjlvzZtVJ0iWnRrTUH86xpSXMMnwtMxmGRFEvJd2TNFDSxhzJLDyp4c5JDqrTykGME6rhQGZTtTrB+MO8X6uYYbq3K4Eg4rZ8QKiK8xaMO8pDQv/xuHbuhAqviqQxc3cR9uFkYN3iENv/j/ZNwiIMvr9cGqPbCa/Cucoyrf0lcMyFExHCduMAwdzOHFzOBUSj4NIokSFXXjvY1sRdnQnFiROZgLG5fgwI3psWo/0A8IFPmAx7u0eUInMJyZLZgP9IefZql37DkksCUO7KjUx6X5eGU+jk1NAKw/L9HnK/R5jBLtTnmGs0Ll5oGI7aA3wYRBW5FjIsRWBI/p0EEdVrZ6OJkIhyyBc89K1Yll1y04TnikdQHhpWx+eHFcyviugBvJiJR9ux4sAIgzfnWgXneQOaZ+fjFMzgv73sfTi3QCKfZaDiSEhbIqakID3c4eT+TGz/l/eAzNBd0XpcPdBjzADafXH39gy43PJnoOiZX/0HjyGDz/0fVuo9uIlvxfIfbdxg/KaHZxZIcICPHZBVl/8nhdsfXkh5bzDHlSDOJ58n46aV7Mivg8ceaq+FHfW17/8P9Fd/7rv/+nubaz++Pa77+sj9pRc8BT6Te+/y/IIjjoDMZxDlEse4tmFzho7FjRZpVxaw3IyfdIhKoVl6N719PJzhnbE29vtqGCs0UW6/cKPjKAfdllKL9xnQAZr8vtjuThe9c9Idjrnid3HsnCC5dEIYSwCMw+gakKl36hemy4IdaWRz/wuyoi7ou3dcjT7O6I4rVsHg/SxfJRA4HFk/k41oCRhOSjR8Jpq88fKj/UDV6xRWxiUnjkCY4/KY00QQEeq02tQd1p1fgIbXaUVHjmAUlxTOp1zRKVLv1eRTNVnKuWTlVx5FpjqlYO1FEEGGvzGGq/yCfN/7pV2bQaDiMa0NayhJ6vH8fjKv4nOKtCafsbj9dHTxpOpCBBUr0VqU77+Lb/JIOkuDo4A677Yu8UbPwO4zyeogTmemdfGcGJsX+AL0AFekU4BtwpzcYHAKkZveuB4mnNgH/woz89tkojQEtm2sTC4/MN1t6Vx5S9YHO2QaN2/4exD2FHQuRsw/nDkv3c64qCR+Ir/8KH4HWfxtE/PxJfJAGO8+Qf+T9mj4tFNpf7PAEr1WsDCta4XB85cu45apbBYSVrQdpdsk7UKViqrrVfu9Y+Xeu63Wd6zhLjUGqJ2+nRlh6JpJWmdEQwQPcoOU94Ak8ZrHdBxud2Gi3icV7dstWCrsKqtMYiAGdY1ctAVLoO6OCRkpWAD3bOrq+pII0Qh+LjardhrfBdaxG/cZgXKUr36i1BY4XArX+PfojElOGJnP9k1tkqcVjUcfLqHbrSEUG4f+VRANuQyk62DwVaficMVHc37fMCAjS/VqBlBHNNsJRYZecns5rdrwErBwB2y5YNgRscRP0v6JISvcidIjUVY+1gOREK8VsyA5dA0Snmk3TRRHm76DNugKf9jQU/2YZydKRd0Tn80WPZL8F9Ce8Gndb21exQOHc9cCC2xizEcZbviicRGhxt7TyephNJjNOBFPceOgeFGhAgrtBBmCvqV2jz0xQJEbLJkNlxDfjbYDYcm2b5NJ40rIpERxqkdBFP0gGgiU8E4meMEG5LeTaRcZEU3B4SBhfIEe08+Pm5Jw0eYn9/KxRp+J8QwFU600qisIiIOBCpG3h1s1AlnggLyHGucTLoXqe/9WVDktbsWKFVo4/WVgo1uk3VhSJzHP1105Ac0QXvv0ZIzpqOUL1R9M3aiqE2n6fLl39p7dvU2v1bVtv/tgGiN1eWVHwgLbbef2BA559bywZiNP8jQyD/3Hq5GZhSrb/0c7V+rog3rTxG0cfQuw3+cRIvWAHjbOiMhwZ/Lm3oDAYmqBxyTiZNKG32HkBuSc4BG+wqaLHqcCV0FO4cpfjhquY8JXia/pmHKiG67slKRYAcEU9UFlzpc8j6Cs66omi423jDhyWKCKI6CsUIoeIVwoVgCPaqRcf6/TWuMC3nJyX5+VRjrEa/N3zH1O6fxS1VGmP2b9j7frDYN+z6r9bx0NVMPz/igXjWr7+yNsifP893WRqe/ddA+Xwd8VmuUr5mt/youhVC6pw8HJpGNMsWkT7mY8yksyFbKaNsMU7y6CpedkzAEL/fca7e2wySTvmREQAzsxnmiFMJoujE2lUuhXfW1qBHCuibtbUndiyTFX6EX88bLwvIHK4SSzX7na1NyDWNQz3XTTRnCywDnoiuuYF2XoqMjgJ16GgPUhkh+brbt4q2cBj4luaJPjn+4fGP19NJdJnkBU+qGzV6nS7o03g2jCeZSNw2yxrRj+J0/c7Bu/2T08NnEevv6PCnp69f7bPBsL7+t4399fWDk4MIYi+Znb6+/uwtm8DjxWL+aH396uqqc7XRyfLRujJ81xngOgAyJAhu6/U6w8WwISMHGHEVBMyNc3sUsck6mDZM5gELRGco5jCQyPtpBnu/RjfqGkXwkYghFAoHjydvl8JkxXe3RMP63W4XGtKwhdlrRKJNEFyi7X875ESHWrI6Hq9rQCKgabU4ylbDr1API1QpH0Zi08Ea8ITt2He82Ftdhwg3/W59PcrOfl0/v5hM1lUex/XTvdnoYhLnL+KLUdL5tRBhufLHv4vRZIfl8h/diFzx1qqiCqluQKkd8l/tmNxSSLws8hUwHGnes8Jr2dY6yY/iYXoBff3wAY7nnseh102hBCcIZF/5W6w8RMxWsYobprf38jxeShhxwUbfV0aE+GavyR/cQUcjhtgHXvQLzs0nnqLG3JKS0KD8eWobFpHAIrgKv/B6hZ93LTSsFboOBg3/IZCsCr+mLub79KJYRGdJFEfi5QK2tnECdu4q1Zc6CL6i7+2xwxrrvQQdoYFAtxcB4FZjPCJs3x5fOq1TV97RmaazZq/LvgnU1ue25dOONQ/55PTj462ErO6MRK+OtiOUWN2ejUEo64lcfq/Fmm8ivZV+por/eJyMwDh5E1+/FlbvbvQA44ik9XMywaoo475iSHQqnMZPJ/HgNwtqFErCesYgR9yw56g9Q+R5nk338tFZs7+11Y76m13zT6uEQj9IAbpZ/dPy23Cik/LvRlu4mA8NcReZeq0apMykWgKwQJT7XY+020WzJBlOkp+pooEjoxfwoLgHgERwlAzdywwX4oUSsjdNeVWPGkgstz4NciweBet16WKv6IJZ9M9jnpVdP9VgSlBgrLyac3FW1TALpKptFjBuXi8IJVu4RTfwnVFCEvDhgxLuxEUTixbcm7goHMaZvbD0gV7LFMC2iMbZ1Vs+rqwXAfGAC81QUepU7YwrAcMUyPE84Wm8t/xSoVtg8D7shkr7NKra0GxRfM0W2UVO97oF4rTgIM5/I1shwcP9zkQpHpIgRBlYM0zvqoTTcMzGE6CY183RklT6dHy74pF4/rA0U3huMhYxrb5O/f0uUb8Yn99QAkoAwglljwV6MtWEZtYbm9dHF3x6HeYZ7P9ZZ8cTuGsiSzpHz17vnbz6+dnJu6fvTl7iun5nljl/6OQXbBGBGEhLaCryiSgLCOACVt+TXbTsQ3Zg+4WSqXkP5UC8kDJsUeHSyEpkIx8SlYOfg1mJI566OWew8YxnzmyabR376p5VUBmPhY2CDMngA6RCTGWuLw4A/ivHmsa5Rfw19rHhxCVoL8WW9K1WUAYtmJl094lcobr7GFzYaDdCup3uY31kum8C6k30HasA9106q9V3XAd+y757Yjip1Xfxda2+0xYvcdSFrGE6tbxlLqtwCs9abtPGp+Ng0rQ6/JhXXGTvhWDYwLAgPvmDTwP7zeVs0UMWAeChi/GIvZe9N/D2iiXbCrJPnJ1CgFMHymLXpUDx7O9HfMZDu5kabPdrsd0vYbtfg+3+57NtD8uyYXGCH8q1h4bBD2m4Kq+E2TvV80z4e7nPHXfW9o+WgwWCpWDjEv3m7i1dZsmFxdpvBk0EBONYCxib4Mnbz9ZhalE+UhbUGFl89ug4WXF04J249gVpm1M+wvSg2zIhb+XDomQ4eMMg2P01JTwo0XoDT9cNghpuENJrwUr7JZX2vUr7wUr7NSt1duqBB2JsIMyGi0/w4zsDPDVR4VIoZ7xCcRKAdANOvvoUoT0ftysd7quvEAzA0DLh2Dd2c78wbicefL+qVKQDZ7VxXNVYuqHlA7cmE8aXRjNhyjETCCsg6d1KSUsPntlu/J7kWafRCnr66jYn3BC3CZQEpQuxtuyyWUmFUIoxfD9jIA+RB4dZJ6hQGYkon6Y3Uaudo1TLaRdojbaQ+ixA7WuptKA/90sIK6zbPLCgiD5Pwx3XV2uUD3s1zea4tqsUnQNO6z2XZqka9H3rqxzyVXYn98bXmsMXdlozgspNx7s4EbhBj6qjhDpdik4YAs01AFY7ER6lpKyDi/qMrKh29clHGe9Q7rPOsYKcy9OUWozrM5YAE7rcYsJgUUzgc5s6TKDTGpoLBIDZwHgEH/YhkKc3S0+QwmyqA6MyThWMz6zGvrmm5KdV9SaWd8RVvzfkyVdZKyWI30iFG+wTc6y2KkP9aob6IYb6VQz1V2Lob+EwFwTgM/O3rxfyYp9ErjIVzelj+Yw0cNTERFRK5qd10hmYpmVHppXtqLAFadhge76+LRg8470lYdknvVXmkLeO6bPl8BIiyt0lRGIFlhB9Xl01bgeTJM55eNrw3dmvyQBFGJsTEHFc6T2se6PDn+rjHyr7cOCY3fdwK8Fy8rRMeZGC3RsOIUzSCqv+XZ3joOBKdGjd8k5yO3PI7v57y3oR8HdzlwqO75qjdnTVjsa4ommczn5Ok6vDLFcn5OrrcbJYpLNRoYSCQTuvp3E+wqFeVulRaelJaelTt3TUOS5/2/plOhr/v4t4ki6WCuOEyN176v3Y0RnGTSQ6fhdxk1n3Ig0tSpEqipq97Y0Hmy0arxIBA+PHotQhmlXuvOZkRYbATNoDX4fYPcazZFJAN4uRETslovvlpYi2JfbW50vuepDIx8vJkQJJcaI1umyNHD7o8iy/nU3TPzH0xy6hE5r+U5J+bkdssg3cjRhu34yPFlzFhl4jDrjkIyFpPshmMoscBL7BE6aC57vRRqe3id4EA/g9uJK5N09ypgsAHq5ToHclWKVbO46WFTrOVbITEfLKZD9RsZpW3ZKg/Yp5Mlc7QQt1PRD+aVg3BAqxt7Z51pTtA2kv5FrDuWHXqgakYeh1xNTkLh8AGEvO0nLurCju2b17v0gmecT386aaM/ccafJXYFptPebXnHL+iEyLXK1Q1IBammSH2if4Zt0CVUVk0GzSp9PtwPFva+fPEbSgru6B3mIEufqEbPudI36Vj5QU9I66fvck2lCSGnXw9T1Lbm3Ur17LHX8eJX7P5We333GytsMHJV7lvj+Rqp/yOtos+K7edqlvE62F4C45SAp4D6Dp+dzviKc3Gtcm9MeU+jd2HkUNfjPfdrirV5W4ghh13PeOFQOIXNtx5fC3H9vUcu805DDTOdJRAkE9L4EHk2+H6zEzbfW0hiIJ67zh2MYU7jHRoB/1XSfxq16jnQQtqrV+E+3vHXknUrbKeQPaG0fGF3Vnl3eCzuwWEruL2PbiGiulrrQ/IHyO5NeM5DdqSt4TumbJk3idhnohnVL6um2k/D+hpMx5sXhhHdeJAjb3Fo4DGC347Wi/HR23oyPWniNk3fBLKftZcm4eJg/6s9fNZY0bbbCcbRtssS7TIj0zOSoCULT9oTdFU/OKGvjadeiIG8P7kb+g7tCGUMvWjkfSfnp9RZLxtU0SmsRJPuHM2k2QNb7zOkLTwxeHUB9gdN7H4HlrKqNjzTb0uDHJRq9t/d0FvrgBiuJO1yPTNqskUG3/ZtU6xFep1rE6m5INWXevpa1QH/WzLFDTm4YMupav/ofr6Nu4Ts/iC4NgNRrMe+iBSscW/VVMuV/Bq4iM0V9tYxR1EoOX4+MeKatfaQu1jGNxM/HXNmW0IqMUjWpkwe7RFqwPDObsXqvlCOKT16kpRNyLCSJnEKK15jZBrQ3eRLIkjCULwesg8bW1ry1hd1D0GNlKqbviqBZ9AKNa/ubzp0oFfsc2OEOWtEaCD5ZRbZEjNznO4kisaSZ3AOi9da+8hSa8aQjAIv+vW83aLhlGo2/+u/BkmL8LdC9EVDTVWe7BAQSDj1ahREPJdhJHtvK1vGD5XY+Tx7ZLwsnshilQ/bNeeqRNd7JN1OlhuxAZzCUdTHaxRUiRWKWHyT4mqarJtGon+20t82S4FiPlz1BhoR7n3MNBMk9fG8G3IuB/XDnexHIQhFc3HfbxU7p7KDWk+N8xfojXLz7qCYNBL1BNqTzXAtHe684CfsTNJLbmaAwv4gVWiuaqdbT8lWyE8xXT+/p2ZNYN1rS7sDtY2r8cWzB9DwZ+OUZN/BRwOtVWDzcdoqPyMUorUc3dFxuno/81A/WrjdIvPURLfBSit5BjqMP+To1/yD4oBX/FRrm/Qo3Ol/Hk/CCNR3AFE8Z1Z1NbV//MF03ka7hrOx6w1+Eu/uZVIQ6Zs1mZV6R5BBYpZgb6cb/aX0IjHgedJ7hFfLH1fSjWGkw6UrzeCHUD9WtHJ1QTYiEdKmUaix7GliEU9Azj7I+OC5rwDX/GYR1c9ybP6pA1pyO2KB8MvpR4ZxffAnEVLGxAtKmGXLZ36XikuyUGiqUDgBc+E+Kzoolvoaz59yZb8uTFVs7h65UousB5Jix469ZrO0X/ntgZepTLsdY8LMfQm+hwlEurGZjIOhkmrw+eJpPsKhm+u0zyc/bJ+NhRL/BOuMt0UHcLm8C4YmS4MiyHqDGPKV5JlFA96LYsUxCr1UOhqHpuvFzjmlZbs0vW65K1mq/TegNOhdFZs4WvyiXgfRscRsTRRgjlb0rb2wii0Dsy3aSOSg3sh27g8DK8bFNUesEjUNYOvtQjKvDLPkWlH6bimAf3XPMAUdkIt8jh5Z7Li6thyKPWQKwqjw3RLyk2vXBXdPDgu00QrTZqS5AxL+7Myj8YhD+kzm3LI9Xs80M/PLBdGg9nGQp0JfhCer8GuL6bXge4zrmx7f+yp1Lfmktb1FzCY6+vphOaXjRcz4HrBeD6Dlw/ALfhwG0E4DZL+DM2fREYPHhs9sNhdUDmDev9eJQYg4gHqVmRbF2Ty05GIR1mxeIwzwYMVxwX/+u72mYPPgn3cqkFUh8epCNIGX+QFvNJvNTJD+2fv13atZtkO/NTptVMa7b5QP1n8RBPmKacxQttobmsVGU1G+e/60C3d/CuqJt/CQMAc06nvETFnYNn+6/e7L12Ej++O+eRvG/4PH97MT1L8s7b+G0Aih8OVkGVp6ki062d18pHhDpe79uY9PHP6AE5IvnROZFJ6DUguDncbphL6K80Gd8iTYY9zWimbRjMsoNNMOxN4zoXD/50GSs8XUIz5YFhxnwaBHOU0lqVwWreQmxVcVSTGUszBnOhGhAnGyrC9S5V3JH6My2YBlXFkFjK+p1Qva1V008ROchsgsgq/7w8YxbZOlmr3JVnxT4J3c2wQAJ9QqX6umGfwC75xn3yeJeSxWp9gpKHBTukXhoxd5FfrUNKblY5QHSnBO9U+VZFbeX7NfPCnAfvGZ2j20V1LvZwS+gOEaHKbRf+BhA3kDzbhr5389dFlxtddPkqF1bCgeluXPgXCk2X8RQd/614J7S7y/+PdqFf5K4NyIMcLk8gZbOaDPQ9EpO92KPytJLKU5/K5wyk+DJO9fsfcGOmGbj/Q16Zcei8VI8+jD1CJzShpxYhEAdi6AlrISxZmDb85sSqWIcIZpy6lrDvDisu/cMIY6gK+OhHdOyAHi2JHlFYaCsoDyrsc5R6S7RB145+B8hz6XGFq1uslp/gouYdt9Sz5xBjT0gb7XYZq0nM7LqsMxuXBtpVV5BwxoW/HXPPhILn1YXMEKe5J0Lordj5eVbYx0VMEWtG3C1F6XiXyzKfP4JKPZeLselU5aVYR69evDzBzKxUGXAnZNThj2S8O282Oo2WHeS1Oh/qxVCO6T0TWkrn9bPnJ/hFzzl1jSF0RRLpLnmU4+8v+QGQOFxvB+9CYo1nHeG3PuPqSeAUnxijZrKZQ/rg+Tz9LGqpkPefvT15dnQbYsaBEVg2/6GCldPqkRN6MknO8SMISN1AWKaYf5O4WLxSc7Dd8G5GzO1JyTstgN2hsCE4279SwfmSNIqLMyEJyMM0t+7wBBYFwYITHy5jPYFfxZyIAGG6RvbJh/kvwE+j2zAKCH5ju9zGw0b0xx/oN6bJGmvEbz8Qv7Htqh96PhevooYj48MysNvvdmpw1QGSNdecz5t7EzRT1qLa2q/1nz1J+VJ128rvL/nTR5S3HLZ1g2PPTzvfNc/lqV/TGRh9oS7EsSMeJM9mF9NXi2RqziL1L0K/4JNIKcLxxTSeMWEMwYvXBghxzoTufvIjSRoc196y30p2me6QnO6SDdghm2c3i/MHFXmWmJwWFOFmAwAa7ajxmqk7seIQRkYpBQECNPZ5oAhBRRmqZWQkDNA5SAYpf47cI8RnfSkZDgFEjmD+CBKlondEvvPdp5Y7wGCNavrn3P/6BNeFAofl/FVBdUbOn3h9f6rPxt1T8Pft6NRyRYI/9j1bDXejyywdRl22ge6yzfJ7NH+Ag1Mf5NS4HjM/Lx/ITTIjNjzqRufSfkntJJ1CIMNlkrMOPYzzIjlKiovJItgCi/viYjAQ6Z2468c+ZRVUul51rIJsciFje+tUIiI18aHyufLk2dTBV+8/B8d/BHonylUu0LHHNOfvwyiLj+8lp/Mp+gmsMlnr96KezoF5uRiQ4d97+uEcgFD3+oMU3lAURNGUqaNx8UGRewNfm61fKgientrOnqXaDDMSz9mwPU3ivInfq98hGFhKs6q5VKbgGqRsQTUjT4jHwO2wYNUWau3+ESW/hnzzk0QZ26c14seLIulvvrQHhWKfP9vabaCefZld5AXZApuPMbJOx1iSjo/LZXHawtsGq2Uv9Y7Es+45r4wzJG3JqKlODem9Nw2bB474JOr1cM0K+jAEbV0RlnXzP2usjEDBGa0RCoa15MeKCSF/Kh8TU3v0Tb3ue5POLhZJUTkEG/zt8ynqxKnfiUE2Csfp6rFxnDB9N6zLRoHYKFZgY1r0HHkIThyJTCZpUZefDhcLZmiKONpooQK1IQ2ri2nR/ZYM9usw+E053Kjq4bE+pA7pMVw1zGni6aJcJeiDV5LF2iaOsuSXAxFWKhctSK+lvpyeisdMFTMMa1t9g7m3odGAiW2NxwYmn/oPzA9d+KW/tY1+4T9t9TSN/SP+lGVfk0mLo2QS81yUcAK0+cDwxTnb7D7U9IbSmhQrM+uj19kgniRgkZjrUdlPc2bz77NNKfSdL1buV+XUjAeWqVPugoWe8AoPZaFuFV/X4S26xq/xDMzX8+QM/rD9JPyJ57n4toQ/v17MxJ8JL7sYwZ8imcOfbLCAP7PsEv4Mk0HjF8Kks0wsSMeSDqKfTvbfZleUxXgqhKPP0AX8SfbTLL0Gss0hK1+wDw6u+hnmAofj12KSDYcQRFZqUhfsAyYFc0sfzho+mMUH2QMsFLZhZ8Tt7ePCqWuRL7k5K/r2JNs7K4Aop8Mml2/8Qb0ha7ip6wrYvEBmKIxPM8ZQOj9m9LAigLDtIAPCBwaCkRYfJr9ExW4NsFoWxkqeiJeIYKWzf5RKyvzIZMETQ+TybqB1xx9+1kM5ithQtgLqDW6esK3SIOFAbe7Zc1P8AOPP4ZjaFxx0aaCIPyUBFbCtWLpoGsKgCtOF0po4FbGt0+gbuAaTzVn4oU9k9UkXkJZBN3/Nbb1kPvstmYE8Bbjkc63hmHkCTNXKTKGe7foUvTuHIfcKYmQ5+IfuLy36updLrV+HWu8XyxOkRhxRKZhwpeeLdAX9ehX03AoiNUHK2/+dqd2MJfNCrCUhp/MerdJ5j1btPDX5bqv7atGL0AQv7Wmi+263gghpFQ74fJLF9KAwfYgnvdWHjr1zxwCCpaO7PjTdeefzY3kYUy3w6IivfDSi72wIo29cIhhaNB39ItvYClXMNXOBlDvU3xaToA0TpmXDie0Zr7etJN3WkhQOYrbKwTU+9eP/wMBDTmJYjrSjRa0M7vrrrlpG2K71F1w72WaFm0nzeMaWhJstnXwNwMsOV+yuxYUTlrJSPX8PsN6f2VN5aA87hmYdC6FMaGZsDK2TJ7crzThFEr63G92De8APtjfNDUPBzi5nVlvwPZs2LfzyepV4TEtm6IRPQLkyevmnkBGIaGP7zymhN38aCW3/KeVzbMsHnWBLSJkB8btVBEaLy2X803eEoG6ovgqjrrTLF1aRgv3QBnjpfsaKjN+2TAgL1PYM89VbkuLycbbZzPDTuXoV2G60pj57GXkVzJNdoVdsVwNfGxXIuoCwEiDhvf3QCQUf+pysyVrYANSXPE3DjWQNg0ZYhkWvB0XO1OhH/vlR1OgOKWkxfNALpS0EAC89NrcrhoRTReQsFOwz22BoW2jGWjTet2FBSo57ZcakvDhHNxQXb261tMb02ELj9IY0GAvb5fLe/mbSnpLS3r6xrLfrSHp6C5JWNND05pcYeQi2oXpXRA6g/AVcy+yQ7EfdDtL4BeojHULb9V2VDoVuFYleBYlesrZRQcJxmAZg7ZFjegyNHiT9nu45M3IKrfn1sOGjpmhUqH7lDpRh/cwmjg+SySKG9aAdXabJFVz3RD/Rq8HxOLuSHvqTRGxizRB0AF6yfs+TYTkQWfZGb6+cNQcKX8otGlF0EC+dEpCu1VbuEcGDqpLhT2FCNBlfMCESfHrCRsqTv6uibKnUoswVdIi2veBgsdaiLRbLEHFnwUY9U62uoG/Ke8bpXRudQlb9UYpo1KQ9OEuR8DoWHLcV1kLJkLYP8yP1/Q/lajdOflOT2+6WSbdn4U6LHomkJR1G7NKYIYTChpYyCpK3oblkQrBjGxbGWAj0wFKPotTRkE+TgrsIzutqyEWenIe3/CaYA2/f/930p6aoTmeIMvDpEGPeVw2u6uX7FxnD0lGjCi3CJIUQfk30fgC9Xw99K4C+VZP5Lolfl3cauybrGzT2Rj3sTRp7sx72No1dV2qBhqt7a9UtDzS9Jv7DAP52TfzegwABVlCzBdvBJtSkcL8fbETdVmwmGySFh3Up9HvbYUHUpLG5EWrIRu2WOPYJonG/X7styuFJT0lWWp/WZimtzZVo3S+lhVy01d1d2cIVqPUfVLZxBWpb26XU7q9Grdcr78zeitz1++Wi2+itRm9zs1x42yv2xYOH5eJ7uEHSI6fclgNqvAg5vMywa59+dIRhJHNBd/aeHr97/dPJsxU2YxUbrfBGKbTJsbYnzj7HPtGwzKBKSGUUuYB8ImxTpyVarvYuqM4+yCdAoxM7IR91u0viVqHhvVDJbshHtHZDwf0QUaGeRjayb8RSzG7RyJSdK4a8uxmr3jlZeMT+qXzDFsIOIZfjFS6Wsw1z2khW7ZKw9mY1CIzd3pAAd3ZFiJjexIFjwXRGq7xl+0cuX3gfSOMceNIQNZUivXGR+BQvxzk9DbR510AEJGjC9YJaWMPaSvYmrj4+M1oVEZDm+pFVoXX5yNLwX//2kVW9c/3IZrpDc7pLt2CHbmDg/hG9zFnOAYd+s6GgIEps74z7DuQL4jY1lYCvnJqC4teAVCToIhOPJvBFydAOycSVBb8XZMdQwq0gN6pS3AmCeEv9+Dd9l2WaztLpxRTux13DB+tuyxucE0f8wklZv3AYScaDlFStezCCo5fxbDihI0BFfzbfQMoWYBKnKhJntW+gWjfW5Q0K5YB5BWcfnI21iMPvuPGk8tV0XsiABNLdqClqFQfd/BlhQeZeEMINST1IzuOLyQLl9eu1RTanvpV2aTlPsnNZwK9QNdjylZyzmTZsOPnjEWjPA3UP3FHjTMrMNkqfiSK/XQSL3Z53SlKLkQDVvhYCclCJxj9W9X1XkYIMOiKdMeB0COf78TRhA74QCcgECeeg+Yku6aOSVmgwOL3ldGxaHIimNi+dGOM7MoEbH5gO1n42PWNIzTeM7ps+MZp71HDGI7QPAIAMA9GLXBDFZfg9id9D+La3tKomQUIcR3ZQtjj5FeZaz0wyhcE6qwJDJMuz6ngiQEyWQPk1XEcFhqojeC4nO+hv6WIs5gjvKi9XX83ekosiThmEcu/JNlSiW32F8imqgsrOxvXXGhJaQUNOQfkoY3DdmFsLBaxlcGvgF7QADOTzWSg71pxNXSZytowxFcKzczsJxyQdk7x7Lo/xtcJCvHU4yH42Z2A8TZgmwb95qBZXcytaCO3WLR7lHdUqLjFT8u+LPJ5dTOI8XSxtBgBZJByfk4z1SEvT6EOpCpUORH0i9CFPlMmUdMMxvORQNzIr2M5hkPDv7Uh84Uk/2myZKxbpjN+kl8XoFwkjZSsZpKLYyfdoXdIfXMrwghQIB3H3ATHHizvyTrHdwFGObo3w8Ok4HyUL9YqbFr4KDLkXlXebddXAw36MyRPjozOH5HgoV+InNcPKa4URAJGxZh7maRKehXGemOp55YtsEU/4Iwr79gSUL5kUSX4gx6+T83u5d50WQsoOknwY3oGfJCNmph2SZWeBFOiz+DIdxYx1mqR8m9hyDomSocxnSlzm/ujk1faSqS/0gwt6euEWoAA689qL+2MheqpAWo5rC94BHSY6/QKzdd3Dm7fCfohiyOMTs10AG8gRF3zDyqkJESjc8oElDNvLHcu2bHn5zVdEEvyLWEmU2xgyi6qRQmcXVaU4oanGIHKaonFnJ0IVagkqZPzycVscJjkf9oVbtZ4QnY8+sBdmSVK0WCul53I6kneBuIRpoehiLyVsCZIpx1hmMtJYphz3AMLyrBc7HzMxcMtt77cZ2/MPxqIKZG+HUvwSOsXNZ4t5+ODC/9LZu2Ckx5mT8JYpDuKJiTn1RoqlvOwnUQb4FZSF9/CJxiQeLjFldd4p+eR33TyZ4QZpNUo0C6lYunGWDq7TRJVNSMpe4kPim84ijwfinSLx1FUr2AJdq3kLhI0+vyHhdUIn/uc5ZP2Gn1Fv+DhLC/l2zwC92mM/HgBAuGq8FFGPllgrFS19dzVTHeA+1dHrKutU8AeZnO0fRvAMhP3TGczfthMTbzUJV29pHLGKBtSNKLQSUUt4KhW1XpADk5fKSa3WapoBVYo50BgEC2jlX4GHQTgv+MDNBj4I5QAfBDJ/fzWDqKSBekYHliJVjBtqcAKrw2PKcsGrgHm7anpR8ETwsXz08TIRYnLsGGR6fb4US8QhsGhZiDIsCAlNdLk2CVcYa2AvBqwkVmJZSABJWUfC4qxZ595w+Da5knsHZyeu7FR+W3SQNEUCbXnrOzY4uAGQ75EbP74a1OSwbetek8HZnISjUXsYfa2lKH4g6a9FvV/EFrkusNg3w0ckHtEaWzIlNrXv/3EwwJtwXdfYDlEzKEBu6b4dWi5qDuJ2vGWSOBs/k6hSSN9zdNgC7ipJPomcjCLc6d1TO2iMQPRTF3dIRz/eWB+rz7B23Nr73GFzA2o9RI3HUAtq/EoDP+2UP0B+jD/+iHQxBHOIdlt36Eo7wRZ0LVEHZOrY45EPJXwd3lsaNQWDnE80gBo7ZeMK2lW+f8Kv97peiSfle6+W607ZZ7vl2U9zYu/aiYe/sqXoxSQ7iycnen/mzNeAJrVI19J9xJwSjw9evU6nXImXC+Vu9LCL791g/1JtbacecHGluqb5cBSHB7gbrVSjpWjcJSaE69quWrD+YPDZxqd4FW2131O9kpl0V10/eGUOKc/RK8lXeKNXWefaouK2qs44slflvUV2UkX1onXD2DR9xbp3bcGFRhsCMklXFtN0FlxXulp1C1B+mlMHdFlBdYlBy6kuwzlaKME4vu4J31og77OuInWmFZ8ZU3705QHqFqLlgGph6glD0eWHcDQwXicxfUIsFMqOueghBPSrENCvrELRwOhXLBHB0bKspb8yqeM0fMuytv6qu8jQLmmtT7uknZi2l4jYWIbyKBO6ZIcuF3VM1SGkawtKAkuHAAbgFJZT867Yq1mR5MJkL5rc8i7w6iV+QRdgyWWLhOy5Lo7PM5o5eTF6bffZ55rPmvCyRZq5eoo/h1ibYxEpK7GkYYqYMxrhdexC2yLSZm2gtG9RE/20t3iajNJZOhvBZfueX/yMbzhVyQ21jW9npqRJL6rmgWcEe2GdEm4z1gQEddE6JG3PjE9JazWlzXhpeZL8S4uTLnzMrXo9HrAiIASRltQHLaKqgt9FLWoYUZUIeaShjEJ+o6x9oN/NLoIS273I7ihvt+Ej1th8+Eh4L1LPIqIrJiyfEKDVsGokLo+qCAJOcgUeug4bAfMr2Du7NnqpAUUDow2mNTJrjhcGu/JQ4TgrjBIOX2eAVIpf11wKwJuzWsdgMdxan/yL3C+JkADXFSeW79ZNKvvui63Tt0eUWi1a4ZXObqa9xN2m6ZAa0+HTn8uf4fooTIwaAMhhUzTZRDjDRl+Mluon0Zm/b5BO2DV0cRzjPC7B6VFPYXDXsRUgYCIKrUAw4y/I8gWSsdMialCEtp8wVp6IMbO2ZgYItQ8J7LzcjQlEDM71MSKxGyBTfPsRhefpbLg/yYqkkNEW1+1obzLJrl7BmxTzbBK72Tze9uwcqG/79vfDrLCj6Go6p9DhyWeYlNf+YmBZhWxCXGt/1GoWnWuTSn8ESclYY1hc/Hs/uL2203hKTxuDXwMiT9w0mVz2jBYruwdUnzyxk4CqHBwf3oopdm2/n8X5eIsRYCWwQXo2iEk3KfqYlVscQ41Q4rzVZQ0InYgyPMhwZ65xKX9gJMScV98g+ZowzZ1mmRTKAqu0gQ4wJ1qa6ZMB2Q9qCS53dzGb9RnysGWzWitwad5Sw8da9htb/F2Ua/snmf5YMg1PRDRtLpaW8JctuEfgdAhcJmj6XYIhdr7zGjIn3st0FjZicIR0xSJf0uYLdozZAZjRIOYvNCY4zvPsYjRKcnc7PuWQYZcbcYUD0lfFZ0Uz7Pvjo/azXXXDXri2lK5NIvarEUsVoUWRq5keTE3u1EXThZZd6shOSF/Ibthz8y5y6v3VqZfwT1TbL1kreT14AOn3yZvkQbZrTXzl0MgO9XT6TmW4LYr0DYcXdk2Y70keD35zbkP5gb7taJjmjIVDP+y3LLA3mQVDZwt+d5Xx8zaeJiEA8QhBPJ1TADA8DhlTacG0iogE9AJqLRh5RCZb3DnAZZ3Do2f7r45fvXv78e2716/evDqxY4DFdR+TtEQ+pcu78rV0YkZ9q3DIMPh9yYNUhPUDdtd+v37fDiDWcVt9iNvqb22Zf+yH77N8mOT7FdHHAioYgzyPh0Mhs57FFVzlSwfx5I16mt4uHmd5+jtcywwBoKfbneFAh93AG33Ez3jAwdRGX+1WwC/q2TErntitAILknmew85VjWjyz/aAd6Wh5E0hmagsFk9n8fN3gZahJTi66IlmI61HwRDVmnvqhUpZ8ySgkayrT7FggmCkbl2DN1RM3ZVCrkjCDGsRl0OAGGMR66iYMEqosMOp8wCCdGhSsSEgLlwqHdHSp29AB21VfLJKPZGNWEEgpHS9a1uFqJRXvOnjKVxTqoKcUr9tp2DpFLCIhfSJK7eBUiXHToMkDtW7Vi5lEy9xNRjFeDelGYgjcUAvzpo1ldhXbZkuvRL0GO+v3jaauu8oHutcFs/rZoxGSwW51j0tbo2aPEzaKt9BIM4VumCzEzVHwhA4xFo8n6xKzoboXkEEUYNMAWKwiPIpdy86qGUZcm92KQGoHyGf76wdV+xbl7clEmqO0LGQhloGCv2nbD6X5W6/lxli+iZKwTerA9QgLxrolYWPftMHSXK/XXm8TcKMFwdkqBBYFB8paGFwKX6XxxBbnJs2XGo26ZKR0HX27B6lC8qqR1KLh+zmSwGq316rvriF12KY1gnjznLoF5dwUgj0ZPRyghMg5hMw6K+OQZeJ9/YxDVvXOvXDMcofmc5fmf4duXiDfUIWVa97e8ytiatAF5xmIikjdCw4R79Ul2wOCvXJi3drUupxct1NFcAWKimS3kuYqRDXVGmRXomsI16G8GmlEuxbxFalj8vXor1qBVUPNKlauw66kbi2rV+PUgyui1YqrTnjKLuzkhYRdttPXpOt6bS7kfhlnsLnl63oiS9zEYpnmTUMMdg7lz52n705O3r3BGBkzXSYx6TH+y9/6l7/15v5W95Z64PqrhrLuv7q4N97gsy1bEY3jAtL5cUMWnhYbLCbL8tuweO5V27L4Tn2xkvPuT+WYVsojsKeUpdamUmEQvCBVdBNmpF6ieZGFmBUFT3BiVNzNtiV/uXP+cuf85c75y53zlzvnL3fON3LnIGPecucow/7re3JUzY4TBzPa8bjb9Rje8ZoS8NroLczrZ8+Vj8Yl1mxAIewCXyfnCzGqNd7Ju8NSVFkO2CfZfI2mUIYtMX2ko1cvXpbWywFUxUfpaOzWXE5Bo1OoYsdXTgDBAJmn2WKRTdfC1CoIGRokdmkvGBDEiekLcnihYcW38HhrDlt4e6tutvBvVUqfL7OBV7njZVt/Zl8P2dfjZLFga6m9T3ify5g3lwiES7yHXGt/z2bOIx0CIJf5yscJdJe32y3xFUg92qP293xX30f/WCvE4CIvsvwptcu3SWx21X9+sjke1yeMCt0RnVNc0tn76eQdwXH/phyHeOVpv5RHo0s1dSWPARYPnWTqGppZ5R/hQCch98hZCXnS/3KQTl/k8dKHC1cR3JP85RO5mU/Ens3h0CoD48ZWIexAcJWlLTwObHVBc2DDYA4c7KA5ah7jFb8YrYQTZG95UHa8p6fabmKG/mm8K0rdljoSeoQnoVfiSujdui/B0+2B3HwumJWnz6NB5ewjFhGvKdWqtEaTrOWmJEurAvEStWpcohnuWvYZQ6NfOjT6xNDolwyN/hcaGpWDIjAcKgZC1RD47BEd2Ixa5OkNqcMBnc7UNCK8MUWEbntzaiyKNmk+1N6aOjMuLDEzJykmiYnrZL11p38bElGFmHTIYYZNy+lBacrxmERYxJC07LPbc/LZXVLC7gnl9nSwv5bX0zNDb9sRTI+ys/LxdRYeWUE/TY3JcEaNsG/jXj/7vEXPaXIZ4ydhJ/vJN3Kyl463z5AMa5lyFTTFRoCf8rUj8eUltzTb0esp93y2oyP14UR9eCo++ANWbfc7Ehle6lMf//jD8Ql0jgzQURDoxACdBIGeGiCHt7JF/xPhqNCca8Ypd4ZmXXNOQj3VUE9LoE401EkJlDqJRT1Gwr1UGwXcm6jrXx291r3PPl+3I/bvsh1d/z3Lpu1oCX/ctNqSNIAzwvBnJ1C+FOVLsvx3RppfRoY6ghBAYqkgZE6JfLEfz9mcTYDlY/jOLyi2xXrA3wYSn+LrAO/v8pRJNp68lwjAhvy4Uw3Pk5qpGkrhpYwIyZWimVFHD8dS5L9LuVLiDnWUlCeX5XvRaUauHRpN4iAHnFK0qncCSdxtfNOv2dxFDNaoPXcmb7yAKa/zSxzGwMsJcf4ij4cpm2DEqUyv7exCVjqmWflcRHsOrVMRy4v49Y9GrOqd8xHDcIfmcpfmfoduXOCwxHejqg6kaDcbAMEDWS8W2RSy2Ig12Sbz6u3LZ0c6PjZASQIBsVezcZKnrFPzbBpNmfz4uBWUQ2Jwm8/9+cZPD9587LVHr2fG+Re7ll3wK2rP1fuxbrGo+oT1xH48mZzFg99Wu9p9jSJlumTBq0K/SkrgLxH+w74VxsR4gpt1gsOGW7Q3SUf8eT9e3DlRP3X2n709eXZUMxQQRwGyPdzDfnUo4AGr8CgZrhAMGDNj8upYJAzeoiMTtkoP8LcqTri36nlJOB+rnQZUvKT1Z3Slf9UXpT7m8AhPr9v1nurkqTp4KZzQRHejy5bJyK1d6mhyEsubNXfv2DtJ2+2OAMsmP/f+4Dp72xsPNlshFP7WEJ9V8pVGOayLq5SnYnFmo1lgBnGR+DMTDkYf2bn87OpwVSjz0BlbnX7bKSUtJn1t4r2ViPOz5dq0+yRtwoRwO00NikPIXYI1Mj2Sfc2Nx7RPZCA/2OOb1P8Dh+DNT6isLYATYmlvdjmk4EbBAxze/Mrfh3obpNaOdhSzZdcib5Ys98yZXpiAQGdhv4ntvrYeeJ37++8F9u9JngEIpPALLZFybBm1EebpRx2gGq05FTzSRWXhuhU5Zb7a+ZPRZ6pT7uzaz96WnlGt3Loa7UPveYJvsjx2+JoKHr4uix4u7XH3xV6r6a26LcBvBeZqTFbwbw2uWkP7USmYesfeCn63+LFkA1msLlXf1p1drpyoxsBwsrNs/Z3NFBRg4+snPZdwQizx8jLGbZmcbg7JLka89J5vCWgZo4uowbK2a9XiPPFSrwZkYFNV3AtU8R0NXq2wbjrnFP67GXfUuCMXLBXuttG63qm3HZZCiwryV/XQnuDOQCwtjkKyVy8y964a1PQ07+DJXmcYcyQVOmD8paZH7LFO9djlTq2BYldlp3kkVVLNTsbp2PQZdrmCXVIKdlmmYJfWCGWG9jSdiUAo8S2+hifJBOLtqVpmJAXuAbESSwkCJMG23NJWnbKHl7bbaQS3VsMt4cVucwROoE1qL/7/s/euXW3lyqLo9/wKh3tPDzsYxw/MI4SswTPQzStgEkjvHIaxJzATv5ZtwGSv3N9+9VaVVJpzGki619p7nbM7eEoqlaRSqapUqvIGFjQ+PH0gI6YHjxtwSSxMjhMIWVstk0qTXjXic2l0eylx53RUWRJJZ0s4xM9f97Tm6ZP311wKPqf94bnm4K9/yDP+CQ95plQEnn1ujcWLnlVTDOfTtiEoC5rQwHCfjul/ytOln3lm/LwnUOkPlp6O/c9+yZTl3dEzcKu/04Mky8gJfCCXp1HC5wCNFXKDsf4uPwLM5O/+ZuoxacAzJQEnMK1Q+ISyeE99aSkVHXRjaSylv/620nTtqJgKy5KP2qqP7oo/ksDVJLZlq3Xw4FEvuVxTdbitLOetNyIeS91tD19DEc2p91TebMBZELeU6gaSX1Gay0g3XMhPihQSj0XmdxzL+a++WKpU/10DV/DpDOh2vAjb6nhdSqdTa/IYd/CMDIWT1fuI7fO4xe0yP4e2hCPsDZe+2pk1juthTKeFv7iLR/FlJyKuFETiA+5+cHLDRD7illuml5TZgkoHzQNUJnyU6LKRTBJIFwbvm1spb7P4Q5v3bJgUpnz4odvyunxoVnafmfE2wXdYgZ38Xb3xwVH3n29/dzTL4jtc8i+0xQuZmcEzsYDv4UdT3+FbqbV2+7PIWgCs5t8VcqKAmgJiTAKoTDb0HQsE3/8azgQ2I90ZqAD7g+2ILvEe93p9DjmwBSXA6WU/xVEINAyvoVABjAijY7Zokdp/YbQUQOyLJ1hayBVPFCJdTtWnlDjDHR295yV51ZfAMn9Md+AgSAHKglUQbaG2FHU5aCL68jq1K4vaOWOnzhHUFlC04/RBEH0e7Pwfdmj8yNlvTuSY+A9lDufHDUT3pbz0MtUK/Dobf+QN2EdThefq8mAFg3ew+vmZ3KxtXmKTogO8z+ZmCrlWs9frC2PINRPseUjyMRtajp+LsGVz4racKfgE07Wq94WT7FgetAbalHJNN2Q56GJjQZeKdAInFM6wQUx+POe802AhV3DjJmp924xH0myAsqapp6irOQAG3gyF1iNtwg240IRTuaq7j4q1wmZMJsrJCxJ1iJPDfJtzqMx2ZtYXr7BZ26kvJfm9Eb3GNiv2SNWbdo311nrUGr9dtQMvpK0wmwS7wh0uksnl1TvRQMq0n+ymmTYRB5NdA4/EWQl6Gs5rps9nRgsrz4gMbekyZl6UEjRPSdqPGWjKFQJ5efDr43/9nMhfrYT3tN5L2uAb2md/q6g1nHCQAl7qhicQLQKBCZS+9Bj6MPIajY0phujYNgQ+UEfzEArrrxlRTXl1h6q4KP/6F3eu7vm885HFmCFrSn2TrivLkOlDPNk5GfcHJ5Lv0MYPtOw88Yx8/wS9C8VXwaPh1+blyK/KP3o1Fd/Dn5rDsfet71YbgEjEZTQ45LgTHNxdkUfkKOYc1xs5ZXHiowEdcQO5Wbb8J0ckNNYpBeuOhjV+GET9q5z5sJqbuWUEcxX3ovZM7h+yr9wbXYGKVkIThcWJilFCbfvYc99BqpxMLUgqcshx3dSllDg9GbCFyqKYzUFLmeldjIt4Ys0mAxKIq0LZxlYiUp1jx8FR1BI5uQbNXkODQ8iUw65bbPvw8WKA3OB12osn/CuEhPJxyhTUvH2JTf824y3nIrukI1TNzagcraLaPuMaN6KgQlbU9ZiMGHmgcrDGTv92OPKqvJmBKI7GAEPGD27HEW4Cdc8R9JipWCFTAJkp875HY5scayR20kh8JXoGHZ9EbNe3gXeuyNA6Qqh1OvHIrcZrcPis6utcJaohZFGYHowPwxVW5T3xQMs4C7fFnpgOz+HSbbAdT5jiXSu47pM4UbfVLRrDh6PmcBSxSR4mEnoSmY8VEIkto3RL9gIusvgkN127HHEKE/StmxqJLulFqMPlRqA+JdcZLgr4CTsjEN8obTba8WjQaT5caTexmc3N1/v7r8/Pczc3b7rdN6NR6epqxm3XOPHatdsl3IKfRufSei6d0HZ7V/1sx61stcnOuG6zcxIxYUE925vRbmDqtDtH9xf63hDebWS50yjmYnasGEVX3nmSlx/oYONt3IPwJr6+6fDLP+7pmxJnXyBf2hl+RxEqQeW4x8ahn7DDbvgjZeeTekZepjAU/4KC3lWsLZvu+iDnJFYvdSmg3AJkKg4cyVkIMKodkHlwDSEBVRIqSEmqVIHbSYw7IAHoKeF1O/3WN2UJwZuoax+X4/6kjOcbuAJVpzJ43fZS8Jn+KiuLpw4k3ICbDqyCfHRQW8pBx9kV/9Yx5lXaTEHda722IO59eGMkT6zgDuhIQ6WmFmNIk8nTDRUZSxoDp+nbaA22xNMElAEHp8COR5tSbGaY2tN4P1OqbFavhBQa8UEgql5Uwjz00nDETWX6QJVjFTBW3GrNia0mIArIdnRGbeq6X7ERUhssV1exxZJ/m+N8ob4CupkFX36g9i9BWgjVliOZm8sJG+Ir1q6sk0+LNqwMtZHQg23kWkp2Z5CXHwWHQ8O0SieqarVOU5uTzqZKzW66didb01EBP9fZb1734vFtOzq6H2qP/k7/ulLOC4hITkV152Tdq06fHauwpICmJEf2QLWatU9DXcp2Oq7k3r2z1IhGoTsY9O/zlXIRQ0Ji8AbP4iMm7bVtDke7IfzXHeFVb0Xb4etcfQXVMN3NzTlSrYFazwC1mhVqMiRXTrYEodlPASLDZ6YlSY7hoAHiJyotvPYtd8FzAkKLv8VkWjquyRaZaez42xx8Ewy3iBnPq1zLuf2gXwLpBoRiwasIK3NJnP2HV3kmwSDqHvDrHFdZQWQ4l7/TitocAzZn3P0Ca0EwZ+L6xpWdjAqDVRrHF1BIj8gVEEiSv94ZEHTuXO5IREsUdqsUzivUgAI+ga7wrM5dAirlFwhbQ88+sjnl2+cPDQ9JuPdJHYV792ltxTr3nT2L/jKl4gJkH9F/6eNwnJDnqyt8En1/oZjxl1jGUWJltXKZKDy8uuKSmKOXGKVRdr99eLy/1nBDdjvvwTM/hjU+OPrBttv5baejHjOUXV3LhAEru4nOGK+6B6FmJOKHTkFp8/DgsLGze/DeFyffD5uDG9JbKjC/UmxyRt03pjFccNrYOOC+EHCdoSzJYM3qcZpV8y3RtfLfNquTmqXQFbEoBG5c0pEWOXJ11e5WRd7iEH5cCq705OoWAqua8bG/rIsvwNUoulhrNSsU0l3REurJh+0enfVM7OZstz94/7trijUcdlT6jV6RvOK11SqmJuMshIR6S5xgWYWYYtWWuiZw2B6YFS1/+CQhbNMjhnWLfRKh5ODzISmrDUqTAu2IYf9+1BwT9osLMM8X3kRnc+zwxTNls7K9zWEfHndcbMSsyvcnDuK7wXtKz7ZO8zLqOMGBnEtIGDtm5DQhaMOceo/yc4DnXcjFHFRxw0Ic02Eh6KP2MQjq4zbgZQsiPmi0TAsCI3B4e5dt+gAPLIsqhT2ZFtSqWHEA9XQZjcZqLbnCzZFpc2WxaGIomk8OHvhkXmdw+JerbLCK1JJ46Q2h0BHOcwhruQkPEYRA5kNH5sH3CK7oJoUmq56ceeoJkDJ/vXoCOnfUE4loicJulcJ5hRpQQD2BgrXNAUUA9dNA+TJ5Ums6fZI/NDwkOxRXkv31C+RiQK9SEM/V4BDCgwwsWliqVysQ6ik/Y2ryldjs53p9tpt613I1PLgnG8eHe3upQGU1DvGkNex3OmJmGTseBcBuHB40jtc2GqmAdUUB+p+3UcS4IIYdmHVitoWme2Y03TNP0xX5slHOa0fblYU/Q93lgJlSrh/fGUxKO+bdMHwduLXptWZ7xm/9Ub2cDre175LB/qO6NztdK7JnVEhKEshHp9CAOEePpC5H/c7tODoLRQzVFc5DFc5PWCfRLrzztM/4wQSHHvODKvhJP2xLqY3O6j1zAAKwuAmY6yoe5qZtCHNAOT/pYf1Ropbu16Mf1x8laO4kGT/raFwKTw5zQI3Eg5AQ6uBnjcLbZIEHMW419CjGg0E9jCF2808ZyXm2kZwnjeQ8y0jOf9ZIHizboscA+BqKgAXaEXhjbvhMGCPzvuHw2MSPT6y/wMyPEXCkNIt0KYTpamgMK6FBhkz/zuHNzfuH29qCT/chLwEOt51rgIAYkAZL13PDBbjwxM1BOmqqmnPFEJ5SfyqBagJlk79A24Ldh2mExnKVxj4wuJDmhYSztfXDj1taf6KA52dEFayBkfJdMpQQSWBY61t7h5+SAYkqrj4Xmjp3yqit9BfeDHo4ZOEa1F1hsDBpwKnsA10grh8eb5oAIeEOJSORlTUzUUHJXB7gy/YZoJu6IreCOiRzZ+aCJdiJYCKZBwFqG7Yjh5HAfOBVJyld4l36F9p8HAzSGRFlAQoUhQeawpGgQQgtVKgnYRuyi8T4E6K0sAKYCtfURFR27lCZ14E0NmXEHVa2/AyNIGEhiAUQlgZrTeDWBmhbsBaH8w2R+i8c3aR3vdttXke8dcEsk1CuhDecKy/OtIb90eimGQ8dH2TtCR5+bRN+7FFeSXsBYjxZpAXZdzTUwXtsNNzxDXeRg68npBc/cEBsRy3sinUHCq+GTVOqsihEtdyrXP4OO/7cFWCAV3W/8VuOv7KNSt1RBTuaiWcHM2XxmoH3QPjoqAGVZsTTAxAIlP0wfje1ghMhFN85kaiUfxEu1Sy4/CpkagXXxdHBZYTxGAma4JTxf3ILZfdJiXqGEoXRg3gBtKrc6Us9DxnNQJQ8IuQfXrO+E6jKmTpxVZiMMn5snR3lme6MRPyJKN9glG+Eq4dEuTpPo8zqPA7lm+woV+fDKG86hCERfhxKbQIlwrHNcNFSI259Gx1FQ/l2iXsZ8/dHgtNqJxpsQEav+j3mu3HD44hryaGY6/Svt5WSjQ3JSRV9pxCYCi5qJ+Rvcqr3B4Ok6mxg0gVgg/Fdflk8V3FK2flvolx6hfJ0pctNFELhqeJ3jRAlBpKUPJNM1rTHxUm2ZA/JWTpRxKpx/7Z1Iyb1qkWFrhLl+/27KKF4q9emS7v921G02b/vJRSHYYviTzdR1Eko/yN6CHbAM5l9jKP7o/5QR7zSP0+i8ZjtHsdvSFwCc+ccasaDmaZAgnc65RYP1a7/U1ih83+nJOti/ynQy3YU91o3m/Fo3JS+BHOVhHpSRVZzIT1fvABnThPlbpQEVWWTLCdU0bPqvuZusOOXbYLj6Irxphs+//1bvJLnyuVLBG9Rm0UKmnk/+bEamcx+IIMbej5mD2sTIhjbKBrGVIw2Len6RT2Q3Y53arLdhTqWL+O13GxDtYkvoUZgklSjTfsl1Mjd1HkmDK++w95MDVNHyq2nu4AVmwi0CawgCJRXmQqm4R9BkKxGVogOz6FA7usqU8FMHvm+rjIVTMDdKKC2ztYdj8E3DWjEGCngqkJGoKBCqdluC3z2GNfhd8n5GbGMwq1+pkjRYGE6SF02jxiQmvwp4bDNhcFISssORcxkm82SAQPJa0o4aFSQpLLDuee0gGFoEsoO5Fv04A/JkkvwREx/ucZl175K92sw0O9psbhXure5oclmxjXcaXdjUkXjhtx3bLqueIv0XnDME8mrEwKfiAooiCZg13QMTVvhb53K/u+cun78S1PXe3HdZHpMeLG+OWxec8lpi84pp4Sai7baRHQrB/4oAT6auGzQA0k+SUELrIiWx2AFOl2n3XGXzVG0MD8Qjkwz8cf1w+P78h/vr/tr7H8HJ6c3W6fX7K8N/nPtemPtnP2z/j3qDcv8w97O8fannePNVvfjTft95+4yXj9tfqp01raP++2TtYf9jfX19qfW9f5X/vfaZP9rf3LQ6FfY38P9za37/aPa0sGN6GunvdU5OP5w9W1j/cPh72t3G8Nu+TMv2Dhb3/10tr+2tj15z/puHV9vnXa2DtZ52fr79nrjdIsh8v5og+nxk5v1D+xz9+Pvx1vbp9HBcPxxuH27vbn1Yae9HK3vdtd217f7a9cfN8oHv3843d6832OtPlwfn31fuzr9zpTz3Yfy4MP9aPf3tZuND/sf1k9P6q3q5tndYqN+9f2g/k8eA2R70r4vfz06r43HjdrXcX3+c/fhbPd8c7P/4azXb39a/8gqnRz/fvb55vfL+42z/t1CffCZAZ///q1ztT76fHxV3dqfHN42vnLjQ3y9e1selU8frtfuev3ep8/lg6P5q/Xqh28fvi887Nwd8TqLCx/ntypfP7O/L+PW/N7u7X7vYHPx8/1mhwG+nWffuxH7a6337Y+ju1v21+Jwe//g8/r3zwvz0XGjW79fGH1Yaq21Tj9Hk48P48ONwWHvbvErq/mhvbnJ/tnYuf7j6/71Urn3aRB9GJ5ft+fXavc7Xz8d/b72z4P59Y/9vdZovfJ5v12tf9789v3b3f3BXnthbf/D/Nn73duzrc4f3xdO1vq14flg72b0+Y+Hh9+797fVT429eLt+zTC8rh70v++eV9if69+areP75vm3z9enR53h4l51qx2t3Xzdmwz+ed84HJbv1nYOP7+vLW4f7R4e1rpXZ2fvK//c+rT2/m6f4drYWDh+aH9jgP7o7t8tXnY/dTbZj7vl+j/HzY3GzftBv9I4Gm3fDRbv1w/Ld/O99X9+6p/fHZcfDqO97cbNTre9M99oXb//8LAUcyvTt16dL9uny5Ov74eL0XJ/c3mhtljd+3290l+Mv18ejc93Bkf3i7zS0u38w9337W93R43D2v7Z7f7lZOn346P469Lo7nqttXbP6mzdb0Tlq6Wz95PP59vrC79/+Pydr9Rw59PXyvur+qfPex8bX+uDh/rO5cf+2ddoe/7wdv/mvPdh54/bzidOywunC/MbR+PLq8HHyYfbxY2z8lEUt5hcUmv9cTuob33u8n7+uN/fPrhcGuyPO/X3tf2b3Yedb4dntaOj05P97tn3w7PF7X+O7mv197f1g7i9dX/2achafe31+JKfnW5/31s7/v24uXnW2/hQr/XL64OTve+ts+8frtb+4ETRWd5ijYZ/NB6GlcNP75u10XZv7+5oc9RbaFwvHZWPhuutk/3j6sH4aiSYxMnpx8PjP+ob57u7uVUdFmP4YARckkmpCByKpzFN7TJvGFPB2JFbTZHtd2vSigbQZiWNXP1OxB9r52c2ZNBJyS1zLXbqMDW5JUDPEME2rR4ZFgJkuWbHTG4z1yzoWdUA6IGpqqOEKd9TDfAbKBiVEqWi1cayUV5I9MUcfyvvxMVINsmJdlPY5HgHKIkuTo3b9cMIJSLwkoowndQCPzVz7XLdgGR91WfLbqWAdjQaD/sPVIY2pI5T2EGwQ6EoPE7BcvrUKuuzdomVFqdHpco/a4dIaQMkABX9R3WYSbtzOnzSlGZSA50OjYngUT2mK4xOd8Bs8KgOsymX4gKgZHaM/CifcpYYOG6Kk6G+2SYbbjVbN/n8oBkPkRHjOLrq8Pr8ZaDkgLzKn+UvIJkJ25lQX/Fe/ZFBZAa87Ow8f9A8KObYfxQkhkkuz2vGwo7J/nmLbIfqHoYVzM4WQJSDl/LBr6jzZ/yl1PZCHztvFW1VhrK5n7B3QChiMH6n6AcgmRRgmAh9gQTiS+TszSl/AfguJ1slN/qBQiu4t0v88PrKTsT3nf5ls9PQJoT8BL0OBk8HjZWh5ERuCpsfNvrdS0aFn+LxjQzBlHdaFHOTQlL4G1dH6asXpCKYi8aCN5UF72CgitF9LIQEYHkuuQ+44KK0mJgResIuX5u8cRaQz847aNlWb3FRl/BRp6kkA+As1XkQaV7BRNM2bTC5qKlWAbmPnfS2KLWuAADC7fvoibkquh3qAgqqyB1A9foD/H3JpKxvK5mmU7+xee4JXf5pE6pCGPX12+cnT5CfkljfUCWmb60Q+VsrCQlcK1kzuIatR+r6KxGtKoFWNQGt6pPRmlA5usGKkanu6PqmGLnI8wuoQHJoXoRie4uzIBDZW5QBfeEcIa4dCYTS41yIFWF/6uDyL8mk2oCUCjKaAsThhCNF4sD1FVnqaSrqAJ22OyoMhEMSgWUPXs2LAKb2ZmwknBz4jQgQ6qOSvFwwnherPIYsvlyRx5S9aDKAdFsmp5QGzevojPh27js1UX2CSFkRj3zEBTFllc/jTPUSGyZHH14JlJws7+mXysKZZfRPNiMm1pfFuqJGwlgnNTzhlRJudk41O+fNkrEjrrIJlGYJlHgssyqcdoMJUftc1E5G5TOItAB9DkTY0EliU3V17jflBYkttViUen45uSJ9ksS0fXk7Hvd7Io5wlR95hEr8ksx0GnZnSVDcsSUgkAAoqU0eyvrEMF6C+M5Q5EvZpWZr2v0onNgDDVR1Wdmx1YieTlrD6lany7bBMJ6UumyLxoPOw/rDx/zHiHtN1YTnx9n5Rr8/5LnbADgewxppABxwdCYidpyBL+fiy7kVXDmlU6S115XuSmxxWZW3VBV5kTZHlByDxuc0/AaqQsJX125UB+uyNU4Mk4UI1YxXhTeNtP9poGL6Gn22p/Jeh0XIQPiSnxeAmOV3zAVg9WfbPH5kvZYm6lAVG89R1h5D+5mo38cvEXlnW+ItYUVKOZHPN4/+Kh+qO1ghxe/buDoO10pvarVIwwLTm2bnumRzvYESNlc6EH5oTDKeGqgYmjD5no/Ow3XZeGB1wTQYpaYCR+naoBhiWYqVbUs6qEqAs1A1EYOhKtB8Jq3T88ROMdehanjMJ+tOIIAlbYgnc6og4XFvPtxN7Tl7ST0YUP/CqFTlViVOd/wPtkjiA1umQa3kpHDD8ygswVpSHVSLrlzjmRnCoUGTFXLr1y5Qm2M418S/AuUCjgxrTVfKfoDqOrzXN5mYxG9OzYCWLxHnH8sFWr23HneP0VUy6Q3Wte0v02L4rDOybP9dNBKOD2fg282WcQA1yL1OVqcgjINoMuZwzqwplFAtXoG+4Nayrd+FjhG+4WA1/igpcPiLQMS3Q/FefjrdInDyTEKDEmWz/u0Y0OtKZyST2dP8+XXCdM09EbKZL6x/0eZPb9DF0GTMJulxr8ESJ4hN35XQQKNI53o0DrQeg0i3DRiNMYnDQFWL01s+LFb8618em9dia2EKg0UKcyKUNyCGA3+7ko4Z4SsbYed0T1AXZqiGLE1pjJc2yQGe0ZkGmUfXXuRas5Uq8uiMztIHpxESQED+8xKpwJO5P3BWxCo51PSGiNRRqdEy/i1V6ix6qJaT0zXvpyje6Xr3E9VuMGB46TsaP3SiUsu4/VGeNiX5ntdYj5Lag0e++BoluSXdsV6M3D8S8XrjPi12LjWtwJKOvvKxnHFsVgmImyaeeDR9b1P2BUjY3/NY6ZlUSN0UadCzgtDn0jVlc16HNWEohYjAnHw3MiTmMmi1XlupFpNtkfaMuHFAPxBPSJudK37665Qf+QxWibkMVg+kW/CO+Pdu3G6LhOlZepl9TC9ijjb60ZXdRmm+wmwrm2fucooLXJo06SZE9o9SuVLM6dI3NsdEQH4Cg51zpvgVwHFO0UMRzs5shgb4sCU1LPIohWLxD+d0I2wGKduHahLeRUm1PeE3oS69p9CWopqHdlbSBkl0DkhA0Zj+ZnMoEm9qE0H2bZQr54krLC4T+YmQH9jAFMofnk2JMpfoDZa3Fp5BkZc/FEXY6wcoFsv0cEy/vevHbeg7IqhjIm6pXQvWLIwAkZfxuOHSTLgrgvkgdAHEph4eEFhz2rvmLR1UwnT04HT04HX04MwdMBLxwfDsQEXRP/8LXcfI8T7vcOVgHz9WPUQ4MmJcZlh2VIAwCGPakwgDIKA90NBsCGOT0F7dmeQcAc9TES8nbzrrzxUTbYkZ86A9FIhQAs+E5qOws0iB5diOe22Vw0+5LTNFoigcr3kgo9seEckl/UWb8LQTQcS5IWjCpGoGtcCPQ/FNwOVpib4I1znRcSGQH1XYeyr2DbT4XcW/t+PhaIwTy8G+JXxDMRBaTsIyCOmv9zcxOy7zrHCO138HrX8KB25PqLBFOBC7t4JvrkT3B8TwTJcHtgGXZGFxBRZr8VqP8aAC8eR9yZK3MLOVMyGWpew1xXdnvAZjXvyF3Gbt6PL2+joauue7bSbGKpb5r5loSWPBefSnuUpNs5ogVjiLZ1kUvLMDsD3Rc/rDJMKT93QCUbEuX0oPNkuevIkjCpHfrFxPjhH3n10VXUqPWaQ/CzAxA8EmQ/WM8h9DVGLTk9v2nUbMaWsxtW1Dnqzsz2isnnZGPetgNJU3sJNHxDr4Yuiu5Y4LLTBEwLVk6/zQEXYC+1MyTX6zYPUAyO70s8Fjxip5PtBKCSZVfOk9YHUtN66zrKwqkNDuXWvDYfMhT0xBwW1m3txmbSZcIyfTNniYGrFphjLuj5sdN32VKXByCKtLI/qrC+S61IgmKmRt3LveiUVYmnPvY+mE/dGJ1uPxUTQ8iidR5/0wbm/HYw3mJBpvdOJBXjgAHketcZPXFwE/Ugip8BiXd9+GCghdTrCwYQBTiZp2VsFoS24TvbMRz0PtZk5k6A6Rez52s83TahwkdRsJeRUG5CihRBLGcD1VSxmLD8v+zbtm3OGbS1MDWgkexcmk30F9NdttnglgliiTT5XH8IF1eLjcT73THNhF8BByPszlSBum8/nY8XugtgdQBspYb4FfHkd0NNmNousuz66g7xt5gkxtlQTV7uJRfCkNli/dMuq5hnJsHck0Ntel/ag5EjqzoDlLnUVisa76PHlCJaojZ27IGSVZC+gqDgE8wnXv9/emkohvwOpUyyuO1zufaydTKF6bWdyR294jhQkXT+7vXY932JdTlFPsW45qMlmhSh9k6cODW8pIIwFF4NwvERS4ORVykPXe3+P2nqtA1m7hoMrTjUlsABeRzMtCjHkySRyzO+fw4QA5/qQFSxraRDxkcEeWimwQ1R+B90Zqr9uD9p3Ds5BbCTyPcbXUDLfj/2VMUNKDjEnznMrKi+BSu205h8KLD5aeqvx4DqkwUdvprdvaw8IcVU5FCDO45eGeGKM9Mfb4CDdpQWEc1cYcIBb8NPcP3P5NRnA/iOzH4tyQKcs/6TPjeaQNcUvChw+H8JzAJ1huBhsTP8aj5DPwhJ+/HCNFNR5e3L4Zs64rEJ7Ny7KPhJ2gFqVlLbRDSWmK8004YUnd6olLmDeUrl0caPw+CQv5/NLFcW4jTgPB0pM8XDV08ip6luiUrOh8tsZbD8UX5Ju38MIy6f1pa/tA1te77t+MEh6/wrP0Ej9tZd48at4mkJi1ZHovCMVcbiVO21x2JSorBUyjmHlr37Brjxlohl5pHjs9clkIZTVAsv5qTKEy/vy1C7Cm1FmbqqvHkL9IB4E5kzuRmWbk/pdzq+MAt7rIwq6eSoZzq4m2h5/Fr37Cav3t5/9JkkOmdfr7Sg7Sevc/d9W9+c/AMG+ehySSlx6scQasnkwB/z5CymNWLFlHy4AEr2OFlqCMsx6ScdKUxOcScP4zZZusOwXOefqiZ5rznyseyb33b626PZkt/wqOnFG9/4Uc+Qfw0mnpe2JwgWn8stS/9+rfG+h8dl3ajjsd24iYaxkcpCh6Ma34Y7ukVoOo57TIeFu71hvHa524OXruq9WfZEqWUyEtx2fnmWzH9PfSpZxmEwZqos275BbQTEiv8Swwr6bVdx51DiYinhfuNv084+x6NvFIWnDkJdEZ3yXZ0Z31DNq8WwxWLsFe3IsC9+lHnBiNx+J2fjApMjwKzjduG6+KgsAbUuVBt9k/kaRkCDd/X8xdC2dG4EbHVlKkDpJOduLvLesshV3W3plyfoPuu8y9BbAcvzlg7I1HJx/f8/uMXNyTbyj7V8pxPW7xsmdzsAPY/GVedv6M/Bu42qG1/usc5wwGfzPvOdNyTk3zOyEl3Jv3XvdAkLzX0iN2HGn0OTdALkoiRyCCy71fkE/4hnzRa196EP7s90Xot1fAD5Tv4U/swgcfZ7s+HSAOh3pfD3924m48dgiAn4B8LHD15Zj/7M3OfoGRnrbzalils6IeYekccP8u7R6Ys0/3AfPmuCTGSLiHMRFMz3wKQO9y6kvgArvd9+JyQt/EbnPiXUPSSPs+kV3oD5k44BwXIKAI6My2cWWO5Q4Ss+Geo5U08oHe4AZaUaDpwqo+FhaP3Yl3vnmRNKgIX/FBtSSeJVWxrB4kItaMPwmtINJJql8V9auovhVhp9lq8ZeCy3JwtwrYCipk3+UfpVEnbglXvh4KttET7JMQINgcFVVb7yXHCuX+IIOmsrPVZcYEG/I4kJ0d3/k37PgLJiHW4L5MO5twQZKH72lDAVxDqALpjAHPhGSmanwGvxQKyTf5au3gzGuPZY6ViPf4uc8HLkW4EVO+0LP9l+KL1gpCfr76waOsLPz/eQSqk3E0EK/X5UPHYGkMQJ2rKHkS5Otc/t4+9bgHCuS9tuwm+KDKDr/z8YX1JFAJ6D8uOUum69QFhxcMD+PWco0HMhBxCcQadmwGk+SppGjYh8t56guX86cuAYyDK88Pz21oLD1DVjyUu9gcIHscU9gK14wyd2+jFxc+xeqm0Q43nAmqKRDq1g3Ol6ygdRNaORaBs/OdTy6N8D+UUSAhwNJDufiol/sJYUekLHET0M/4jj57ph3dRjsarkEX7tYztVvbdrcmi6r/AZs1sFVTWiZsR4TZr9l8E7n56CeWXbFmZlR8p5w9fadMyO3Q0LsF70xJV9K2M1V8ikbCJlpHNBiybuhjUe2f5oSHQVYBy0dx97bThL5iYkfxOj4tiq9xD6S2KzsilVPDVaj1qSqqhQ7VUOFznKnyycvV+CRuRxoP+JhBzFNpZ/gducdhZzzT/h+II8ho+W+QamuuLWGQc8my7Ly/cKUqJv5LxLiRiykA95amxC9/pGB0Kr+2sh1LK+a2+JavLNSW5i2/Yp9KvLu1Tnzd60r5vYJKYQkYdZWN0rUs8WWiF3bES17BrOBkJfaLrWOgPXiTant7C13u7ee5IBYuNfJvOvl1Pi9JaQ72kESLhUIYXWmStZaC4Io/zoLOcT/txWPiVVWneRl1joZRi23dfg+b+whkB6YmMIh5MOaSWlr4djrfGiK1C0QekLqFp2RoT1fIxO26zLLWr4KTn7hqIRmJD+CBR2t0nnE8hEW6B/dhyp3WntKRdE0cL30+jF6jCCg3/Xv+0E1EGovFbce//pUwVv7mrFxw3xz4bOaawRT29Hsg6RUpPsa+F/wnDsYYcVdga1qJ5hY4hgL0DZu2Dp+6z9Gw77+PCbC8R+Dx40UGuOKFPuBjc5yRVQuiF7eszorm6gW3px/Okou9wi8JS+P+djyJ2nm8eworWV8o8GbybA68RxBbDLxAeGd5AF5jyBpAgylIDiZbUyEh3KmrsfmpFfyFgJdnR9vEsMyf+nZsUFTHTSHLC5gfmJ3J26DSOB53IvXGEpmOA7PttVV4qU/+AiRMmD10q6mnrj1bqyXi2IXFgZMZVmkM4243FrlFHR1RjuNMXQKihbPUMZfDrytsyWwOPzCpUnqo7ONc8Efgu4aYZQMIYiCMhX/d1xg2eyM+LnXdelbU8ItQ8pgTvOZoV8B4kwO/CisvAiSYaa3dL5o47Q7gj4cLmlRxd8f8LbsdgWffBBO7mvMet8lavmidt82MOFFGEVsIYVsrzft91rg/PANi/0Qlh1KbDbyRNxGSTCYq/t5R/YBSt1CFuCk27kYb/R73bWDq4Ho0EhEbJeC8CmkEIxvJEEkiQVV0FQ2jXisqPFnj9iQ43V4bVoAcVqWlVVATCah27AhcQAq1tQueMDoLO3ma34QWiShpBPpwqGPPDSnlnqwBoaYSOHBD1QuO7AnCAUBpSH4G90KC7jxS4nErGdmLy8z8GHFfuKq5Wpkt2NLCfBlJa2MPXqNvoKlEPFG+zZPLbd92OudRc5hnW1p8YBtmfMN/VQre/hW+J1w2BCvtHACTBOPDGO0ma3ug3B1CCzeRQgp3C5nLzTu3QVrlW1WpwbYPj/fXGmunjUPH2qKElcQ5Z3OmDkk5497ZTPhSTQnYB/liChHJnR9KWoJHQHI76qvP/IWtEMher3kanQfz8UZvDYJ4xhQPMJeRY8A/VGx0YLk52+Oo58fK5qn+kXIFQ10n/IO8HGxCu2sQ5+V04uwSWFxaWz853DttbFFmSgF9OxO5PYbYJGSX5DyC06DHXrSLpBfNcevbSDBa7mQyaPbYsNmXo2h4ErX6vTZ3KAC7thIJF4OxMRt+ZxoMbyr0fh5MfOWFg43o4K14tzozx2NyCFlQd5efExVAhA5iyEymwY0ytCGi+BgiQDZ0aD4PGf4o4xU8hpl+V3bclSrwOLZyb6osDCtTwjAHeNkfj/tdZayT6wCtdZL+PnKXBeQ7iw9MAOQf9Dn2xoqq2U10Cp0pFdaffxMxjVxUoeUiGNQnmIeUChr3eN/OTJ6ZqUlR8yAJqgvQsssVQqPEm1xsZ5OZFVLFszDULDKoIQhKBM1h9KgbG5RZ1r+YIZwe0O0Ogl9wMydY5Q0OBeM0GxwaGJvHXanR/iDFbnubk0Xq1rR8eKWy3ZaT1/TltGuKgDtyLySxKyZ5nkgBBy/RHEVyRusyTFVCuWQ6l+KpiVCKNJMp/FS7NBUcDMglgCxW4eDc1eIh6JvDUbTd6bNhmikFh77meOoEVi4mWaUmMMPJEqcWhLGcKS5c+217YCmRjn97lXqSCkIHBnMgXVqaYqC0Cxu+tRg5pvGxWndJgM4mAsYWYdgbRndx/3bUsAv0fHpZVetl3AT8LLzS72U1V1uoU/qfWhN+ZAKVDsUZeYyGyK1aXTa4OhMfKvzqqyDiyFUKnlL01J4SdFGthb6164eHjqN7BkMH8ekD9+DTabHpF+giHBb3ciPI30/WnnLroRZdXXskXmTIquYmY5pL0wR4RvXmJIDESG59nONXB2TpHL89qBfCNwdPYVgqEftjWJZ7kaD01neAa/tXCYabJ4VLS1tJwbP+j+SXZKg0+t4ADsP+7enn23lyGcQdDh6pkHvnxKUP1D8SbpPCobggIzUTQqr71OZ9Edq4Yq4M2weGAiDDFVzh5ZH3IH5jPc+PvQmxNw+QkaSpLvouQp1//g0BvnBI1+hmIenOCkqAtxGgEN+CvMpVSvWAHSnjZHmfCHJ1LzkK5J0BCInn0LAvVoprALNV86B54PLAa6btBQMeUHXCRdQ8zo4oWpyhi4Ox1JVkCRQyz7Aq2+aPKN2Hxo8OsineBAiI73KuNUKi9Fr2iAZcNlnOWY1Gf+2Wy5F8XZ3owdRAGa8Qei4PujqzMv34u/xE50LbnzO/N3szxdzMdnTJ/9lvDvk/a4Oh/PXA//n9tif/6Yiy22v+z0k04P8ctsb8n4P+Hf9nM2rNfAGTIvB55yZdECuqdQ6uFactMcpiaRq/w3zbMJ+zp4t4ajqZSJRV9NRt9tn/OGGJCf6TQwAS1Be3drst34qISkICKxA2RF17ZwfU3unfDkfB6nwydnb0Q9S37IBBB4qANFPmRsGdHbebbhd0w3S223GU3FG3G+xIwJIddbu+7wHoSFo9kzsajYIdCViyI/xaW1yHX2H9xA6u04lHumNuRy0ndX91Fexe9BDsPnPvid2r3bSqFA08fM0QGHMWJDibmxFxmNttF4zdQG9z5VLFFX0gpLz5IY5wbkhm/++NOM055fBe3si1NX+yhWB/lvifV1crfoBTF4WfikCG/hfKz49Ahm5rC+Xn6jhDbykUk6WznZnkKzfo6ok55nHERbM7pUBoHq3tTkV5ahXtqeDxvWmvSspldFVy5tyVlMtYcwETMfWdSdZ7kuAVI/GUSCMEL0w2bS7HDMkHsMAAzNmJGTf9bFsoy2OXJ4bc6zPQ+nYDpmYZ8GMWp1+ks3fxjDRvV5Pyvqa1P6fbN7K2t5nTYb6++7RXI1kQowDfTJHq0Yf8HMkDhKc7W3kh7E+bg3xAXBTNwSuxaMSk1nY0Ib4zkm/dTJHKgaEwTZPni9wxbUgO837WrXzFpmKj0x+xwcuLKDPv/OWsyOTqmNAYGC9xKf+fngsZzHhQhSzLzK0sDD9lJNYTwFV3Ug9rE4a8O5IHfpe5yxf2S0km0MpY+Tv2JZGjtFTyVroJS1J6Z3MZwjHJN8Sl84J7QmoCTG7luwT73K8djdlWYkxs02QyX4WYaRaT0ghmY0S4nAlczgqGJBPh+PYnuK3i6a1Bli1ZQNiZ3CSAsGibql9sam6Md9zsMtSHnkHE5I4ggZ1PD0woRuE2Ky/g+6gtJkcPRk5oFtC/DnvDjXKMjts8GVm7sIIu0TEM2Kc0utJtBao4uyPKgCQOm8THhnkyhGHABJFwNr2GGkkbMmMnzoYoq2Akk7MYUwEgH/cszMHyIQHLB4ilzdQYINZZPqxX1D6XiYb3pNomrGkFgnKrYdKd5bi8yqVAhiAJ7zmPnpLHUS4tlhfJTr1NU0zB++mgDFYZpqD49FksPN80/hqEOXOoipSbiC0QJrrQWcRvlETqpAO2InZ/IMUkwNpUNiemn/3X8L96GfpRIY26A1ec4YKhkQ1AD+AhrIcQYbkkJA6tjbhI/khElv9tnq0YRYqf0kAXKm2iWkfHWxu7J7uHBxcHh3u7+7sN0w6OFg6DGvEDsMGYyGH+1N/2bOAc3yVQUsCdooC04bWjUWsYD8bm/Rq4HLfP3oSk0elfV8rKNyavu4BXe1mGJ58GGeCZh/ki3StWd18kBq1vb+bRThF3a/f+AyEUwBFtfSdtBSwLxG00/ZC3h8/Zk7DUTVzjNPWQmwCpAyFqjsKff0K0ecytQhHMWBGOynM4TutPiTbP0peJT5hOAPR3K6ZVyfl2whEGEE5tGnbjnX6NGAZwen7dgj17x9Ou3mMXD+L9fCvpxejYbw5ZbeRhfJZmLAHWMphIvStBacs/TOIGrTVBOw164tKwfyZ6YwXft9j4AcBssi6un/mztOzB01K6guAb/cGxYpqZgZMvdgjUhZyfHixBmm2Bzxi4QdQaxPPHf6UIIGhMQpW5BcCzrxLXL9Akn3QrGpaqnIArt6NxWwYFGw+lBRloUIP+CD/NTMCe2+SHWa9Qj7f21hq7H7d8jyoI3Tgzv/MdbhRuAWQmxsl+NkdBXEnLowfmRdjgAi97iajM2fAKxYsSzd+BDVriN/LygsKu92+/yX7emq1WEqFi/Wp6HP5d9WCaYH68N/581LtpmUw2oh7XCVdzwnTh5CKQyrKpEti2gcl6MIv4im97CjbQmUJkyXZzaRgNOs1WlJ/5r/8Sjgnsv95Ien0dGU9eq3tXyaqrkhBzD6/yM//vTIGItxCsvb92/MfWcWN3fyvUUI0pYTCP2WO5fzjVRlFLXzuZ10tp9Apv23JvAspcKowsXMnRSVbNn3YV0VQyEImhFAKr8XFt73QruA6GxX+VLP5r6KLgqxtaMPQg5Gso6yPak2P3huArcUMgNyNn19602X3BN+RYXxQwEhiMgR5X5ms4Mzc3Q7VPnno5b9zE99XN18z1dbEeYwKvQLbWZ+lwZobq8EXS70w0cnqw2/g7kUjyRAlsE+fJ7Y1r6s+5VOkY/KyV2tt6v3Ww+e+zVgrfqVZLWu6ec72yYPEsKxY4GY64pYmL2xvNTueS6Wv0xaYzkKzADJ1k8o2ezkbl9e4bqpAR6VOKscqD59qRvAoJ6UamMF09a79hc4gPxdpElHCoFXoTL4QbI4zomGCr+AQsA04d7LYTNpj4syCtJr8MNSFJc9pFbkYoOS4p2IpHx+5mEXl5pD1DKLiikpMkV+kqvFik7g6PNEwJilRc7oByBCVh5GRnC6A0S6A093SU2vLtb1r3qZB+vAi+AMnIMxIKqWciHEFLfYVg++DjEOKWLJn+gSHGXF/pksRd8NRuDfBZcotB/Ai10ttkCQdRczjs31Mu4intrIb6Llet0+ocWwfBb7jvvHeQwpW1mzANy5SpKRQz9TP7a/pJAZIBDffd3JcV7+kVP3iO+p2H634vcY11hGi1JqmKY+q6v80t/u+6p607aayf+3uue7J/lAqVJsz2BdfdVmSJcq8QxL+j86nvEtoG4N/1IiFsBvdwD9rAbc2AARw5FOPqjldk6eGET/Wu8hlU8679Pz3z59pdM+7w7rRobueFi8cDcAE1SBJ6ed8OrLfCYxxRmNebuZxI1z0GQtQrMjSkwODAIoXJAZ+ksNIxAHL+IE2VELCSVImpoE3whYIVcwcgzaL2FydFW7PVSjteAyHmrh8eb24de6IdfNGZVWhN7EsIsEmdeRvtWbrVz8/O3hCnDorME3rQh5s8MkpPYGadR/eD0trlqN+5HUdn5syECAXf4WeQt3V4pAA56cSVGYnpo1OdJ3mnF/cBRgydfkm9jmTIp6S+QvESn9StpqPzrH06SUDs0p67Szs6/xPxY+kQXmC8IlD8/XEUYBdbMqnh97BGTO0pqxofbvtbeG4V8lHO28Lpaqffz0AJpjqfXX1cfyHF1hkNSq8+/Ux/HI6zzLSmOTnWtfXDj1s+sWnEzFv3QTDn7LS0Lvtd39o7/OT3K2Z46p4C8+sNY9oJpoxnA2AncxLngqUEH0L2JSkgeYnjc46UQlnIBjry+FP6F+LNVabg0h6pNZLtXGwgzetILnuytWt05YWk9rgNq5NYHjRu0WiQJi4Cj2oKHtXHEybRWyWlt8rUp3Ao2fNssmwIHMkfpqiLYsi/W+URf/NEkBSczQ6b5ziSnmA9QEY3PibW11Vy4NjxDdMuxcBFhJstpmwO8zMbzV6vz6eFexExBZjrLXKH5P4fft0SOxctxVyvnxvdMqo/FzGxZxLfffL/kw5K/GXn6e49/88NVCHZN6aF1MXrJFYk/g7n6O00R2MtvSW8s8QNjhMaIGk3lG5rlWMeqmLUDYZ9qI5FuRyqcuxWYbpyt99nFXvX+30Rk/McfSjtsH4/3DY78fgBxOCUp4MJjldPU4DFm7c03Vc+jAtnzBoRuuDMkrkYNM2pGEm8fZ87yo2sqlahwtKIrCFoeG9zfXgquGPvU7Enw4978HVdcuhTJnDn/pEr597gTkOLu/6ILqSoHe4FXPTCzN99JiZ0mgM9L9KhlZuzbR24FQlHlwIYBW+5xhmEiD+krEbXel2bTgkEK1zRwtANbdHzBOxHSbNZTwLWyASs4QLTaf9EVRvPl/AHukY3GsjNxTXIplJTOoJMBlT8BTwmC0+Ore7XYRrOxL2dhkxz/wlMYz9T7FoA/JsE/i3k5/AN+zl4L5y/wRe6fH5j/6Xzt5ALRJq3BW85kunqEz0v9oNBcvdNNtbtuNeWdfLOzLs3Y5NiEAnhzdE0yR4CNUR28EKmHC85l0e3+t0BU5RFavi1XptHAc3ve8FhE864xO22l23vHmcCduwCexTFigPs3rqY2hR+SXtez5eIVIAc3BJexK66k52eDo8dAAy5N/YgDE/DtOCFyO/Ad1YYBOv3LN68EpTHXiYIZFy6g6LYy9UssSjUYA0OG83WDReEuN8N9WyrZ/g2wHuoIrSYoHOhIBbCDd97P9tXwgTIrZLx3L7xVg1gxYCaSCMJZ7G96ghOV2KGy95N0ptlnSqxmFBF5VpMoG5w4vRuSCriK9/oD/YT1r5h6cQ0kZ7lSa28GCNympUpwqEUApUETLxWCJsEZOh9ZFByvcY8jLliytXg5pCxo3bMWLooMnA2+p3+sFrMod+VAo6rEvJuMkaaqSitES56Uj7iKZOzridAxJlHwbwL1byBDEmEgiOrHUU9s0CYBcEKconYn6itWIZijuzVefZNLoyG/5++NCmRf/5TB194goBiNJFzm507i2iCZhyrM6lAxElXWKE9CXKPUI5geCCdGNjNDyDsc3ya3YJHy3X3T5DrHiOqgVG9gUNxwyMRppV0+AVgMzHdsFP3/v7RYIUICBJOgMkHgP9n71m/Ar8C5Ap0fpoxZIx04/gGTVznI5R6pvswiHqXSM4Re4uJDzojDXxYyr2eiO8Zn9gSu8a+in3mdZn6ie6UyKWSWjGdLqQntAw5MuTYwZeQTpWtnsjzYF5AOmxtKhsIZQEJxnj7Fo7xNrI+SKu5sEnFGhEMtbmV2ecVLC+55qaHHNZNR+BCPSH7vGueCGP5BfXidY/NzdrzZAqMwEacegQiaobs0nvyo1FBF1mBKZyzji9V6lEuzageaEb19GhXApfp1+m7dOEJIAtjN7T6XW7Rys+8eiWChgtHxLkBq5uToEUQ4G9+jpos8RNJy17sWvYsJ521ckT/RLYzL+8DAoXcLwmWujjVlhcrW14RcJqiYSnIwAe4++xqOsSV6ZxHM9qE8KKZirlXr2ZQWJw7wlDDV5cvLqw3zJwN7bERM9MyooEZHiZmQxtOlwnNNwmd0fCjyZjRmQZfKZXt5dmdlUTuzJF2BySNO0KycDssQd7mFwInOmTPObLk9nIVEp85gtDm3mgOxrdDeEDZrnSZtv249j71MJgVX+fingwq2b9S2zFujU4+vsfhiAwNHkciMIIBOFMg4kM43b10DQBZrJChOu1+65ajUmoNo+Y42upEErFWs3fXRHfnRPuSjhulFje58o2+h74r7ThpY6hFg2uGT0f4KIlPUqZJz+VEavTrRA8EUUUoDxoKtQJFPd6iGUoxt1wmU9j2wqYuS1/G6HVnhdI7q4jArXMMtg6oaw7LO6A43DmWDURUKoYHV7O1U/y7nEjU5VmCb/pAJycSNSBhZerd6/o2eS60aZxjhbouc1msP1ziMKWnJ+BWAOK+WHur0yzgJdxtTkINmhO3AUdJZmHsotyLRugF1/Zp8+vAa04oeBY5cjFdeGEKd8bG/3DpXGRTA3FLSPau3ZqVy9Kd84IuL5XQLlUz875If7oiZw4fffGInfTsbG0Hjq4CtZ8y7gv/+Zy4+fY3jLMmd/j2PMuWa/d7TDuIW9/G/XVh5lVbcF5uvykmEWvr1USN+A5qwCnczA+Wo1XVqfrw+CigJiIej5Foq0h5rpYmZFUm8FaBEu1Uo8RToXYIYlLRNQ9M0TksKvnp2x/voBASKr8lh2HohUTndFUHkeYDoZ+LMJrHIY6lHMeAD0Uma0CqVcAMAZkHjMcE4KvZMd1vTlJaNQkUBWcR/ID3+paMu4EmcF/swTLMTubiILPuklUSglzAA91gRHbCMdCn9CuahYSQm5263Y8XSVNBUZqxLCB20gD8C1gK7OQTVPs8ivqUCjtnXD9PQ69aFb36pJAkJCU96jIEEuD5NFr1c8alccPEpPptpYauOU/Wyc8ppfwrZBhTL0+wT6Wn6y4r6sUhuQO9XiE3NFc33STpcp+UViWc86B0Cvmn7SdJKt4npVgJ5zwotXopzgW6xBLuQ5dnvwfPv//Hi8ewdtlLAldP4elur0nc8fl441+95ax0DXZOSFPLKsN8TZZhQvLE1zR5Il1g4zC8g+Rb6CB5lqME9CjkP/8ocWpMe5RQR/cUx0sW1T5LpNjHxIvNGt7zDof3zBBFNf/MISnJOK8qNblPw70s4WMgLfPXPGfIIqV+E3patvBglC6U6AgVxtwFIDyUMtvRigE99odrXBVxrfu9mHUkPUrUrqKVbOijUhLhOojgQYTHpaAu5XQp9fiiYuVFbUvXfzwUQmFvXyYYRAsv8GzGI0aWQJiCzqotbuv8ZK27Ifsjfw6z4rbbmb4dfyQ2Grb8t2/UavJAvkWFovp3p+BCa4/G2aAFIVmXEgUPZ75Ommlk8Ofks9ttXke0PVkNvaixLuaqhXCijsx7ZurtwpfE2TJOCWkLqngR7bP0mbQZg+XP2H94zJnYBNwqbIdu3A5H/aH2tHh+JxXAyFGP0nHjV/qdOJiQAw9lwyNuU/HpiWeSp+0ju0OjfnpnDJzTlWPU9gC2RLt1G1MOcBg4gDPJqAB52R55Ga7LNLJ0q7Ug+KRETR6Wluo91AI29XC9lA34GHTkXMymIOPXSkXFcxFwnd5/yrvEzKkQTmJOLuvx+IhNB48I/n4Yt7fjsePBqtNppDnDgufLz/JAkr8ZSnl96UTrSscQKPY0ukS6XWfGoeOvnSMQM2CEXnKvvHAfanMi+CN62Ozf9/IjsSDFXARffEdMy2kL+XtmjQc824uuxjPYbVebSMulqs18l+4SmUPfGXFedMn3dgyA6MF7d6cLMLyh8CLwidwdiLiW+MUjmQ2NZPYpIzkdzDju5yJB8qebiO1S53zz8wzzoHnF4DMrFRKzUk7FgpPQT8djDiHC/w90IaLXy3lUaPA15Ra87WaLGzZUttZB/z5fKVXrRXOtXqmWgZvoAWNOvNVZ0PGNp/SzcK3HlW35Ltjyt99ysFolqlGx94TucDsccuOFMmCmUqPFA7V8DaeAhxNlyNcW+H9RLnbYe+ARMs/PzibZpmSls2a/Do59LmN7M0HgpcF0s5C0Ib2BFYMDVt3CKUz1M3eQ97YyptqtO26A81gvCk940hpWtzpdRrzDeFLq3nbG8aDzsP7wMf8x4ijVSttD1t/5Rp9JE2xjDhj3P2PAxB/nBR59XW49QOTRmcysAr6ciy/ncHzU/hWgzwscvtg/58JX5h9sb9Z58AP2X9UN638Y8eGpuwo9/B8rL5SweqFiy+iwSuz0uuZTtyUNUDZHjqrfkr5nUgYyTl0vXr/O9S+/vr5iv14fq9Aor89P+p24/b55ex2Vvo5e3DWHIp7m0VDmGuVBMFqdJtMT+YS3+kxzHd7yyczrJRAz0L9ldY+b7fh25MQDiXu9QIkQfLUO4BVIaR1+fmjpNDbw64T8Ktlhoz8gv8treadIXp9ogdy3Acj07fz/F9xW0lCTGl5J0grbCo/qSTecqrPm5JGdqYaPGRnIn4pgud/v0EdB75z6AEEa2pPXUKPcORfzNOl6FAnOwyJjHW0miXb619u3vRYMPzi6HUROXVgL8kXuxWbGBGnlouvFvbmQPlAmrqjkSNIKzliqSj+7mlsK8EU1x/rnSTTmOX1G6G2aelA5kA82jaem92KTqw7ij9J6h4nEqBbxiliVsJrXIrSgfHxrgXCuuTa8vsxX60wYqM6X7X8KCRCqQQjlsv0PMT5rmzIxEGQx2GzRkBgCWxW2CgkVxgByte6s3skgEry0XKp4nbqL3XKm6P0winpeBTADx1EbFvOYQfQA9vkAyEJOjfJ2FiWLk4WD5phYVO4eK7h5E7BzkWILsnhMY+14NOg0H0x4Jns8bNqS0ubuydHe2vlyOYw+5xj8byFNSNmhKCVLVi/vSbZc9XLlWZFGkFEMO2xW32GZmUPmMcc2brjokXcR0OJvwtA4h6DW5JnwZmgLl2sk3nCMj28FHz4a9rl1ifGcZodbHVSJuaNpHK4fNnas3OG7GSMelgkv4HKMJKcNGR4Fk4pUiTNBDZs10G0BF+mupfOrER+Ulm3WT9cbqXoyWzLQtOV+fLcK2C6/70VHQ0kSwsZN1Pq26fla0DHj+D15S8aNu4xy18K1fcjqNnvCvTU/YwK3s59O/LjCjP8sWZ0RAl33sQk4WN7a2siMhA8fND0BYflaegkHZla6M5iZZfUCM/sW9PZMM8umz85sh7NfOa2sAzitcS/TtAr+lzat72zt9GnVrh7BaTXnbt4PFA/O5EAYDHhoPzrKggNLPs/baA6gP4lbh60ZqvHDpwtT2R+uQIumJlABUhVsh6iLklDACqYKN+SaOPJKAFOnFkLXhUDh7EtFPuIhmSoD2tVMaFcT0K5mQLv6dLQxWSaRRQOGnsekYduHmA+MjEXxEisb8syqnJ80c9JL4i6SQ5xJkSinobuAWEVNEJJN6elBVeDk4LbEcrqCrzsG8ihAwnDwvAV1nKMXtiZw8oTtLEiNkwloTJHO+JcTDVQTpODHjksjAd7JpFJL3FWmUngctWh1I3hYi1LnxJYtwsd2yixI/SbbDAB1yCwrovQECvcoO0jRGYmmlcDfWx5XbwV5eSvEwYOdVhM6rXqdVoOdVjN2ylUQukte4uxupekEd7Yqh62sCkm3suVwcKAVMUCklnrMNfuWAMoZjRyoALGD7Qj0sM6XEb/sZ6Ojho76t8OWg4HTBW/V6kRN6cfTPrz8yh158s75HTTTENAStDd9C4p0M9UTD1I9t5qjgzrmwgGleUBrt12DbrfuRq6+l2Gnc3O5urmSIKQGG7BWdJalsrUDc/gmmISIdkgZp3kBZYE235EBWjwmci3N/OPU5tUOPu9TTavCe5WyoXcMFzDBukHJqGIgM+rcznN6AclkRZVqYpWAAcmYbUnJxKS7BqU46zXRDBhaVEmB0uwkk3G0KwJBYIemJRUHSal3eig6EhDE0bvSprCwVu9sWAijwlRYsMnQWIjldoOVp01Q0TsrcBhzQSCZgarxpgFNQyrjtkif+MyAnE00qiizFvTaHFXNDTuqb31jXShVBEVq3jijLDiZLFGLbBapRlebZILzyBv5ktl0bx0bObu9D5ZivniPH/zDwne5mxADhs7BGJ5pQrJsupv7QJtwL/epvSAmL4T4o10cbAiwe1VORJlwqAxeMAKMsjZ0byBFpH9zvgSOVhArY0LXtce3OgR5MFwwX/wLpgZjfQuvEjp8ILRXuTwPLjznak0FGXXYgkg7JPVo5lBnKjFJQln6F+DkC46cUG4XWCUhRUzysZSFyWWaC7Q3ZtHQZjmXEvb4Aszh0sIJRj1Pb5m9pWJSEWq3SIcgKn4CoWxcO5y7J2P7xPxAaQw/w6Qmz4wlNTzzaCEwHc5xRu8tBDmfRVN1yilG51np0dPzHFOsYMh/tjvN6xHeGfZRCUpZlOVQqyxlPtWE8FpOFF7FaVueQny5g7ILldHFPXYkK532gHvKOXrxdzpIy9mOT3um4S1Fb0N0Kj/DufMLD+/nOOJC0zKLGQrjOWWYaasonmT7YG0tgt+ETsPK/56G/4NOw4RJpU+2jJNafc5J/WXn3xNOr+oiOL2m0qvY3Cbx/tfuVnP5fGL7e9z+Z/NDsm2GY6PG+BepmaWqRNw8+Nynxs/SVmguTX19Pj5d+cV8OpuAzRgP5t8eN7duVNUwozb1/tO59NSTlZlN3/yvjjIFl68tPJ7Ll0tL9XRmr2v9W/J8xsnKpcUpuPfUOgE6S+bskTFPHit1dKzM/+8h8RyHhHj/N9G6XvNyhLiTmvBWf5S3a+VHSWzzSEJEOw5O/DGKewiAijtlKoVNMgVdzQHBFrA21fGQaXHbE4/jsrE5JtbEQ+xvq21Unv0ca0+AVjHdvP0bKRSVlKPmR+LtKublHmMONcMcDfxKbob4qf2RoZHksPrP5Ab2HFB/JVe3dxuTLNW9d1uYIDM0NjeF4NeK53/it17xcoHfF3M3yJFjihc+06fGzhw0YK03jhmJNkdPeOPPh5aaADnbowIJKjWJsnJ1cZ2qlUcHA9bRb6r40TAo4XNcH/zsRB9Ykp3LDUr4UMhXbWUUNGQ0jgY6qjzq73XgbZebZJMD4K5BPGheIgqmJ+zHrT19GM2sDYfNB4Fp3qI1C0N6iBj3kIMRoc9WQU9uqDPh9iIetgKewHQN1qUeh5sVheP3Z2929otCUjx73WZDtRyfXBQhHBR4QDArCJEVxQle8ILnoJHBEfFHIXykc3O/YmQhsccbGVGRHNlPy67puLAXAz7igXgnf9H7Bh6o8GtfRv5kAMUx+zv7XTrmGPuJQY/6nYfrfo9MCSoWtJDwWuQlcmdysigzIoFPRaRfrAl7AR/Xq3DyQFGQkTyV0Ao9X+e85yiF3FvRl5cpmHqyAvwYTUDdxOdFzsAI0LNyMzlAExrMOQ3AkuBsOLaNXYI78IIL5rpVZf7rnRwACGK7Wnc6HbuCNXfWw18p6MBlHP70DDuMIol3v4J9rzz6gALd/1UHVCIK3gElzvnxX3U4yZWgGfhg/O93JD1xPM9+EEkEL/38m9qBfhX5tsORXZpbeW5Ig6dQC2Z0JtgL73KtkkOgK6VmZ3DTxDf/O16lm9sIVznxqoyaTJAX8iyuuefV7Nwy5sBfRjjp9daquGaVxM2r5OPmVQni5tUM4qbNMeI0z6/xMN35Ne6fsFZxmFRBcIHcb7lqve7gjq1A5tTa4XB2GBy2RSvVRWwN4iE7d0R3phrqDvEcMvS7gVCtLwA48kMyNInojgjWs4DDee/w04l9pXRxsQqs1xOB9wnv7yQFb7EcrMmeaLLHm+ylNKF2gvgtn0fKQGlrxdxOMXdSzO35exCLNZdsM48TJTQc0ROF1nNkIy1jEdKRrC99ZbgKPY2/jP27dCmFr4GjnJsvKLJtss0xM0ZJXs3uF41gZhtgMaMVzYlpmAXtBL/pqdF2rXHFjEYs/5n148wDGcP/eZH3hN2Ejro31JaMo/5ofDTst1hb+UD8vzPL86FocSLmTP5KhX7Jg9sfdajJ6DPgJmird9vdHUddG5HGfJHowHg0ao/c3HabvWHUbPPH8kVeQ0ZPsDQuQ9LQ1UHnTkg3iG6JwnGVwnyFGhYejsCL90D6nusIIj7o/IypNFPMzSyX/2uyXpYeebTDXwZQrBaHxf5JBFZdzAKM1eLA2D+JwGoLWYCxWhwY+8cCCy0JXoqVFz8KkNh4Esg8Dnv03z/4gYAidq0N4tcPfUZYF81BrEN1na8d7V6cnG5sbJ2cSAHbfD04bFzsHuw2dtf2dj9vbfILswoo3j34yAo2L9aO35/ubx00eHnVaX5yenR0eNyQjWugcHPr4+7GlqizfXh6IMrnQfnHreOT3cODi/3dk/21xgY/4+fqfvv10xMeTG1uARQ1dve3Dk8FOosQ3cOLrePjw2P+fQmhebF/eLx1sbnW4FLQ3DIo2zrbWTs9UehX4NxsHp6u721drPF5E4VwZk4P1k4bO4fHZtbgtBw3NsSwj7fWNgXuFTgv27t7zqxU4LScnOzZUVTqxGrsioWoVuYX55dqC/OLRJVTWYdczL3Dg/esbLlardUWq+XawlJ9fnFxIaoRdeUccEgqp8n+2tkFKzrdIiqfNI53BeiZl+rTyxlQbX/3IBs8/s1UDNS72D492Ggw8tncOtk43j1qHB5rPLgxyEdLt9vcamxtNNj8H2yBvaA/n56sy9sZXHmrId0D0Ne1PS7toab/Qm1k/c2t7bXTvYYm573dk8aFQGy3cX6xzymrEs3jqqztp8PjPzSZy1pVXev8cKNxeLHBQKxfNM6Pti4Ot3l5TY2FUdbu9jmHcfRH42Lj8GB7Y+f9+SYPUTgzmqHqbO+dnux8rKo6Y7oOm25T5ZaswrE1Ve7IKmwO9g41MvdhKGt7qs4kjIyp8xCEs/ZR9/WdrHPSODwS4dhQ4cfqxcLx2qf184bY9xW3kM/5pmIliiaOTtcZPhd7W+/XNs4tWanPFQXNAlMFVdANhlQDJTVUMg9K5lFJHZTUUQkczgIq2dDcYNH5vL13uNaQkejAd0l6ouxiq8aZCCRJVemE8UTbkSzaWTvZYZx8WxdWl2Dp+trJlqBkvanBzsQVTrYOTgRnNFtUF/GxcZFEx+h7E4JdZJVOot6oP3xDQzcxBkVIhP3RdTC6ZVeUzczg2zzxkf0XByzkh7IA6MUrlF9d2KVSacAl8REOSWg/A3E5soiqLBBdeKXJf3I8LQ4zVqmaUXFAT8bN1jceHDuaycU9iZQVPsXPkldVPTW1gJH0qYd+sb9Z3xhPsgUJvby9UnLVadwb16rScIhiSF7G4xFRp1pAEUXXDSBRzH5esflbmMe1lgCgJQnHtsdVa1Wi03DlP8tf7EW/wvt6q9eOmybhGeue13rpVLu9Um0Xa9X60nxluZZ7Z+0Gpk6F15kvV2vsHJ+vLJJ1ql9EEMOFam2pVilXyTo1UWeR9VZbWlzyq7DZlvh4XyvmK1/wi8uHMdMq75jmGO3aIFhUeqXKgmO+1cZOO3vxF3Tpo74JK7RAsTrPTlv2tzBSFXJv34IvlYXFSmVhqVwQNZf054V6lX9jVZcKcJhaV7oYD5u9EcO3m4ehg7e5+S8/KeYeirnvIsZg/nvu/+YmDGL+gf3xvYCgiSZVt8l2Jf+9mONfwC34ds2DPGEAJVAP5rxXmVdkLf6V+/8IHNimY2ItP9/yV0J5Vk2LOZmMa4TCJcpHwLO5K9vDbC7Pa0q4CLysnr/nUzmSBQyJe/FXjdu9Rk51pa/zDiZo5kE4Bb36kvxtwSUsqICCFiyogoI2LKjBAjac3R4kM1kmcpLK6cpvV4o5NjuXTAdnM1VUbfgGmM3VFirz5WUmMZeLuUW1jm2nbRs2l20rou1yuc4262KFta1oVtVyGrdAe9W4yhsvlBcq5fpSZZm11R1fOm0vQXPVtiY6rtbL84yJLCwUc1XdcYYRz/PG85UK0w6WasvLU424zttWquVyeak8X12YbsQLvHF1qcoYUn2Zh4KdZsiLAuvq/HJ1oVKr1KYb8pJAe3GxXK7V5ysLUw15WWBdqy3UGZdZXJ5uyJWyRHuZ4V1nQKYbc6Ui+y7P1xfYmOenG3RFUFiFLdQC1wWr05F2TSJen19gE75cn3LYgsaqi8vV5YV6ubww5bAVlbEpr9Vr1eXQsKv0sCV5V5cri+XFJdZ1nRp1lRz1gtxXfNT1hQU238vUmKv0mEXHC/M1duAucgKtzFNDrpJDllxouVopLywvL/OFLmcfsZgutqVq8+WlhXJ9qhFLAq0tlSsL5aXadAOW/S7U5ueXlpYXKtONeF72u7TMN8f80nQjFnuyvrA0P8/me2m6AcuOq4v1ygLj9wtTDVluikp5ke2oWq0+3YglE2K91muVerky3Yjlfqwu1cvs/5b4nphizFXFO2uMjdQr1amGvChZJ9+IS/OLU5K1ZEFsIy9xjr9QDY25FqZrTh71paVFvszz1JBr5JDFZFeri1W2qZYE361QY64lbOUKOx3LtbJAu7JADbpGD3pesU7G+xYXRaj0WvZBS5a/uFBbXmQHxsJUg56XfHOxurTMqHPKQcsDtlJbnl9YFrxvqjFLNsIEA4Yz451TjlkQ98ISQ51x7fmpxqw4Z40xgnKZt51mzFKOqi9W5+fZplycbszisGCcgJ00S8vTDXhZck52zLDtXF6easByTzGNjnGRyrxgu9OQtthU9RqbKiaQlKcbsey5ury8UF1amK+HxjwfFrSZlL3ARKn5OttTC9SY58kxSyZUqS4sLVfmeUh4k+Go5TQOCyNMBV5gMsUyn7A6NeZ5csyKCdUW67VadZ5z7Ur2MSsRjMmd80v1+mJlqkFLjs8k9OUlJhWUpxy0FjzZgBkXqk03aMmEqvMM7/n55cXpBi3POUafTGRlbH+qMVfUdLPdXGf/q043aKlgLNbmFzmhLEw5ZjHflVqZTVhlYX55ukErpWqeyTLzVa4YTTNoqUcyzrdYX1gWbGiKQQsSW2TzvbRY5bM9zZglH1pmfGSJ9V4HQ8YGqzz8OZvjNheh0ywsVpfrhbARKw9/zjKM0ttVcTsxulaGdjXcTixmO9SOG4Wa7TYPbZ9ntaFRqCM8mdlHnRbcPm3oO/EXx8YcIS1ppG1NOJFyoG/f5moIdeO7oCu/zY0d72pljJud9Tw0tJludlVgLAxnywoB0asw2XDbWE1+vb+JO5HILMb6YU1sT24JD/s/Zn8uzHsew9yuOZYOiXySWRP2g0w7LNub1jBvGhq5MpwWHEdjx+KI3cSBNc8U2JXRRr9Ws9O67TTHEbL5uWvmzZM7zkp1CSxX7l2O+6U5U5c+W+VgbuZnmwJhjpXzIJavMs/+xZ601uA6JpBy3PPA2OCQf97Yfjhmdn5uBzeYrFHHNSpfUBxvd45kku+RfzFgZCBvDhecOWTN5dwZRiN3WvWLskjzlwGMmthOB06WKPMCA4EvkPTFVuNhEAWvUh6ag7goy/itD44XzAv5+zr2D8pCxGsfyDsi0xKnKer1otY4am/3RsLtBBYOo3/eRqNA4c39bnv9QcHGRbyT9YcdVsErEj5OgbLL5ihSM2BYdNztMjTiXjua6EnKsxlhvcfsGON/8c7kXww2DwA4FoDGDBDc9TzVo7osc5H8UwP84hKJyqoH00VKGKu5u37c5qbxf+Xg15kZ/JJBI8jvgWBZLgEJ4UEum60A7jlCSZ+cHYuwe2kBYGzchftTN/nCcdcI2J3ajthURLlws5XnH6rnIYyQCC+a5T3uVFlv2RCK3gB1RY0g74cCxijOhQII3BsnK1uh+Kxdm0BrTW7+rIa604n2/Ldl1AZBzsRmF65SHYJNCiFRvbncTu5mxmCvo7G3mR+5V13Cd+fJLZ+ZEbJNto0QosKkraCpMCPZuq7c9HoSA0PwyVYrznssxuovrnrgSYHl/OSsiuouecMjARGcrL5CYZfU0w/E50f9zl0kSIL75EKSUESk7vr6YymJ65olcUAcXuVnSjPAqVzVewvnTXEHasdzSIil8bovqb2nKBs+YxB+GnxjvEE+mUW3yv7o+k1upteXv2ZgOevutjN+k1ORKtlPy4p/ePTlzQFUVnLmM1cP2KyY8CpGIiiNbi9ZJR6gvsIz3+7176PhRpOnagtXrhSyka2YSmruvJlLnbfkWXPmzJDOCzRtdhOMomHc7AAGyT/yFprBA7p5BxGXac/v4jaccjuFsomVxAVEoqoCPZuroMdxDLKhSi7Dlfh+YGxyk/XYivKi4wIkzZfs05QU6frsBkhTdpn7c0YkW+cDns3NfMnx5G39Hn+US9LszEyYVM2cM3B6YCfim3QAtQqM3Jyq/qyiW7g6IZpjDb/8bbeqcJAp5npsIGAS9KsD8VLQ0eGAOw1v5b2HJOfJBbzbzscF/IQpdKjy6cOvv/B5ys9MLeLK5cCvwIhJzjTN6ROdPNVgsu10k6pscENWCt6bVH48XbAy7ivnn2DuO07JhXUb4iSyr22HZm1gC4WIyxaslGkb/eWzr5HOtgQvCOyyciWA2kE/Z6bgT8sRJF+64i8eGWcSvErzLbszvpjxOJzqB5RJuUA6jKNeuyOkgZAEwqUT44BESiz2TLE6jZIkROOSGT7fXHBhvCNSN3FPsBupOhuIclzuSzqg+LOzbr/fvu1EM/g0uxIjFpS4a9hriEPIykg6CrAIT/0z/aQB/fFrZATZqyshYHYBN/Zum9zUektLWmMzrCtboQBKBIYDiN5Z9W2e/IU68yElGjVJL2ER91lAy6+TBY1tL5v9sWZ6sOPEEZmaSsdDwLg/4D8IgHbUbhOey8arT/fJh+tMo8sWQwTK2zyKPL3ekTXiF4qtZtb1gY4xI0Razb5Gjj7NWVGRPxzzmBj7DRSgBBbGZ1BWVhTmKoJIqUM1uTao+yY3V0CTlDqD19Zh0+44nzo6y5BXQwxZKc9h7RkPHxKhbpYkmqo6lNTI5gh2Sk8Z1lj/Gewuy7rJ9iu02SO5+x/u8WUhOeuPkvolAQ3QuHji61iBB7eXwBinjUh3zQ6OmBM2Ir3MmwZ28hjTAF/9fsxYgKH4x4tsxkAJCYeZG9rkmQ694zGHc29SAwTg1pX1LpR0WJbCRt3muHVjmvEaQrRw2pvvYhcFHv7861+4XrhTPvB4OBrvNIft++Yw2m3nHVEMJUYUkjv/GBNzofkmiMBIGyZZpwfRBPbpTrd97jCOZAndo3cFIKpyQezljHshamGtBBqZCgV0ZsliDpK4YbLZIfUV006jcbTeF3FX6eslsffkZcpl3LuQDwnYZrwYDPvXbKpGG5foyulKncSmHYwtyN8WrBo4oMQCy6060H18jyVvCKLM4bO2UuRgjFzZpdGBLPBjZfIJlT2L0ViY7nA67PjJNvlRJJmjX9YcPfRau23n7Uyz1YoGMg6VU3/cX49OZIRQp2TETvgj6Fngz5QLK+5G/dux6J0A1ggX9xiFE0lFW2xzjIFVTAVUkOiij2rO5ZSoH+5zNXA/oFaFftBml8a/Dk1be7U0T1/7J2BMUYn6gQfEvUyYqBc1u4njGTC2w8N+8L/5vmFnXjEX9Vr9dtTG173D2x7TijHBXNyOWyfjZnfgfu9t9Dsj7+Nx/977OOIBvzj1uAVtFaDI+84HxrrsRKNdHmZKHrioyhVn5CoH02YATKvfue32uMLDUfoT3eFbc5ZHn/Foo9MfCZUcHMC6bO3umiqQ8VpcDJp318RXGSTFw7bZGT8MiK9s/Tz02edh8578HF15n8Up4s9BPNrrN9vkQPlj5dDrePnQHlY+PV7jR3HmBookFV3LHyu+2wGsKz9CPw12trLh3rQxgxW2CrbR+leQ3oV+dsuU06u4F7XdO1oOKu7FTEXud8WeisZ5crP48qPbLLS/VDxBkHsXZNttTpg6Cn6PLvpXVwwKyKkrN8NRNNzp3w7BFcNx8x7+iq5ADxvNTnzpLbre4wpB6XeX178qX7g7mXFb8TiArldFrWq4ldyuunD+C7WBeFga4cmyUBBXwrIOHqcMnQz9XfjqwpYv0WWy19r58CpXW9AxNIm7cgW4Xqm6gLOAXihTl9VJ/Iwjw6MgEmtrSADM4wJQK2w5m/ao5mrRkOE6SzgLYL/mbRN06QQwc+GR+fpKgFfrgdWhvgSoxB1VAExCIRwgQZmLXwJsn1djFLBQr9cA4Sl9TXy1uKGz6QdxFJopsWZUWfTO9ShIGMk7SuluZ5qEWdzrXE5EmEtZvmCgVq9PCTULwDCh+XKAugnWLEyxVW3L5Iw/vpRt8gXyEJVNjWsfMGHLGniD+yeKb0DdsH3uNHvtjkqbrSHavM+CnRsUnAt0eKqXTCDXslfMTvfE4uiKKI5hngDlZslv+yRKhNVGojHgQQTVhMVf4FURHwW3k3qOmGRHPF0C1Rk/peySxOBOUJWIf8BmlUVCkNGNOPAvXqn4x2mIplAMjYMvUBXYJKoK0RUx7GqYoyPx0aVOcFXqxSIkORsQVMOLDuoMbPxTgMhsboaLoTOFxzRkkurjGrLldhtqzSDpbHmWIQf6rdDeJATXdaR0wwbaET8h2EoZEUe8Pcmbn8tfcv+Xv/VcWCoo0acIbhMclcAByz5aecsRv4z85cLSKkMSLCyUVWoOrB9kIEQOizGBUSQ1yfyIUzMUW+P2xAqVt22h0P+JQySAL5DSlXbx22+5l/iI9QydUL/2PCI5QoZGfLbt6pypQNUYHA4v5/NTf9ge5ZHiwQu/jvo9sbVH6mZFTFLB17E8Wo5FUqNyChvQLJRVns3VGBPlOCpYyF/QfMVZZThg3uRPBuGLEVL4zOuvgn8S4ouGKvbXQfMApbqZtoCIw2tqEoQLcJOkCz5Y4qU7JraqnQC+U/HAic2aCa6D5ryLZp1C08YElqsvqy6sUE62irPx/kcd7pTlpW8gH0+ogf1NKGWKdX/aQv2YcgrxCiSc55qHEHs5YDGxnuABdqOZ631TNaJvRzRI587g4nbYQbcT7Lfs7laYlGc6/evraFjinOkfcXvVumLi8/k3pu+LQnUnDOJ5A3uAyIQ28xtT7xLravWvgIPqKtQg9vz65S8bQRpy7NPo9uoqniSh9/g5ECb8XIetqjpSqXV3j93mfTMeOxavdv++x8HYPWQIo1CAg7K86p40OEkd9R7+4P8FgnOKfmSKgY700k3bokE7FfPiAQ0EXkTqRxFJ7EUknhcSHgCo0eE54Oylfc+jId/2xglz0f7PnQxJflrUCjEdWYrbcOpim2mXO/HQ7cRW8xsZQxHdCliN8pvNcVTq9e/zBTnjNr9eAORpY8OF6u1JU5kAxHZX5yQBmAPBB0CYNPZHqShRJr9XwlaXqQcay4B1BUMTRqDNrCApkxExif175VDshUeXJyffIfYJTFDOB02gRA6YH2SbfrI82xTjJzXFIIpCL8SbGEPlFR6JkG5KISRUVwIhQvlNwA7UfhyODgCMqU40QJOHLPVbNe+iYfM6SmgplWqiP5UhINCfKKV3sSZPYkJTCK6NEqEgxhlgSMbArXkXvWs5NRLoOLrgqnzRGVSCE1fyR8AlZ0RjlGdblR9/nV+BlfAN69/bnFuoC1/LtxfW6ILRBcmwd0H+ybr58hS4xAQKmH+yzr6Ya/UQpNCNJqqf8RbUXt1H40z39tBZX11Xy4+3vXisfrb7t5edCN+0m6/KdyMHWIx6qWackrxL8IT7cdMtemV92/nGFZng3f++5xag0PILtI8KcRdOXGiOxPT7t9uDYXQXR/4deVcedn6D0W232xw+7JM3+bqQvLpXhY3+uNmR15vBYsIN4ufete+sHW9+WjveElkAEqPdmybatW6KJqcHu43MlfWE6FRGSvzgXt72/wPLubsBqGfWQY8Cx6fAFkOPgkRqTaBX0rT9PKigDYhnAFdU21EzhKQBeVziFbw68Ufp8A+iNtiqcxXStRrdhpASKBoXbIlu+aimogKhdkvyyruWbH1iOwbscdwFzhfx+A74UMAfV+gXm5QL8C7HSpASCv8AQhXfXaPfTMxBv9E75O4FcgdRfMxwD7qEsR2vYN8Ib/izkbHQ5zUjsKHPQnfaHxHf+wPi8yYStdQ7DMafTywhukWhJluaEtG8IhybDs5dZ2iK0XhjMN/xGFxGTZegqUaHhv/ZwcfYmNQorRurwF7ywQvl5+pfqZjdht6eKzj+lcZl3KuK18F8Hzh+wLIF46T//YOIqqHZ0viGyUh5MvdOMTej3sYxFbLLpYhcPMqN+/1cv9OGjxShedQFQgfZcGxho0gjXHCf0b8lnz6Y3YRNJeFjOHh+uyKBk2wGV9KigZO6BlVSlJgCStJlCJT1F4+to7iSghBV4G2HkznCOVZt/4zjL6WAycSaLixs4IOTBs2qbhjEFjhsfIRnIcJOnxghRdROe6NDwFPwt9/0bgInndKFXKTerrqHYgGSG2KzKbNg1ewVt/2avn5Oao8Vbg+GIb5EHIzq7bW3dBlg16iuok6STYOKgEAoTk/cGwEXMIi8c42C76SkuZ5uZOzlzl1f0+cy2OLOGqE2NHhowEf8Cd5UAakjaXGsOQFf1unv9A044HoAOIenz4o8fX0Wd5PXmgs72TlGgs0Rb9Rcbiq47Uwgtd+Hnqo/y18cr6ucksj8u1DZ9l2uiudUCmzQy4m85TTVyuTtbxi+FABlEqcE+KYaCd+VDHE9RzokC91tH97LzqZP4g/JpyXFtMhjToz/AsXGBBfgsuRtztkezixjgcrQh2j8xc34qzrz9ldOKAXc28woAMEFM3XdqjAKCNMcOMdiW3AW6BsWEVHh3ZRnFwf3NvG4UttATjmcmj/l5kATkssZryhUVVK8U9V4J2Gognidqnx8DvG947i7iBIkavQ0alIdyIJY34qpToCsSNqqcqmQFW2/UxMZhG32ANRY0qHLeXyrJjQM3cw30C/C0F/Go4PmQV4uaCEIFXAK98uspoZXHsEGGJH3aZZo+SOwQ+Tp5C6LZgby31nEml8Qs2n7fuduaVfycsf7OqB1h8Qbh/DmHOItuD6qBOdwUSon91gOhUdxzJ/SNwaZ2ZyNJVArOpsCf5TUXMQ4FjE1FrAwjhSndxgQeljhaFiE6QLHf8Xa1lsHCQKy3iuE9YOEbNmSu4gebMubKGNJALpiTWi+SdiKOxH2FhAEy9Nc3S+zDmW9oi01pHrsfZqlG7uetsjqqM8nr+SdM43BVyxS7iBMOW6/xKnofH+Lp9ftEho/CRsRcEp1Z4ZwKw5YuR3aUTsNrzr+qLefu7SvvQUqYqovJD3uSbLBE1cK2T9SF5eJyom13g5kIvb9vmBTso6MKQ/tuFIEXZnKrptgyWVH28+y60LvCpCfTjrHhcyCwjXN/R25o0Nu2fz2bZvJxb7Vdeg0Y13twpay3nrcs7ZGY2U06e71l8D1ui6mNyVttPTpwrPcQ3Aj/cwZ64m4B/iOTNYIWw5AeUCLlx172rtqSKns3pWI88GILOl6fTadXnmwCmnJ06gBoikGvZCuDyBkVPDTAaVr9CKKjgCEZuTK0asAmQnNhxUABiymxKmbZiZwTQQB9d01DTjc1TUJ/EiC5ZoBHFiu+v9DLZdlKsgR2TEM63Fiz0XYGoodSCvFmq7TIXgrTkiyCA4A88POzx1chDj+4iqVz6wDiwcoRgW6K/jXHdolgBCWOUh1GguU1N8IfaU+F8XY3DKpBLte/b6O47JN41DxDnrWAWaKOKFn/piGYUL7eZKtNauhUQ9RnXPGaFTyvMN1C7IWqiFPQbKS9uXGVfVqyl9WORHvAUKMGb2voKeYr4XpQX166zjBOIHgqIXgzx+wJTJwZIn+AtPHCV/9wPrtFLOVOmN2ffh/Z3MzRRFFDkgp4Tcv3sNRLahMY3+Hokz4ZVZTJNzQ8CFl7cInWDQFTLX6CuRbjwxQmUaaMExmJokM606QB3zewOOLKSz/lLh9cShFy3/+9TErql7GPXOxNjQQVjwAniBl4Lp0JFdD/REy4oRJ6DFahSyL75rjyPrrjUKO4KLQB3BDBw3r9mGwN9+tTvgqBeRmWw8eAd0+vTnEDZ4I14nlTeTEJ9t1+6L2CEXDNgEgnVnzXysnIOm4mk/t2mPbcl+lwHMB5cWU/UEAeh+DK7o+RaPsTwG0Hu7jomSLNExgNRePMAjvKYGVc14HHhBYwvecfhO1r3KKxvZuNUXKUHAq5TLlWl3h7/sq5lmX1SJf5ZaXuE0UFLo9oIRqxrNLGAbIR1uuXSBtBrK/QfNDxEMKcQPFoJPyt6thv5v0do2mSl9YpExcyT2P+1n6RVQ4C99a/kjOKJOdRHwiIZSG6aTVrPIqdU5ACxMGXwydf5yBU6dUutCK3pkOHxK0+yS0UgUlY+Zr8aiaTHcq/OyefO6sDDc0R5WFFN8SxmS6lSokXpAobW1tnO9iPVYyAbaVTsct388w1WBIeIYn2xGfzVZokbaXqCXiuAIeuGbLOAFLUx3D+N55qiOYjFurcc4i28ZfQpmjdAv3BaUiBr0ojzXKZba1UR092bT2XAax/3E2rjRTVsjM9BP9J57LSkSZvp5mNSIomGaZgUd3ZDvreiuUbJTKlp0H8nkziPgKzjdb/vvJ4UHJAeSeVsOhhm3p6KUC4T3z8J4GTWkr999WqJ5KOlQyelWhC+3LCu+5k67CP+X+kRODZTs5D7/zZAVgx+ki8X7BCwalXjmR8Wm2WdPxyAGw4rdXKYLxB/u+MSkwU1L3MjwO6J2Y3Cke9zzbAy7LLmyKI40lFkydpEdWOqCMS1dxr20tBoJ1FF24MGIaMOPZqNqtfm8c92yGTeJNBHWOhQ4WH8yWed7ngp2lwYKHtAgkreEo+zPu6y3hWm1nFaQPddktgmYxfed7WrvQXKO9Xldps5STHg7w4jMOyAIp65F5DhqNp3gLyitnfKJnGmR/omeaZH+iZ5pkeaL3P27A4jHuRr836ndidgJH7bSHue4TOveRrQyzPYoYxOFePBrjB7eiGfEO1gujLQH4kbTNZ8wSVQRCiodKovZLeMh2aWf1v0spA33XwY6nn4AVJ1xyXjQVIZLb/HVzylTJ2v588db01FiIgSnVLxUTAjexXsdxK7cr8BUNRfiEYg6MWw0YCka9E9kJUD0NMkn+G7YL8M3+yWZU/tDwzShhDAmlF5oOk2PRoasODRfcHxrwuC90SyGeKMmmpW12Vso/wYTZOxyLleTXzoUcsvVLvs0GrWUIYoPm/YVAtIRWWM2flW05kR8ziWbYFrrhMEIJf0aJqwQU/uhebTz77brTv8S3SjprDP1VbTcEVIQnSDVLqJaRF1zYEDqndC9Yot0GaN+QYWo1WwlG6DTsJVhDsZnEcjYKohzJ+Ipa7b23HgeyPYhP7sj+hIZDu2RW5pL0K4UjThKSxqAkVLScx4sja+ZIa4Xqg1fRzpWoWfYq6KlKKOYz5RULbhC6KVPk7c2vph7w1tHjDUmzDWjXhoKWv//EfgWopmOzhnexavhouQDpQzuVnnNWt4TVW9sUbjnvvhcTBWCF71atmm9vdRGst9ySjc3MTl8hVO0Nhvviw+nAe4DidABM6Z7rvDdOLsp47OfJ04s97uUp4sycP0eWYNQ9pWogDpUSdWVGbgE7KMQ9KV94lwCdlwDCZGV2grIEmQ/vYB94NGD7ZMLD2aPAYAZ7T7tYC21m/V2xIAlRzR88kB672cHhAlZg1czCL9rS+mhMoJ/QM1lnhiScEIuV9FUO8GdZ6jonuDoq6hBGS/3xYkr+5Cwg+jlLbu0gsaG2aCskdfLaFR2sBYkEu7wM6cGBvLyc4M/hCk8g1ZEMNZAULombqmRcpGG/z8B1pCZyP2CCnvzzgf85wmoGiMXiJJgRYE71HZ8GilUO61/hBUTq9K/jFiuVEjQuY2NsM8STyrwUYBeXUbNFpEqK7s7FjtNKjeq9ORpvgRRUfixsp56bzArHXWrdcCD/fRFNBrG0Hb3hdjxhz30jZPTTuDdeWhM+WOUCKxlwWar/LWq/yf33jx9UZClfJb28HT14saDYiRD3rj/csrkWTONo2O/Go6ikc3AW3OHw80NmByi7RaFEUWytNpqdzmWz9Y3IYsZKd0dH7CPDg0r9xMrRK1W+JQzlcfHBp70ABZlWJViABWZMV7YF+O7J6IDYbAPwnWwgKNCr7kYfMlRpa8pPjiahydRWE7mCbVrM3D8YCefeuBVW3AwdtwOuBvKcS+dHeTCzfogllapVgJH8Qxxizh22inECcrTBBG9FlXltDB6X0TuMTvLmbjA30xu6hxFIT4GP41N0LPlVIHKrLHSanGAPMeru3iFE0HjPUhzd1iFJdCVFNYZxdxnHKQF244hHQHIYRleMFdwkhEsk0FAjOLJbIOSDgPaI3zTk+YZ2C8yUKvZGIE+q2TdoppwmP2mS/n/23r6rjSNZHP4/n2Ks89xEigUGbBwHjHMxiJhdDPwQOOvlcnSENIBiIelqJDC7y3d/uvq1qrt6ZoSFE+/dPWdjNP1eXV1dXa90cLPDjpxGdthVYJoGATuDtn7EWWg8GffAJksgCNBcZt2EWity7Vz9MLH22elQV+WRdudKodMk61yRlV8bx4momy1OPk9+EcQeGYop6o/jYA2vqfpM0D6ddrJKzmLdjFCXa3BqMehicXKVDqoKCap3omIt2XhDGHL4iNJMPonlmS6+xnwIcXZnDNDnM4QOfzbtT5SFNyyCRK+S63T5QUleeXXv2uaLgFO7Jgf9/wz+u0JUcypixNL85g0oQcZX2eXB4k5wR5AFyZusWiJXX7m0r9SCy14t0WqVVSekX2UUDKB7L/+Solj15+5gaziYiHdL1eFjnaHspD8BBclpKYQf966rtcVs1O9NAKQo1w9S+Ec0sNARr3f16BNGr6paT101pwmp7LOaMXULrn7RZ7XS+AyZc4E4ghmJekWIAtFejbZWqSdpaGZRgBb35O4dp5e9bCJJll2E6d9jGgijaeo4ttF8CePJW/7HJ49sTnNDtC/AXKAFT/QMghjXE/XBxEMOORrHPHtNc1hp2qd3D2xLxi8SzlyW0SD+WWfcO0+ZvNwBG0P01ZiPfkLjg+LmHFtNaJxlrb1OTDfw36dJJamSC8C2EkW1Ss4DN+TIoTPoy8saHuNyEVjEO4oodOwJFEcjvQR0594dttan9I7WOZXtiHuIgn7HvI9xtVPRHkl1oKZOHS4anFac10DFq9UdThRJg+qKxwdivVjx4l7JYkUfqzKU8URmldvgtpLSFQ2cOwkcORs5SiUI+GMqmSdIjchcbRcK0KE00j5kT1VVEAud4mnrpYJddV1NBOFK5YzMRw3y9GlMhEhNbh16CM5C3pDWLoWeaYZHxGTyVyAVnU8mcP5TyrZctMU1tQU9iNdGr9ub3K2HXYMIQHTq3dLrGE07mKfSzz5MTYlZuXur0hMoERc6A6wNrMPshnZkO3WFVChesE9uY82jWrDv7tjb22vKPMBjj3CvJfMS51/jfDv3JGee5V4T+jYnljoWeAIGcE1mHPgC2mStoXSjxbu03x/eHrYv06wWl4c7PHA8tydDVegyEEDp+jzZl+NClOjHN9XXyTwcJfjlx3Q5D93KJ/GtlOpjMmMgYZ0zj0D59HKgjyVHLQezAEByw9NzZSLqzUD8SMeTXpZ2pRA/nIVu+MTOw9sXzFZKQib4oR1NqpVeIOfMWyc5mE1dT7IW2yB30xBSrrETbo+e7wqX+dNFiX/9+0Qaccr7pxMG7cprt3wmGUgGaXNuL2ilGq0HTeL4GkYcS5Lzcdr+VCbS133EJUAP50tLywv1JC85Ho7k5VUtvhKXmIvNSrBB8n2PmTMDOppvxlx2h1gW7LNbUWTQLQ0DQLhGXcZNYbcrJYWCdZjPNKQyV3UoUG/D9MS4c/lYBPygTbfstjZvXUrx4S/pbTtLQaIRWZjkMe1dxMABRRGRtZ94jITsZ6KEtmGW5x1/FgzXgGhEzxmEWBif66YA6I+tt5vNxvHHw0bTv6BQ0alpcqaADrNjHdlMvfXcI2TAa9bCgvmxQdwjcOkZPtqJA0ABKf5ZWGBu7l73tAeZys9EpcrP3u3lkZd7RjCDF2lGBleYyfBkNErHWwKMkt1VU9Ls+nI9kYPWPMcC3FlpLJYy5T/T0Vyew9FU1+cjIU2oCvGOpBq95HkssZrd7ts70TeIJ2CO6hoMxc0Ojq7WWWTabF1LFXPm9Ps/hoMVeEpV4a96gj1uYCpSs7rYy5SGFerUPCeGfwjww3fPkI9pnJHG+lWeXihuDEqNfckbqZWDL8CJrCHFKBXNnOLE7FYOqGUTibINyv4h//JlgMZ4A+MOhYUsrusJsgZITNR/5H8gDu3wIlGvVMC44fnvaWdS8QHQo0FC8PL+ec8sT59WvE8O4BKIV+3s4HZwKLgQwc/eVUWDIPQqrB4OZ+Hq5R5AzZoXTZeKDDjeKgc+AeGAEVkHcAzJf0QhWQLXuIFm3yyLrRQj57s55Eh44i6Wy+VgXxKL/sFO9B/lJpq3KOny+CTcFIVMoDazv9CpZ2IEl0BVKI6jKhsse4Z+AwJQ/Kz4QtT/jil2Ijitu9s83JW3x3VmZGRlFLVv4kK4micAyYwR/Lvj40OqR0QSOMSzZIvKRADEcNQDU/6p9E29i7sq/9qp+eyP5xKtNaNGK/oMVgAzqJBUQPblxA+Cg03qT/o1Dgjrf1s0GWaO0n4qWDd8+f5v8lTM5JeLW6mSTQfgpXhytLs1vB4NBykozIo68xd3p1YXiBFy1bi+CreEgpZCGSqjSEI8SiUJ/e7rmWMC2/vZxLZYsycrxBAqkm/I19jW4syI133Nfwv4uxfKsURjpOGh5MPrve4wi9CRcI2qU1/ypL4iRCUfqBwJrq+c4qCxh5VM++ghcLCARWdSxewddR/M64wkMxcx4tHB9Jh5XWJ6gLCHa8neEnZnkUiHDucdNePsd9BqHB0dHMXqaptHfaqTi3avn3Zl7vB+NxkMJ0rrnoiukr/8/WBf6+3l7e3Uf0QjGdxE4XLKT/VBE5Vh8ErO9D7kwDxEQbjOl+RhZRkcKMDTiGJ+Vq0WpZp59pSRVUaNK61wPtIQC+m5iAdl8eFhSNsshbSE0TH3EGZ0tO0Yeu+HdyRihwqupPI3JP/GVvaRtGmdAqjuQbUWyZvNqVF5Uhl1FTUG6jv6HOjglryZ+qg9uQIvRbgIxGXU60zk3LUer24z6clPl62bdJz1QBpwdPC+NThviXtNFO3sbbofUDKB6O+trPcPXYh/gxtCPYG6reGFZ/oOs5GmRUZagEUr0usT/iDG2GrG0Ej9xRiuy4wF8i9i9G1yBG7YRfpuyma5qgP7E1dDcBC10C9cCcFHVEK//J4cnHRn7oPfH6lKP/hu2Dr4Dv5swC+KzJ+enzFcboeSICoUUdsmzmzHUlSJR8nbj/uto8aH1ocXorMX61zJqihZZUteipKXuARyM8HCxeXWaLYOG0etnd29RhM8zIJ6YtXNd0zNYBLvGpvbrebu3xtqkj+/FFTnVU6lVVPp+UpOrZem1ougr/fbq62DnSaqY2bvTASXkIduOmleDaVveZUYVbr3lkxfBCmiIICh+QH9niWvXyev7K0kv6IcXsGLiYy6O/iSMb3PK/Lz8kv/+3P5feWFP8cX5eao4gXCNK/bn/vpIJiscr5XY6kqnosuVHgjKwimQU4MvkhZvjRPxoHCFxbWAzgE9p/QB4joVYBf0bF0+K75C6STyVll1rsEGmMXW32BU01DIWjOBWJVvCeaEzap2d7oXgCZDEOq3MQ1AXVDrCyhckdFYxUsJUUVXtVIWglDTVGNFbwOOQcr0hE4uhRdjc75AEPiBq9yG5gp4BYruQCjxBsdSEqwl2gLQnm9RrEyeX2cTy+8L+5+qSBhBabILjqgo+zZbU8ybWK/kfczPNEcLV6zSI1IvU8LHd9NIaEog++sqFcVFgLwcQdvYlS8FqoPqbjURMaTQz1RFMhs50Iw/cLuiDyUAmi1DIBWcX5Asl0MjltBibwjZYR/woKpeNSiGxAEiSv2vK8Syphea4XL8U/2t7pxq1+ycS/LbNxLqjS57q5edcf6RvMIt77SXuIEtIp8L7O9ZKFLwFX6GW4FVV4LGnUmn43AFBiDrQkJda8qLLa7KsQDnSHlJWph3+d3g9wJQdfildiZ9sWrolrz9t6tSGyZ7Y2KcWzH0nZ9d3ADbyaUYPu6fZnKC6wt9jGFB0Nfpt3uDMfj6WhSCQILyA6ht730Ju1LKu0LjuiYsHUCCGvysWin7IlbaBOxENJEL6yoCWCvaoPwN2pqxWLu/Z+KYlDqYHiyp0+R3ohedWyV4NILKUlw9z02scHTfhN/DcxGabRsYO27aBMimJBHGm/YH/+aZh5xeQiE9EIUXaUdhCfqIJ5o7VHvQ0oIz68piFo+qB4w89ltZ1fqyaMaOQv7hQqJiKuqkSAAdhjdNOuDeR0Y36vaVIzCVtY/iB/WYkXFFkfcpvVmIvB549ycVD9IHUDpR+cq7Xw6FI13emm/u5YIeiL1PwSu4Foh+pEFuj/fsgd59HzHQD/wlM3zkfUdRBU+RtxDnfgk9CnN9Sj1muxQ8WskDQOSuMTbbma7g2BsuyG0p1o4cwv36PSJSAf7LbvzyLf1BD14Ce708k098Y83qjvb8YGppMcbu6iDUFSEXaOABeEdo7QACUNYELsIZLX8LpRFnkjxZsmgGYaOwt+KsoL2J0snE3GNCtbtfDjst4hEyhMX0jAWpqFmxkh4CE4wqIWRQSwMGQukda2E3nxhJ4gZEYS70VLvNBPrhtiF6cgvU1wBE90hJ0CIk5Ra+OUszQA2AiUMbW5iDv4YM2zQUhfEX8DKk/M6cNBIMSyQr1VoAhwH2mUMaPUgRPlAEEKxqUp6jq+1J+4rJbRh+BFpKHs3STMvxqRdkLh2KgaRtb+TCr6YdvFFpk2GOIiD/4NkAisufxqu4a7Gu6E4EKNpJ13sDK/FbfVmI8jmSua2LOa2rfMigLjM9Or4b7k0zooguxPYd91KBzeLJrMCMPHVcHo5yVuDyex90URKTIITPYXs8yGyCsC91NU06hil0R4+sddKjjGo1vtITNpufNjdarT2D45bOwcn+9uwHcq116m49OEEJkA8kEAx1k0naQfQR2et9XsJY1kTOK+KUbaA74A5a72o6LndF0xtV5pxiSM6AVim4wriyK6m58RS7YtdtqW9q/FqclA0qZ9kf73sYAD+0749UVdKLUMbW+RKYYYhPuFgeK5iIYkeFv2AI6TmnTJv1i3cIXt2fqeYqGfUK181eENkw244043lRVX1p8hM2yqvaV2IfQmS3GeVnH4Bls8qeP6QmWxwMQyhJFmhI+3qnXZh4boTOxO11SF0303Pq7rfWtTXTTTOaOsWfArcC5CDPZTH/OulJ3937M4+VD5ViT3eWkTN/EcjNLF7RtDBo4puvbrj9bIm+s7PR7aPerrbk7ewPOMB9/n8P5CMIFMquw3WaEIxaATM+NlKeYS6eDelgnAOJvqOR5oZll6BZki3SH5MXi2J36tLkHZreWlJxnBT/VgTi5w0QvyepIvX4s/2ZVoS3saoAbWsU3OHAhL8CpiC3wCKcBomV6mJ6DAZgqoHuANMeSF4wXA6KTAOeZlq0TwhoB3xJhoTWyOt33oSobOSx9ADljLvDG7kZj9NR9XVJRfbNaiiEEYhKYQ5pgF9St0COGiCZj6fROK5ENj/DPffkeSggdPQgDd9YMkjmUIGQRn7/aautznoAreQeVOItm7fpMfDHfF8uQrTyyotnHhbXdyizIeynU5ZTZ/G+NKx7Zw9wmLsSZ0PF3GYBGCa0w7wyA4MfNKCkKydDNrnfYnAmscNWbj7cnwgppLdnrIFGqfAk0jxsKBZ/bsK5x2TE/9cvQCktMWApTWuAq9oBG8yKalnqqD0g7B9yrFq4UVtcTLcG95azyu4lxfP7wb5KlZR4QLnipUyII5vvXAZX0vyqGoJegAzfY4jLaUD9WREjllBMLJBcZ9s4M/RAYyIypPdkI3ZwhvT+Fy1slDJc1/3BmOFw97+6CA/nzxN6Lk43C2l1l6iQcrFDQIFwauLe2fN9LIiIYSM7jW63+TBVLmaTEZrz57d3t4uklGe7Rw9E/9cDwfPdBwyA6E9sebF0dXoFwUnKRj0eF1rU0zNFFmjBKIhUuAUDU8r8Dd2W0dwleVaCuaq8NGMqMRT2fmpi04AO71JkVpI8JXja2UICRknkwAmJMiR7pq/mb98oAq+C4izW5SYeYdW7z4VYy36VAiL/2ngrVc1eqLpaeWuO7RFBdeBlpIGO+83U/K6WM47dzS9NJ5e4Ws7s5oPUhgXv4BiICek3jTKpyROyhMjKJ4g0t+qGegSiNtq7JRAxdHvw1NlTz1V7MvYze+uMyF+qPoNBZ/x6yl0VZztNTXzW8p2/7vq/neIhtZ1WRaS3+ljzWaVg0qnv5/VclyRUKSofHg5MBVsVxzSkjrU4vLAUAwYJmMrkh+WW0w1PkDewmfELIJQJUaKoWTxGSt7tNDos57Rh+WJfhOLIUr2fSkeSZQG8OaGf6/efnFFkRFH0y5UwlH1ZMaHPh2jnCxwwNQv8TkUxpj7m31+QFvILDQeEydqKRaBIgGal8DiQAUXmeylDEpWkcbma5WchIULy3zyFC14R72+rKu5LCQvc6TAbDLEuG4kvpnLZTfTKpi0m3tJ1RIOYMM5Xdj+FvcOft3d2tzb33zfMKm6sKrCiw1Emm5uf2gcHe82G9ui2QnbXAb9N/EX0Rr8gN/SvaQRjQ8T0XiJVcogXfTr1W34kVllLD+ZbRNZXmG7PP2V3DsThJ4EC8FBgrTqysVxe4QI812bZBG7SutMnALe2+pZwG5UEJgeHsImEEOvuyZgX5fBBuGv+1nw4d8kPLiinr3sKG13Dwb9u5AvILlbsQWzl1M1I+HC40I/N1aVvK9yMpSjMHBYvQmvr82JIIkQl6qeoDhvxi6XRrmS5osVhA6VNc4fjRzum3Y/eLAsE3tIEhZt7bu8CHAlOvMjnPkdhlQup1NCs5fCO7fPxFnX7PA656aOIPN6o4wY0wkdZWWZKr7IAywvWLXlUQvvBJ87dtqTwF0vZJ01S+FBSGWG8eA0aVn4S9kQEk5Ilmwv7CDXdU22NAR78+jXk/eN/WPxbjbmnjKU3hoIJ1RvSkYetPAubTVNAQJt+Khnsh7jysXS5cEiuF23HTHco4eX3yg65fIJcZTyFl+MVj60ilDrC3bQJyjMLuqHCKiZDSSqmC0jWSaV+MuBrCWbjYfXSh/iWAV1z9ZI2pNQoYcSOdqxYbtI6wSPt9ntHg/5weQNx/GrKMcjs1j6wqsnD1y73808QIEmNH9QGBdepbX+gBmeIEQ5wIFQung0ciOhs9NUzzLSv9RPqZTZcLnzD5kZO3LiIhrUIsbJFUdYh/ccOlScxkwdyhwyoO+FqqwojXkxBcJHtje4GX6iq6viqDb3hXd6rItpGr7peaiEoeWJFB5Pl+1AbwXNoPbAgPxkAC4UP0GXPLhcTz2syZMYcfS50tzdE7dqxbv4poMv79nvEy41oNy9c9F1tS3+wvGFtREKsv4WFT6YczmV1isVAdJnFZvf3TLoKOxeTZm2QB09gNZyq9789HtatQJmKrXY2wMLUHQ30UdGDozYl0jIbmRcbiJpPKXmdx2+T5T2t8pdmdeRBwyWa8JjY/wu7Y/CZEgW2yAJoD0J3m0O+chCkZMuIMcHvb3r6KmNrg/dKoyOsMjHD6KaU5hlS8fjD82R9kXpOxugP5yQGZtEQDDJKnW3mogUaC8dYecvY2ziZjsPmZZxxsMcL9Oqy5TOJsMrdDfn/BdTLTdvXsTsL0IqLv6ARfh8TXRN+ewQwiHMYJnQInhxBnp+k9zxqvkDEBQoOwBisLyqir/SQ4g/cfCj+ACOK8OjbDlzIiOJS+g9LFkIU1Zz/KKpC4uzLKqbyVEK6V6G2+pdlEU0HlG2CvpSs5b25e1u18xHkU1TbqRPM/STNxFIM9M9SkfD8WQO05mhN0ryg3QzjneSctsnORFqnfBU3LMoHYwUmUIeGJQjDDoLY+h9nfvCPIqB0aWEHWqgvh66zOlAd9utRNUI5YBFpxdyBC6pzEM27M+wCaxizb05UBDHeU1r5omxIqugvWMSXMwld7W82zza/m3zqLG7bcQrBQrt3G0nTC0Tnblg32WN/2z8V9n4nZP9rePdg/2CjZemGvYwq7RaHgrg4D2uKpMvSk8a1dFK1BFyE0COdP9m6PSIe/YH7hU6/ONeOuj27zgFBg9yYP5Qoz/bSX749P6YE32029jf3vuI1S8PJebqha3j7PEBk5/44feYBK5+qMXycSD9GJBUi+z1y6r8/bGVGXyvyxkC+HWdTpoxEPArw+OLTxDhQ4gxCbdaU9EkiGiIg3MHERE9IYilnRq/W3Ijq4qpRu9Y7xCo5LWAasRLBZpV5UNRiRDHNkXYfW1Ryg+rID/MaUHkv3Z2ILjSM7vOWlKJ1rszrzF/llLK5aqVnSs5YbNN2oqn7JGzsWHufRnUpdbpgEofRGyRYOJ/jFqtKFJH4I8r53pq1iIDwFWm4la4EFjSDUylkD3yh8ZRU1xJrfe7zfebx1vv6kllf5hk086VlF9Kwal00jJ9Kwctl6ulogJyxw2bvKmF27DT+5x2Z9yLjcCW9z8wL4Y5kCzxEG+PUgtuqizVnag6uFzcMqN+u5NWn50+PXsm7q3Kf628raDP/7WyJD8/pR+X5ccn9OML+fH/ox9/kh9/oB9fyY9V+vFn+bFGP552ttS86t73ix31/Rn5/vy0vam+r3nfz9+q7+ved9PPL+T7qq1/6n3vbqvvZ75OwmqTzfYosyK6ETKyoP2KUgEWmTu0GHOHE4OUSgsEHgdZqjz7eHxj0MuoR3T2QSb8vz28VJ+CdHpx9HNN0s+TMRigOYXKQAszfvE/bJgPN8pt9PvFSpFlxJMw3ABjphSl8uslY2N7XZbNewDH28s7wTGpdQWkPzq6c45Pm0Z0q+oyATnwqwL4ua6XLhpFTVKl9HVomijAYYpv1FG1qPHcfdg1Y84ZgCoSUWWmHBZywLpO4mGOmbIhnzmVxRdsZYV1SWTSUjA7eDCdHFy8bQ/+s5UFW7n8p93K6Qg28rfe5OrQ+CbQAEQdUDCBy7ugMdYafev8G9ronDQ+6D5TPkA4DwD3bAjqKrNhWtW6VxQn8gEfSp3M5/CgKbBH7cfi1eS6XyFOFTpCkd6OwD9Cs6CoCvEL/de/SFFvkE3agw60ULZuDlqkh1jOEVSJmhXJKCD8QPJ8xcbxTiHTf8QkIjyFGqR1t9tvh927klhtqG5wQsCJjushPynDDMcLoeLjUonYE6EMnfg/AQPbzIAA1qLFG8Z6DfJ9SMX7F9JBQvK0JMQkWtp4g6MpUEqoq8pKso/cOQYpxUJfkVmJascaMaoxFCdadhxJ04adTwXRkORUcGzNtN++S7tb4o0RBPLPnZCJPq+GXGyN0gGE6/p/UwFUeTNEShSY0bB1PIei1CQ6s2g2HEi9x6dUETb4cD69uFAPPJkkEIUFUKnRS6X5wp3VwpBsJq+7HkWmJGclEcY32atfnDPVrEx7fpP5UNHBQxYTDNO2d4M/yjwgl+ejrBLJ6xEw4LTXsJdFyUAScofWODqDDNaNVkyuEmiiJI7wy4WCxMvU6cHQGk19nMBANMpQyMPFbNTvTaqVfxkOkXO/lo3i/teT65FOVoODTenpyKSTosYZ1pToNKKBjCIelSBAGQdTu0KbXj4FWYOCm0ZACwlPXOLymYZYz7rpx6BrMxj3BjKAuXKZk3YuMh58OlGbJs4Y3jNQHCgPQF1rkdWFPgWxk349iB58qQXy0VMqBO768ys5nLgdjrtZSG0VGH+DwqqZuhtZNjKh7V8nyy/i8stFRn6pgxRd9Ma31zJ+RZZMhsNk2O9SWWVUuqrs824drA0Xj6CvhPxkD+S0axEHR5PulPS77oW6piWOEZJhqVyhDlBFPA85X0psoWsDVhVJs/OiWOVFq/5iQRI4bD5aEjE/39oGieL29qT5MVc1prWX5abHhJP2HnScBzxxHQ3a5TrPY3fS0Oa8Gupc57ZfqOs/T363mMJ5vZyoEMeAo3x2BGISHoJ5LGlroDoqDyC8St02UEXzeTLzDvmXi57vqSeGfk4E9EUr0XnjmjkFQkWiDWz97pzXkemIAw3UJeYq4q4hSo1Ht8raiKn99DI4oxu31u5wovLXBwtByKbq0PAeMwJfdu8iX6gua9FteJACdCN+Bh5pF6ilSQmQ/0nBPWPvFdVHa3jRcga5xFC3RQ11Gess76xjOo59cXh7zm1pfT2CeCFzMueNnPkSR3zORnxlTbW+7jF3NkUUYVrGBHC70dw62j08PjjCbtF090w4Dp4BMaWhP7RtJ0PnEY4VRfhwmQ8E35obAyAW+aTQ0zvWsHphnZNNFzpXkvu9GIdUPBILah4aRpdqFppolmvG2O7FGt7X3LJBXF/FQX7+eQ9iBBn6572JXK4C/wiikg7Eu87V9kMBKWKDPQyyKdiWoe9MFlkTGUjTssOjg+2TreNYXCCaed22ajaOdgXSnLx/2zjimumxpP2dN5KDNNPA5mj3Wx019hqbTXaKQX53R6d3j94DTuQ0HkHEyAyE1E2XMMKODe/e5nFj/7jZOD4Wm9nkuuhPr3uDYSauWNR07+T97v5Bc/f4I9fE5rY21d82NrfEA5upOh2BDw6qenJ4vMvv1TQ731IhRXH15tutk6MjsQauiYpiK1lOUP2idkeNtwcHx1sHJ/vH2we/8VPLwO99TAZrHH3YPCqMEGVR3Q871B9emjpcUKLh4GLrqj24THMqKdjGKzAIXxjqiUP3wkYBvvstTnb3j8P6HrIWNIqgePHkQtTeO9jcbmx7IbmYes3ND7Lacn619wfbuzu7suZKfk035wXcZ3iECmChD9HBzo63CFOw782anjp/fHrQ/LH3Dgg8w2NWMNnI+fJb0Ube+cqvTIOQqSNXWY/otOgzzrJDslIBP+SyS5guVauAvSZjl9UO6de8/5K2ZuMoaUaTjaHlhZC7xnDwLMVjL2D6Fv83iFtGHUdVtFCFIMTLU5N1/RbxPUdxvq30phrXl/6pcesJg1ylElmcyvyaclYCVc5MDouhlAHnGOx2VbRvx8LLeMqq06P0QrxPrnxYYntKA226AuArn5CcIox4KxCq7YQjM2lqvqaEyzwUjGPJjGDgcmP5O7jubYbszht3nZ3Ubtc+ZGQGxi+dnlFQReYSDMfPSkq7v+a8mAH5mb0V3PhXn11kUH6G0vXta86OGZCfmYpv8zWnxo1YPuhh4YSgAgoMFbOoLudzg5YAiQjwnHzJjtQi3wRReS65GH1Ue+Fa6mn/4l53jNBkzTZ4QCBEOzv5gl+MtFl/ELiJbSavxMgzYbjotyfiffwXsbimlDy40EKw4M7wetT3kRMUz91S9hq4C8+RgDXYMPjZkk4BvYEZjPoG0VrSXDIdwzWXoYxlYE7UG7hIY6R7MwHd/Snp8SwIRg/V7ZRoJ37mMFn1RocfpVVPbTdnNHUYbmOwUdz42hzIK60Ihi/tTCo0oZi/WpziW65cbDOekHG6sG4ZrcANQ42J8gvBGpTZDPSW58sasT71LEMU/LgAVtNzxbYwkfhpTj0vjNV03PciY2lyafLN+STm9CyQhDNJB8U3NZyhsZwVjp9+jjfIsV351SEpgs50t2iDmCVMdj7BFKtObF6cjQ39BaNEkFGvFWSbI7nm/EQbT6ADYDv9rvMg1zTPNsjVprjMt3cfu59Pl87Wce66plVo0kR5hWNE7Lz0m65HH06CHmaeomI4nEwD8EO9U9XFWTRDo1RLqOboeVJmJ6yxmZcxJz9DBQr+3waZ37vp+WMfBmpRxR2Gh+M9OUbfAu6Xg86MCL9RgPCsTZttzqiUyBbP07MjN3L5Az12QgjOaEos90a3KQc7Yx7MnWrswgkJMpqT4UgMKthNlCIE5feW4hFZ86GcMcvhKj2pCjO75+Tj1UBiXptblHekKgpiqFM1Uomg7BhBgt48/VKJ7qxqKTYzKcor35FWG8V6c1qlEl16qqigz1BVVWaegYoqnCunxSoTfN+qrsLY+1irVaIrpXYJurGarhJdKFVX0IXVgJXpwqrAwm6wdqxEV55qLOgvVJ2Vmp9UmTGTM6q0sgkJ1EMxdsbZDEHm2PLh5TWtWp8pEEMucTPBm2UlTeAYW3FEfg/xJP2kpI8Vv75IER6PXI9gul7IpUWD7v6pdoDXoXylLYhbFcT3AIO1eBPsFfGnPwMwxT/mBPgGGoX4b6zFSgDeZv6dLcHFI0R/KQQDazRSCAu9wGKABDmUv6WUH2Xsa+Kg8pZeAnkC9uabBFeROVEOcgUAKM6SwgDtEROlMExqbsYbx15+k1sZM+/KSZxkF1wib5IDziNuGWL+c7dKsfBfdGGW27M5X6Rv9by/8i3KmfLF0UIBtxgl9CY8IjroB1wuKqin2Dd5Yjmzyfi2qIUW30zuUfltAiViHJoDGLvgYuB4L+RvEkK5ZrBxMHlLLz7fPqwe8aD7go38E68EE98odjPWyHmoLZdavFcGJo+4R0ZOlJ9vTq0znm0OfoCn5eCd9eiRWX6G3dFQb6Et1rpfnQBI1tCfkIke9Y2C7dM1n+iq2p98IfkJiZS9IXjLyuLceNqCte46nCEnnAaVSo7ndxBNCxcOOWOSPN9LrCBF3r/ThgUJ/eaxfyYZzqPu3//FzH7O+eg/ef08mDw0q59G2T8sp592B1vMWX+5RMdIzL056B6lN73MTxcGVQZWDG6+jFNkI3MhYOiqmAahPnkU6gB0X9G6VobmkNY0eZMs11D4cDUFiHZjxodIy2PxaJTxcNU1vXgBNOyqPYZQUNWXL0SB7o4/j0y3DGDx+hE/0b5Jj4c7/Tay+uZzHzLyHD+rg1iHOGpAgR/Y4VLQIbCK1SztvE0vhiCxg9/53fqcrN+YjiAAfnmZjne0SFBRsi8bcCF/RF+XXzXqe6K555izqA0A6YC/RbDinrtDsAXGLDniZSAkaztSxsgixyj+PuqJR2+FHKhYYAT34HpxOnULIT4Ci6vAw1jwGxe9S+ogGAC71B2tHxBxz5iSV3TJfmI3NOvvSLci98pjAcJEJwqHmeHOC1tXScDAB951HWbu7JWXAwaDGG+JS+g3jRKBd+sM6OCBQXXVFI8VhhHyxpkBH2hLvRw81hciBu1/VpTQ903uySiv4KisVHLpmniEdD6Zu62q4qIOB/078aSJEX8lRkCKMR2hr0WkLl4niWkSGsq1J8Ne1c9l7OseeYx1fS5hRJzletITt5U/0ot+cYsAyNwdClB6eOyFpnpz71sZ/mOtUvMUxCVyJOiu2BjEDtgoWbWcr5lp47PeTOm7l7eVGdHXzQK6zFlyebUFvjo9KGYD1Dfzpi+CyUGrcXR0cCTzRbTP+zJNxKU2De2kdvyKPV1oRhH7fb0hpfq79+Ly+bhBIupQzDBdGfjnbVUVh9kMubrYvlryS5kUAnqy7Xibjd/ROq8wy9IRyidNXk29SXqNjn1rYp2DVbTSdT6P+UWvn7ZMgBfvE7jaoC5Tgd3hZ0hKHK4B+ugLoocs6k0f3mceWV1CCMiqvgggqZRGWGPnRmalkAbPVoz4g0BhmSEjq6yd/qAJj5tjNJF7Vq0ci2rpuC1GskIysTusI0dPeg/obqkM+0EkVzxNf06f46vPS0Bvxjrt9c6kJ06WDjLlPV5xJoIKR8IjabPJx1LR16iLkelHTOCo0WztH2/J2PLe573d/cbmkedapAzJ0WyN/8Pycp1+t9LG5WU0vJpAaHCOeq8sV3D9e/Q3wego/kn8kBj4y6h9mUofpl43mATpzEz3DQ1xK+uKiuCcL3DlafLDPysXvW5lrfJDuGs/AJcgEX/tBxvyK9gkMqwMQ3b/PwOy4gDpyc+niHCY/2k8rkcAd8+wTPlD/HBWF5MCmoDOmafCuWpnNpaXrookezqkML9DsrbaofZGtzf+/mKjUvODDvOkgrhs+up+RMSsaYEXeBrFWPbPf0ABTHd4dC38CbuHwOCRq9L0A3hSEzgyQA6oNgW9+IaQEASvT6rOpRFe3tMRsLKatFIsJTdADOxcnibpEUCOhu2KpzNX6WfAYjIgPVrecZGLVedFC+HkOYG2+rMbEcrEafgB9zfbWWBOwn2BLjDYrh/+KQlz7ik2U4AD7E2pcnbvvRQCDhO24/gqHV8LpBiOG0CvpGYPdBawvfKLp3aYEm+3gC3oTMdj+gvuO/dleIG5kt4/NKvh3UNqElIJJE9nZ3h93R50N/5eCaVB5IZRxXaasdMXgbhbs+5IzNY9RWC2ylpedE5yptxeCdQRL6QLmfc2eS2rIuWWgIJteCpqWZ8vAx9SCn3YGiUBcw2FchwT95uCvhBkZq1q/JWZknCBRFRedpZPZZFH8Use8jjWCFl3Wa7SNvnSjfQoquq3RpJ8qll41mAokr5qA7SznsjL10KOb82ElHcVbVtM4QrGxLxs7i2IhomouGIHX7Wqy1nlSTjycQG9WDYH3R24ZBGhQm5q1kwlfL1IGIht9b7IG9v7JoGEMWokn4Tuy2V/eN7u2/eQqeBOtmYSimisqwwzi++ayrcgaTd6erh2bBxUT8OAX33eBO7dNEwmw/yJ6IcKdlis4uaeMtSbSXiyWzg3YBCm2599zhEFcOBcI6W5OvNSxNTEe/X6T12ftCSJdqEqwRoK6nHdnlRwwq440CNYBF0D0zVOs2hHDMlwAiOzc7INhFz4VKkVZAf3hS5qHclFWywOkiaQ8sBo1R24QgzTG7SO+N8HUm01oGMFGVY4y+OD6fRkdU0+fW7Xb8kAX3KlrkU+rcZjSa4ypyUzFiG5jhfnHqiIgNk/nzq3v0Co6l//Ov3WAEU7tnuh+Gq5HXJGtXwG1pJWepC+gAY8qbrlwYurRDZah+AyiF3SnQJEJa4kaq0RXCd3Grkl3IXmX6y7XXyFdUAFjKRlWJClORpZhYKHCf2V6PAFmJ+ESAayNWJUfHd4FLmrRwjFhRJu0CmzWT6QmTqECHSoRG0JQDwZD/8Noi3xt8zfUA4+VM5Ig2jMF2ZaWsV0JqN2eXAzwidvNSRqRmwDkKLJO4E5k7Dhw3re+c+byiyT8Y9u/kYXxWLiQjDhozlDACdPc9Xu984/gM5LHLXOqD1uX2dEX6o+SYq4VA85qOd+IAjdwOluoNGbwK8vqJZANVbY8zy6v77v9T0/F0XOQcpJVhMuZjm2GJs+aQX1QmPhs+HilyL6Nlm4wgVGlPvRFP9Nq9NBb9JS94WTCOO9sRXkelSOUO9be5plzPffmLWnwVbSNlsVuoNuTuF1afp8yfnkcFJ0vMDXyav8vmJosLQUQwS6kmsGIt30koHJEnNUl5kDdHBxIW5fN0x8l/4rOXrHDH993h4zn/ufK1GcwnN6vvLTy5+YeW0NB2ApVpUIW5fiiXQwgatVWgnWk1wcU3noRMsP6ZgID/zfEl/JFwWQddqNV01+8yuaHGenft4z4F+873KJOusB/t7bggKu8jFVsyHL6/bnppWLyasR/BuQ9u5wKIhpRuf0wSiADZDoVUNIq6xi5CISgjmV/X1y7SQImZZ5FMM2VrBmWgfoi5ZlRqTbjPZOleF91JH5YI2vk+dBxD659o1kBR/yEqntIkAhee5Ol86g6+XnL1+CEF19W1bfVlaXlnyW3sJzeZ1+t0tbymXwUQ9mrFhHZn4Mf+D3S+G07Cnh4FryQOEuOI62BoADY9lA04WWslRek2SPoFXYmNb2vLlP0l7XHJUAM9whmh038On6AoQgCE9QguJ7PlKQXji0oJ3FEYNJ4Ci4jOduIStnoc5SU7IEKj4V/MqPBhKi8n/BvvuqUNPgTYJH8tHDdYtrxXS1wOo+x4XooaB78gdwmCT5azXn3lmNKjs9HjqKotyRwgjmHSp8w8hqJt1qvUL1Y1QwYpv5i1EwkgvhTqRtJ5WCtSgUzaTd+bZIzR1hgnhLeb1SnFIaR9T1Unz3lylSLTFINQtalUEsOn2FA8u0QjF6lUWwCIrROdznHX8f1QJgStZCIVqW7vSH7UlAv2ycSVmV2ZBgOUvBOmat8B6yDI/FK75bfbm6+nw1eaZmWitqKGvXSkGLeRFbPMWyBO9WqXEnWSF6ABvbVuwtpBgnvxcw7a2JFfp8aWRPvU7Dm6h33e4fD7eH03PBhiFI4oacbIBBN9bDx7K07CUokci/BfEFjGakeoKD+wzefEQM45rAPUMAi3tzfy+IWpw8a5nZVDUws6MeOukJ9vwJxkHlM50weU/aELAp3rnUZFbKOKLvTFOp+nwJdL0GCrXFyVD7/XqTRTS4JHar6Ypq38MVxRx8Mwf1r9Q7E0If4i7TJokaWflVI6gsLgCxNXqD2OWzdPT+u+iU6pV8/Ce7S25v/TQzeIl3+Zm4qt68wdtgxtWNZtw5uPh0y3DTHAPN0Hz9XGQOsCQZgnQoGlKGdkR22Q3h7ZSd2FP/oVa8/2JfKBboUR6w6SxPxh3MFwxTTmkY4N6PmLQ/B9Lufi6fAW13v1do8dIZP/37uO5dTsJztpiM7xqf046054jGzBkObHSRLNkIdPiJrIHSVSF3iwLjEc6tQne2FETnld+pnThx7JDp35v9NB1V4VW0znp8sBYsvHdHoJzyknbPEvo6qpn3AjIMx+leOzBiHva7SuUH4nH6uZsxRs+yPugWY99bAlOZspt2HxStXkm7M5m2+83A4nqQ3vLDQwE3vP3ODA9l/PAdG05A2gL9L/kJJ44VhqEgBdn0nOAz+TGQE0Lt6E9BbGiih3Vq0hYxZptgyzVYmjy42KreSLZQB0ZyRVreYAcNsUf+b7/ntN25glcZPr7afwutCihQ/pGeSNuycoYtqC5j1XA9Ck1anlRlG89+pNhnQ7QiGlgFEGQCqyCGPpCjg2cZqqe8VZHTFTNIIN3zJmOuH7dSs0tsz1qvHwGB644+vOEkgHmp7tl7g8pjg4ut3sczXFYVX4vntHipqz49VqCEw1Jld3ADMXAYvxxqCeY3DSxJNBWx03bJCuREa8H65L/o7jbJS/weZMW6WuGC15klk4qZl3+GhUDEUAXDCON6mqCpWmEUA3JREiJb2jWFu7ki9+BDR/iObZxzjmjdmj2YxaeJbekdJ9fRXI6T6+4/x+mRjpO99rnjRHiCnOOE+IPYceJtOtzo/kt1YMBhq6CkGnr/B7iplUoo4Ogyu/XP6NZ3inbez3J076yCXe9uhzoYpnoKHW97gEMJ2nbw1pBeLGsAB2dM493IWZBkVGjquKG17/F15K4SBOGRM9sI0w7MqVsUTH9ePaoI/3PqjXHJnlPP7e51b3DYzjJ41s4PnOl43n36sfzmtn4Ss2luGzZM54xQ47Td7Q3SbG473xttdrvjOXYoCMYgnbxvZ5/mtubhdJKO59Vbvzf49P8EhwBhgOe15Kw3NwTvXLUHg7Q/t6mlnel4jku9FpjSvpzbAcl6l4N2f65nTmv5H6PPo/bto3Q7VdlH50Z1pqI63DvzOzPtbAIdHgKhSLvz7lZf4935sQf9NJN3xNx6HKdpc9TuzG3rJ2LZJ8dbcyORk848GY3poPd5nv3Bh3n2N57zQQREfJ9dzm25ab99l3YP534Ox5/nitWT+XZ3nV3Otb/x5/dz7nEyjx5LtURSRPTqJAkXf6fqNSlPDbvRr9DfxSvQiZS0jgjc42WzUAlHnsRSWb9BpU6nv59Be/xsJXVEeWAZp2eIX3lWTqXWigRWooPQjuNJ1YBlQzeqhRYdsRdlnkWFAufvEY1b0TaalMPqVgZhuArrfQjaLs//ycrLSdAE6S3tTJa9Emwi7hVZwb7CFJINLcCRKJY8CE8eD1PycIVCMA9hqLUTs79eXBSpQQCRA8SOgc2ofDEofcFPPii1PsJBalbIYAzCZGOukGGj6nwb8CHnaI4AsrTaNwg3fgMWZeseOY95DhC6EERRcCEUTGpxm2ecjU+Co+ibSMfngWqZKOJ961btuIuVdLBZup+cHANOwYd1oCXs/7542fqC8FeCZCHZsD8FOl1hJmzU4ErS64OEtRyZCahzAGscsLMYDgaudJ6yA8ECqUnzlopaSIUGyfj90AVzS73nnfgheP1YRbQviCHT7soID8fDd8fHhzauJbz/sPeR8gUdTGwSF/0jqr/6749bb59WdFQe5AgiRfKqbW4MNwkDiDXcPDk8PDg6bmzPFNIENE5X7XEXRNxe5saHhk22weVkEy+/gRvZggDIMwYhEx46rBuuoiegtdKtlumlououjgaXFS5/mkDGvaEXhXCmTe2L1ouTzxMvLlHEPEH3VvNjFl1WIcVDzoK0f7sbrh41RICOmKWKM6JSfWc5gKMVvbT2Xjj7NkiZ3k3PC7qz9XJ7m477Bf3QHOymh4FYrc4Q4BksDfs3TDw/XWDd33XwZYEH2T6KHSBTi7jTqVstWhMrQ5IWDUmiJxWC/GJbmc/i5N2iRPE4//q+KH3njmUwITO2+Hfan6BJoW51WOHYJPx8k0xGFRwl1HYcJssZZxy08QIlVPTSZH20NpNIZL6LqJaZL02jEps8lH3dyfvpXfy13K9/l5NZOWFj1bsmXCbgojZB+lq/wckuqO/z07zmt4kkPC2cWZj4c+9gc7uxrd4YOdWamx9kreXcWu8Ptnd3dmXFldyKbr4LqMcwmWU+FHSGw4OdHTp/832fTpgmRPTGpmn5/HH3DjAYw2x1+fOM5G7zG5E2Xs4wtu5Ne5x8bMrHDdgLAMWDIGbpoJu5rDzyoIpbM5MGPMNxVZEonPpJpmfB39dRoHd4R8HoapzFk/1dL0efprdIvYOqaziJ6icNrll/eCuYWr/V3sFvjWa80VXv8opp9W7313d5zTxtUTjLo83fciZ6uTNO/3eaDjp3ZKa/7hw1/t9JY3/rI9dsnI6GkAklbHnUAA40t3G7eyOwAU90c/uDOGP86jzxGF6eqPv2aPN492D/cPNo8z0/UfNoI3NsHuydQDuuiXpWy1j6qE2zsd88OGoebx6z0ySpgyzuOjqvXzy967R7JGFXWHc0Tm+OXX0nLtF5m+TK/K9Dz1VWr4j6JmpONe2kn0f+V1Fzcsd9FdwaMnK2n8ftW/ZzeuF/httTlFx1++Fi8emLEXtbmTt7fqPtg5O3ew3UiDl6hW24g1fYKHLmSkwwPHGFoIgctsJ29ry9f9/Y3hUo7W24KRdX3O7Bdmvzw6/IVYKpIO43dTdGK2z+zbkm0ymQa8uBMXK2S4DEP9uFoGeONnsvIQw3XDhInNQJruA4QtLF1Mb6ldnJ7KV025PGr/i1C754WSr1oJPKmmdmqS8qIqn3A/Co5sQUwe/Gu8iQVw+IIp8lL1cXV5+/rCnfsqKR0PUWDESvvi8bB9+IwUDedfllI/kmFxHwoUv2SyHo7l0GhORSLrH13n0c9Bje1yU61fd00Jm7v8sgpa/eCiAbXvClFmyFseFa0ZX/ZbuEWIFgGMom5EyZSOFUysAYjWDEH+L0f1vJgaMMdU5mYLHI4nTXmIJ9kyCJPxo40GAhX3s06t9tuYNSZYkSlUtJsXnOyFiK7LYCA3k9mBP890fCgGKPLHTWIJKrOGJczbizIbo5HpD7GY2u9Ws/JhAi4WWtRD5ofKHl5uvGc/wWcTD6BI2fTnyhP97m49v8a+8+YTNyt5/M8lvc/7gwIY4AhNF6HAxA9N1Qs2+ZxPMSlziEvaUXwwpziN8oHYoJmPIIkVt0mdsEgWh2gkKMIPKvDsTJ5xIPjwn/JvctV7wX3zpv6cW758PqETfQfzvl7qF++3yTe8dKWeN7ppdavFcGJo+4R+Ypmrs3/kvy27xBcoXaOVeIt/jibQvA9Yj7F0gBohupDr95wX9tThCJFQpIuZ3ht0nFeQVIHgE3Cy5mTpBk5JuETlTVEwcPWnIMPtb0YNBV41SxrlKGRjnXEWDEHyCANqrOxRY02hkPr5WRmpE4E62mzFoM7fxM0qozmQBWjwtgIG0TPNZmt3s85AaqQ1dcMgk9b3aRvhnDA9fsd/OlIECTmTcIaGr0D1gvGGRG1zF51sunSXeTVFl8Sf+z5Ekv21EsUTqv8KTZ0rkVSQcZd3Z72cGg3xuk+HjfoIBtnqc0zQ6kPTsqlVjqL52YnW4CNvItTmge62LKJHXnYDJDZnemud6EGxJ4+4GJ3Un3bF53iihKVJ2z/vVi4Ekh9/hd2gdLDBLffpj13G2iQ8GTMFlsNPmeeCLjX+kFihBFyi5smafYJmpGqxqnX5W+O4itjbXeOYXpRVDocARpJ96E+cOtVh9H3bOSFNeWP9peH8vpi/XvopqR5XThhR+vLqaRoWHO2XKc1oM3JeAzKcSHzU1lUiYuK99tbZ2fpReglQSwJJOE6l6E0KD8dfLxYOv4oCW5+dbxx8NG62DHM8iP4CUHKmqVH5pThMajSFnwrj3o9tMxmaAXs/1J1e/TkK25TPmeQHwYhHOnRxHp5RRNsJvjxbTJPauJJTFMXFxb9FoPERJS3S0OjWta4djVaBD7ZxApt4ByFNCOcitRuVjD1QBVdNhtl7DuV5D/eEpRoKFhW5Ky1VaS/3jtyaolJGGUGldBrFtXSC8KwbvyBTGbVeKCAtIg86VjlIMgtCyOhAfBPwYzIj/9bI20lhlcsBQrhhNvuLBdtkvy80ebdCcG9oUQq0Mw+TkkYjdBEZh8qrxyRuAyJ+IXku0NL7y/JUC42npeZF2/v5UwT0TYIwA3P7mFbbYaJ6+2jslAgVkqmx0AqryJRwXPJ7n35Ujv3Mjd81nJXa+I3PXK0DTmCogQLlSBEK6Q9BUEr5cD5JLGwg7EBGYmnTnMey9Tb5CjtN11ygrJLhQ84PwsipjX06wGNZ9hc18Gzb1kjlToBAk894aXl947oy8/oVfGsDtdZ93b4Df4V6hfUC90dbvWLi6sQxwURh3iVOY2VZ81YQyW70xk1eq1JwpyqXNL1p7VarEgRtm2RdKlxP2sWhcSO5ADEZLCTtrjyTYPUivGC+1USEjOZ25+z8bi7h13e4PLX+xfG8s0uu44xZlRZkuFOh20xRFIJkM1cZmCVi2rTDLUnATfk+HokaGw9DhQGI7mBgQl74b5phKRqhLGYJpeT9JBF/7AgAE5Wa9LwlEb6y5VFB4rlMnTZU3rTcKKyhqOYK+U6sG0mqkVWclh6qqTesJMl5fVHYfW+azETpEuQwO05AuG/gI5HjO2FMKp/h8gzyvqMCbXy3NRoNK9XHkZB8uI1Cw+4gyys2gn85SgMYMUytHybljz/khBzq3yW1RNrKkM9E8X6s+4+sunREYXhkGTDuDdg3jivJFiNK20Ji+uGgKSWHIWxt/XlAVMoq2aI2nLmKwgj6U5guLtxofdrYb0w985ONnfjmXL8QRFgQwQEXfi0y8oPAKfSo2RCrKVJTrV/XUvuwa0XkwOZYC7ZDq6HLe7aXI3nI4T2VKcH3GuTDzbRRf9t1wkgQfshxcdAvPF6HKzHSNOV1VCESHu8zsU7C+6LS/4DtOLoMPCC3C2ExRLSTIY4dzg3c86xvgIrjkfsMiTWJQ/2Qjgm4MzObG4Ozz6VDNIBGewp8YjBedwc0+myYamqCxVeGnv1z6d3PyLz6YTeqv5/smOqwddRbZDOwhWFm3Yzu7nMAa5+PYaUNO3EYf/muRE4TAWi09FBzpXlXa0qOU1M7jNNLOyCzlL+G9hHnd9ZgOTeTM7zICMrTtPeVv5kib9EZxiD8mY2H2WuSkeMI0yMv4Zu8VvEtevhWqdyLjqRGhSJzdBnZJxbyuV4BZxlFVgxARbD2laulO1v0CCoQzTX5Rb5/xOqrhRFuzhLdIWXvcGRHvYvrkkv6/bn8nvDEQuSHnZ7VHto31zoCw36u1BxiQzEmOS32LMD9g2wKyUinXtSPAGMWBJFixc2DcDacR5G+Nd1hPH/ef7KZOVSsGHG24jNnfS6B45skCnVgq/kay65rCFWDSuNg1LEvWu40+xNIlkIHyJuD5UFRJU0w6p/3iqJvUjxTc0WV28svqyML+izkloxv8+WV55Ja87IlH2Z7CAMNv1pHDL1SKKmoDU+GPYCgzxIFJqO4xPElTBFxGEiMxbHiK1MARvdXa8z4F9w7nK6QW5dTWiQY7q7xN37zwYxVY8FNOD6Zy/fzaEQ8DQfyw8JjbGIP/mTbKSC35FZpnstfMCrx1A//EVwauuIAw6fKnkAu3F/12gyXsZHwcKtFy6Z2mHBv0zz/RAF6ohvlmKidbpj6EK5jOGAVcwhiyYO+W/D2TA78UbajpOGel0PTELNUBVk6rhkA2KyRRfq7esdaaSq92uf1di/0vu/g0LsJs5QIuBkV4IXe7mzWW1m7fe7r/FgiF2mpYG/ycWYFEkOv3240y4y8cCZKBdOhagtrie7yKqZeY7h1iAjzL5MrEAmbAL0bB5Oc/7WLCcHP/xoiazhFEq8KMtnl35IEoFHo1FzSIhlPxiP4JSpNwGUIqVm/hJEV8+E/WvwImsGBZlgyfl+MrEY/rpK9oG9fND+F2A3W5LXuD1RP0QV7j501zi6pe5ynWZutD1idUSW2kK4NlnpzLYO/lk2SPy1TJmtK5hc2h8NT0Smn84pl0POzZeIjsNvGp2RhgQhsSpXKKaHzo53vIj6aLp4yaab4o20Isw1dWskcc+qezWZOq3b9Jx+zLNaeOWaceQ64qOkbvqVjvbxr5oiGuU35EsGu+nEkTXeMDM3CcgAenxXh8KZ1/yeMEuvcxfnoWQIbbi7tjfbvyNC2+o80d5DSG0KMCCjbuoDVy8JkeNrYOjbUF02MCQ08mwqc8SbrR5cnwgSMwRG6HzPG0LyGyPezfyrYjbqcio20e7HxpspMcp5Jbz2pw0N3/lA1FClPh3PQhVf+cDcK+xefRut3l8cPSxMDgk2W8vDmJkJ/gwrLaVtw18kFcUIM/sgA0wy5XtexH/XNFhYx/+9QL+BRvrO9W4TQzHRWX+uMHe+/2STQ67psV+7xyG+AMQjCjYCoIJO5t7TT+yIqkgNrrhTYhDpdA9CYcf3KZWgF8YgtDPERiLg+coSYlgbSb7nN+ZoyqlIr5pisIEfHO0pkxYO0NlwsB2iP6U6AhTnqAvjyyV6E5SozD8o6ZRZULtIQoVbhwlX48Vr87Dj2/L/7vsnVgcyEcvv9hXfuLxWd8anFgWIA4fvdzi4BQGLo8Yk8JQpYJAD5q2fLM7FOG48kI96CWXidJjoPOo8XkM4c+PzGOI9ze7UxE2NydCj1lyiRg9FjqPGaXH3qy5O4Wvxm92s+Jvi/h+4YUXbxkB0yPuGmFjcjdO8iLf7I4xL7uckLSw1BIxCxFX9e3yOtHnaw6jgxZeItQUBtNjhpnCHDCDyig8DXLreXAcHvT0mjkQDRq/fDyeYMAZY/K49o8Vl2dOICkfn+dBIPm/GKOHyhn/E6eHgctDY/UgxP224/VcDMfiVtvs96VD3WSctq/zkgIGpH25xjvmNtNJXj9StOAqRvMpwmUF+VwrfhpDrwOog49vN+uLCXqhhKC2WADxo0JVbBtrrgC9tuRLYzxu36lB7I1V5PeiunP7r0fHpM84MNpdVnDQNReVAKaqOiJ5UsfGzUVXreUbyIP2OO7U+h+LiEAfH3WmfohlRATypa0j0H33OIuqlp3/HKwlHn0xZSwniqV+kTR4cTFYJM8eK5Vxaf74YpPtjy0luphcqY+xEGDlDewcQqVMrrCCGYBXzcRrMMPkKGiib7vi7YqpaaJ1nKam6OGkJ6dyGN4J9vK6MbiJWjwQi4Vetj/spn9pgjLfxb6QRVftrNncPsQlcDCng08DcUHacRpAaDmd9MehGE6VVk4G2Sjt9C56aTcZi9cm+F+kg5veeDi4TgeTuvI/G42Hv6edSZJdDaf9rrjCOv1pN03akwSc1cQDYdARzXqTK8E33UHvLUH8WgOxgN8zcFpz364m132XYvlqOPx0MriSYXm6RymMAReK+jB28BgPb9XSI2tEavnf0vPmsPMplTmHBZev6fB03N8dXAwf1OW7yWQ0v97sBA1DxnZdT26zB08W9+z1KrZueC2e0e/TDIQadQghIpj1ozQbCUxMHzQkIOP79qAN94VZyOwdOb9wSHwu86g/tBPDJ8qOxNJn7UdbY7TQ4cCnV8WONR+gkTzgv6aDdNzrCKBHT3gEe2Q+A3GOGpY12gg8kIN67zNQcVYGw0RyVBVUaTCc9C6UtTxWN0PTQ7H3TekVRsvg4A+nk91uaIcAlEj099tw/EmpVX161E1v4P0ppVmSbcYdqxA1b+8+SqdNkgRSkKTx3Xbab4MOcnnVX8ChjDxFlN3y+5Zgue8ObuTTtYKXDfo21QhP4LqXZWre/7zHk+5lYmcGQHHYRYmhzu8GB6N0cKxAEwJGVTkWkxlJWPtJO0FXoUYYyk64xJ4XwAVtjsc98SozxxZY3PE0paZh7CJa49vNTkccZabnq+n5Zrebdpm1yRMK7Jj4B33WeCkK9F/EzMAtRSGofS1qp+feYNISmAilEGZlDD8EjkoJjADFJDDJ8zEedZCD8K7n9dD0S74JZpgPtpEQb6UtssaqgOBE/EtnHcBB18JdiedeJ1VSGnqpByclKvPF3YnHrsxHkU2q1+nkatitJ6Kjk3FfreV82L3DDPe1IgxHqslaAo7Wqh34XcufqjkRxpFuEtnJU9FLIgnxBjQylRYvQOcPfdUqoZiJyDBELx5pnogpwbV0nWmKUwfyBfXQCu7EcmnIEbP+yq+N40o9qTyDYEoqAJcSAtQl/teTJfR0gG7C52YoB1cTWFRwc40silkkox0GPtX03PmSQEUNe5eDdl8AQKNaaoMclQ1CxXSAMSyfbCH9A0XjJyRUI5a5yP1MB2CqqzB6O73pdVJAY3EtHE0HA6kPX481bbW7XdhwIswIKJSjd/cI8TWybF62e4M9MTTDIj/oYoqCYQMc6r7/PontJF6XADHoocX8slNMPuHfMxIDKjgaSrJWDBU2Zl7kbgmDg40jMQTQtftaXLvp8xoeH5X+aI36bNsAvdyw8q0/vC0iavZdL6q+2UiKeuUCAFIvVOjoaTD3NyV6DpmQyBFagIVx0uf4PZ+lE926KpB2442HQvmsQQBwzWMEkyelVV8iXPdXSJVmYehEgXr+GSdyKVEuSlgJnGpR9Q+CMTxGonPViYpaOR6OlObGTl0JHicdlVJWURPdYpxeiFN8RdHI1M1Rcuaeds8B06deUw8cLfESBn5Li/bVzOqCra0LxqyWG5/bMZz7gjupBQZ3OICMXpUZgDJBdQOgmn8cgrvTQk7engI+hdpiDNuy9+c3A2Lu/qbQu73qTdJD8ZLNDCuguEUQG8NTBiaZLbpaGG3v0n5/eFvYGFUjijHXaXDMZ0UfPxakAq7k/PDpS7POuHcOLCrwhb1MULlJ0oYqkRiRDlb+EZ19P91y6xhysx7uB8EHX+PkFVJP2CJ56KKNatytxDAowbTLvwbMBaeH71rgmnP7PovGoZ59qNWlJWa/Ob6UV2fmKzO7UzDjSNQaknQwFbeftIERLxWs1ixNU6hedp4Uxq6NhDFnExnkoCAJPKYPFOV19e3bzo70c74aqqndS9/XS8/8YnqGYxLL59Mv+MvG+PZYtAyeVIzMwbshNjixVRgdyvbgW2Dkv3HFEeyMOlftgaekNBK5d8fHh/rRW5UQcvrY1BesMVENbT0tWEPivGx6bnyxRvLNVYlZOWlu6C34erWRFZgJ0fb3fwARlv5gF/3hcKxdw9qD7hAyFP6YLL/86aefVpZXa4tgPSkNnpZfSgL9j79XPBnDdUOGInwrYFN1QAJRx7kenzBv3XHIuYnKK+e9QfUHqRkbTBa2e5kJEL4mY9MtgB55PYEn/0blB04M8ENlPQEhgaoieq78z/h/BqZDgPpaAgHYeh15zJ8NBQQnC5k0KCA1BRiyi3S8IJclVr6WiKmJVUAl+P8PNRTCS68wviQCB6zpz67ijSoLCxVUuTPuX+RUhknh6qP2eCLNBmCQup1jXfZThx1w2CwDdpsSv776DWU43VE9ITJdaVTQk79lvBY5uokZmfSePsUkYgDSHFnjtHdGAkveM2fppDeYvNqUlg2iql3hwwaHgyWeQ1UzulwGYviLppZjcvl2OJyAoD8dZ9UZBUgX4kBfKeLX3gArCkvvlh8gQmKYDNq0TgVLcNvUfPjLKekg+Mlfmgf7yhamak0ABNKtCORTXYsfmrf0clm6bk4rcmFnnl2PjiCpBZSK9NftZ1AJTUAoLq5GcVFeijFIHNNplraytH/RkuNQKYU8me0sFXQbCeeVFUDaFdM9FxtGxD1QpgAmPkt5IX4sR3jbRcfbXktYiv9acKp/zMyrqxB68yrtfErOLbIkILDFB/crCxz1svSKKnDFaO57LPVw0r8hQA8YliKGR5cK0ENact4OmiZRAfS3iC9+JA821RazPjzrl+rJTzVptfdh9+j43clblN8rDx80M0rzHdjOc/pAwivKz5bYqfM71f0zuGpdhgR64sGKJWVYHGYbN+Kvj5x5y0BZ7ihws+IkSupus1QtiHpPKB66G7JWdtVL+y4pRLBzH8W2Nd/toTPZ40k5Gj52m4g5wqpQTRQDDEB4Lnc687Y58cgAlek5XLGr8WUM5/FlUSmDd8IOBv27ZDhIlemDOG8LTQUtceza8PZMwaghUQ8FyN2RVgqCTcknu7f933+P10et9kOggvTzBSPoNHM+Hg6T6/bgTr+UsugE8bQKj4dByZIH4guo2lZ7ABStI2mv7D0ZXthbRiwFwEGp3JdSOJgt9HFaUas5kxiiRgKSCgGcw3IJBklxC5aiIkGgFcBmCCZ1mt0lVTjWtG+pICPrs5fS8pLKWtt1vQEHTXhJXXcLrAlMTowqqLjFO2g4wccKPiZv3mygtFGyhvcNjQ5BA1deieeGbPrMVhf7zk5MKRFlZbGqv74VTeCDaia/VOj1m4OHhwdNHxHVDi1K26C6e8zJh03FTKTiWBQrdIYEJLU6glVtLqi7Q5FU0CkBg64CAmHjyO7+5+xR/BeTrchQ8/GDdaLgi+dmYN3TYepNQakD5iZhUELPY3lp6YGz6AyvR+I88kCD8eglQG9Jw0mLl3z4jDQANZWIDsR83Bx0d8RUMro1qF+2lbzvNoJOTuXr/Iy0AJo2HW1KexBjW4IM1j+ld3Dx4I79SxmqAIyNhNu7it0Ip6LmGZoWdCa/xSP6oiluDQc5b3EJnEwKTHoXd1U3qMuCZunf81dA5No3aaI99O2M3KU6RwKG5m+eDuiTOvW1Ah602IfP0i6JuTLvE6zQrExwP1KwHwirHVR+/qpQMUcNYPBngkjxwbYQewG3+I5k/ewlxRlC5FwDSCiruEYphQf7xV+83xsLgoY9Z14sgbi72U/TUfUnmzDBz4gqjeoZNjV50KtqlhWsMNPHJ31iTVbkKz9QTKy4HNbErVaLT0B85r8q6Gb9BusD2qa1DwInzlOgb449dzvYHeKYx7O9yR70rirxtip6X6lxFRzoW1QuYpy2P+FP94w2Vb5sZB8FiluFZ6tLS9xTyYSVVj3B04jb0tdmy0Mi/WI153DJ7b6VmWo2IlyheWU9TVaXV4C1dYywlOwCayQtL4KvO/otT+02ki9h6ZZri5OrdFCtyjpH6f96XSuom8JysgcsFjJCw0BSaLtEDNt60IUoWKEMhu3Uq60duVYWM5Ork3s+BbXNrkLm5KWwHtl2FdAcN3qWPLdvk8a4LQ1hIdFEbzjN7O4r7ryqseJHv4+FRKWReaV6Is8Y3Ya8Y9AZCfPvzjjnHQ0heQWWni8A6lny08vZJ/xd7Bf+2x0Aaq3kjkA98c52bVHqQ6ug6/XQt5TK13HX0L2n7n3onOw9YsNflegEZxOaVVcgf3yfbbh7MLzUpB8sGVjZ6M2Fnyl43Mn5VWoRDf6D33c0xro2VTPKSPFIuh4Otq3+O9RfW/+CGgcir0o5vwTfgj+0Z1PpCYD/g1jw18rlRU0NOYuEs3ZByYN14VX3sp3hWMC8i4xwfWtFG2Kd2gbYOah+jDs97QRihy4OZPUFzoPjtcDjFzR+KPZ+CiOIIpV2Kc8UHEbUFGHT/O3GzubJ3nHreOuwdQRZDlvHR7uHLfB/hADFS7G67zf/1vptd3/74LdWc/fvUPeFoIAvV1efv8RNPu4ekGbQ78HJMfg3GkbQVVyGsMknxw2v5kum5pKu2gzqYh+U1knzbet943izdXK8BZXMXPlK23s7eyfNd6bSMltpc+uvre2Vd61D8Ufj2NRdYev+1mxt7u8LqG7ZkV8BD7wUrX1y/K6xf7y7JUM9285fxepLDZqp9jI635PDvYPN7fx6ojcdQ/rd5nJ09aLW0W/eem/T80wibMy9BixbD8fD616W5lXRlORABRChtSad0dZVe+C7H4H77yaQAElcXrya1XWH1vDDQI/T6+Ek/SDYd5V2nSm0mjjixaQL96VPpR/sc8B+zQRlE6O05G3CzBSVD4ZMOZAVJQTb7Hx6ezdRsQ+WzqJ19IKjVY4E5Srs50gnJg7rTG15UHZx2+WBAAU5yATFnXHaTQcTAfPMxwVZ3B9mKfLBiu+3YbfJwRVYdgRvneNxb0SyqeVQSa/9+/bn33oD8VZuqpdNIeX0VxDMcBnfQfK+szeE8nhEBgrkfuRZut+axp1IVpV2owK7K8Y+0bf8nsHvx3IK5FqnSjTaInDdqew+OyDOkLz9YmiDV7jDzr0nIEqe2SPnf2PXnPySa3fp6q0RZ4A4NRTvCf2rauJrgHU4+FF7LDqswPZfC3n3CCWNujFY0x4Ys/pPi0ZrCsb6Uq0nRlMi8MYARCCMRcLEgbxy771kCrgwpmLUBlg6Q7jlR43IfY/OKvtOz0PTArg4wxUEGIe2FATsy9Mu9tbAUPp++McPjqZYzaJYToUDV7HjKZEH0bs6fMHPZ8HRxzYdfhFiE2Q6FHI1vZkwmOkWauEkxq56xm2irbTDqwWPaN7+uGmkHi84IUacjKyuM5XjTlXi7PH9c88mtvU627gcz5QnTUD9cJ6IcQHBbKcViRyU3Cynvyjq6Zc0wbwA4XwxQoCKuWiwxG8TSmyNObPYnvJXG/0fueiYvvkNv4/vgH+zW4osu1tzd7q3hrI4wsIAuE9xeJaWa0XIUUTzC3f/ZB/eQwdHgkvaJihwMmhPJ1fDsWCxuklb2qHHsCIm+ZsnxSs4ZaUOit/6fr2IfkpeN596ug3UPi/Dy730Ju0HdktlEcudn0QO362UWEqcpi6v81X5RwC7MuIJu5SzprIYGZm98XXc7PcPldewizRQzbt6cpkMzNmWmYq7yCO+1bEB5ofosyOqedIWICpc5IYn+P57sc5nSQN40G2Q7DxbhMXiOjWwBIsj90Ow25BNAY2bSa3sfnx9NCyiJbPgHgeRbSKVbV8IzNIIwRK+fy/0ZcTdzKSKRd/xIQOheMELLYQckVrPgOni6Y8oeDYRbwZxgWrVzlCwk/wGf8EtVgfprf9A4LXX6+X84muMy0tLycCpCih4bTs5gM+pEc7M9efFELkvK9d03i6ko2MvxAyYpU0n6aZgZcBQZVxPRu0sqzuNFMjIiPtXexk6hOA+og48D9eoJYf8CZ2s4za82dpV+hlURV7J3fvt1aoepwYObHvD23S81c5SbKouZ/YqdDQ6rSq53vfJyupqLXkDas96Yj++XF15taQ+v0Kfl1/+tLz80pQsv9Qrl79WXpyhcTOY2Vjmh4Z1Pc1Zl5oiu4Iw3JBcOci9q2YE2q6syiguxRPvRxuUhIo5n2xsEF2cjn5Mnrzt8bgFubddODnkL0ty9UYpAxs9zGmnvMNHpriYCYYHzcH3y+bMgMZpf6IEqNW4uGyBlcLXaGpu6dujPA3hfJtZnC6dSQQh9SAwKJLFayWtabyRvMIQcQF9JScq7Xts93HrHjnGUxPKfvECIqdftcdbw27qYHSKovliIhcY4Eg1buMmHUyMKzP0XwrEt9YH3O4UgYVytPVh9n3yUwQ4y8BQod8r3u+fg2gReoQ3YJcRSCNj0mo/sMHJwHjkJhdj8EaFfTHqHvmC1cOAoFpaEJs5YdthnhNxgNcQ0ak7g20m9bQ1AdY7nepJICMueSND1S9Y+7Z4UKBVqyfV/BfvbfTP3owVWBYW1j0btnHnZpdA61RXDUzZYmz4ao2TfHpciQTUAqxNDQhLVW/bcdpJezf+I/PeG1waO7SNEpAR6Mz4Cn7YHLWxHKDOf1sfA1BXtSey9m07S3S4qUoOPzQjAknd59V4OAAzKjohwUdo+4n+nfHL90cOOXckMSNwfbKhVv7HwLY3yCapMu93tcn8bKM5And30BmOxxAzVw2qJiVlphPIeixYaOaoFoM4Qp6G/a7gokxEBme9Q4mT4LhULY/1Uq2dxaQhdgvWF1r57kFr6cqtGmCLJ1LsSGQ2PVcB8pfrptdaPSHjoS68yauJiprrMWqUe80kPBU2QAL1v0+LcNcctvpovcTbPM4kNuPQuhk9mV+CzpHXZFmUbuaQC8V4ggrJhsgIBuee+r6QPUfFZOE/Gb5Nm+CfIHhi+QFYTIj7+joh5Qa/SsIcHriAI3JlgvBauJruAa6v3Wd/mPUvFLqoTvPkBp7kwGtQVoZSeOWhsxjETaG681gLHUHleOvQsCVaTKB9qGLaMDW1DpiNxrUlfrifYAqmA9ldRG3AZ2EpksjflwAxL9C6/+4hGy7N3Mcqta9HspeZhcmqwKeLh9NK8vo1sNb2aimSlquHmuzigRbFxWsqj7600JlPhaNKX9lhFl59iz1IunpwUV1+XvPp/EhSiwDzZ8H5ANvfCqI81mHUk6tU+pIUavOllEXWjfsH+uuyd+pSHVZeYwz6b4fjLoBEdb2Yjfq9iXgBVBhrfllVIo1Yw8FfGSt+HiokxhMdHW7Woi2RUwdzxgDZtOOI6eSNrciZ4A9VxBpZNcTwL5sId2ZNjxE5vRuQmc89B1fC7UR32vQbThNdoGQnl8rvZIymBxiOXtsjsGvMIGwTtuApZcuhXTonUwkmEGHsDiZ68stntfWiOZu2Uo+c/BJqe5O1GdcFTolK6q9CJOpDIwNNGKA65ni5hs3eZGc4nHZpKvnQV+dquZeRfrXxD8rucCCDogMkN6hXO4lomPsMknyRepWasGv8M6bE1V54cd8XUdLZXCoe+lw2j2FsJcFFBChQVxRI6ApMruKN0PuFoIkMC5+K7VZHyAlllpE4JrvtSZbIVKTwklnlX6wFMPfFYeCVYIXrUWN2zoKMeR0w8h/frtqtZeVsPXKIaJvXyfJDhpcwbH8WKC6Fp0he+/wMmK0XQBfQ1xfy6/IKcxhsN2+4ayRqDmyalQWSMSF3c1o9o3N8Kef4ypv5T2rmL73Pr+TnFV8jR0ThPytR+M/KUSEUgAdYc9o7iz5CWFv5CJPEiBx+ric9zrAv8ILNZ3GR1ipkw1/ETFEv08mRjOoocy9mSqXEGmLanuFfuL6fau2WOJxud9SXFbwz6tNzflciLgqFodnzbW6eh6xm7H3C04DQRYXhXm/s4eaP74q1o6Yla8Zcm8yv377M/AcEeSutyqcSV7x8FtpuqpIVKNHzjFAdY4wLKlUZH4NhyMzk8txpOA47Q5pZXxtMLYGlajiYT505W/WQdgSHh5x17dYOc4lrvDDQgCr0ZAAQ0cRzai86g6qH59BaAU2qibmteeHqSGUxV2f1zAIdKZ25mi/9mrLPeP2fuPrLL+MNXnENVl5wDco+2AMCJ+/u1bXvypk3C1x9/pALcjZugKEED+YJoq435RXHwNjH2IfgKgYv9hevXKKQYPzXEJ0ueq/7c/2piO0g/lCROf0Iem8I5cWPAtYU6/PWvhwdH284O+FgTPHSuBak5rcmrUTn/RRM5twCZVW0XqnOl2+Wv759lpVQ0PyxDGJvYEg6YQ8ZxvAVwxdWTfPvWdfJWkTlEITlDp048vwqcEsSOyV2yHOn6S6u2HSViQcAvKXvMZ55W/m59rXvvsFcbz0Z9lRddVIH6tYMJh45lne+v+aLpeX1MpWlpWwFIAFujirctg5lVlmfwV1l6UssNVkdEzPIi1IYyrNTGzw7VXqwHNv+GXYgmJu0rIO5tbvXvUEFLogn9IiV3HV2I9tZIvuN72iOw0JkiEMBTRBxyeDDkIJ8ONB4KmNjfYl9PoNEZXQj9yVYmZdr3xVv2UMI8CwOK19w+nKpcdDjkd0Po01Ddri3PcFkOdkls4DiG7Nw7/hd+MnbBcZmLHrj+kp5/pYoZ0zl6red93rx7tOvq7zM4yX/urbDzfasxkgW+NM7AwW4NoF22OW8ifrp5wAwKW4EcNLf1su0ptPcMABYZxWX3bQ/advtMEtZiMcKiG4t6k/D20B+IRpUIKcz2APX2WsZUYihmKyYKGwN7KnYK7Ta1yqSyQx9FoNkpp0KYJC3VVZujgIOG8MKY+KQYyHgWlXNBOtl7SPu2X0epLf6pYNgal43FvIxKLinA1790iIEO47XeCpqPBc1zNjha+kBWpnYq2k/vU3GMnK0o9jcpOjTR3CgkGldBg1DgFGVcIiwDJRy2n6lihdU83qslfG/K+CT/gji8p/T8mBN3EzMVpGWakZL7Ww6gmhcgn3RTngY/zkvDOc0UJst19jJQKy8C95JqQ1BJ9hm4haxhoLP4ZSztk6T+i34UUoYxRwnnvMdH+6/LONVHgV67s2kbOZo3yXqajIZPSDEiHyaT8+PJMfGppuWP00up8p6eW+EXqZ0r7w+4I1iltQYWmu/sKKSQ3y/SMbR/GSYLYzqLpZqTBK6ApKPNewbSRWFbvsviCuG0nn57jIz6O1zcnkH8f6IRl15psHe4aiH2m5B3rTYgIFYPaLHAJ8pnM/HFSRCW/eqd0nVaDYzL4OX1FMbLFN/uIwgsOsCKjTz2PW0P+lBdqlnNpuZ61VKG+3URdsAPRNKnkNFl56ENQ+Rub14y2ZL48FGWidrw639+iQFhM0b5r5GUz7OMuUAcVhpF24RyLvIcKdKw6MadLRz0+ak2uPTZPJuQGUNlRgTJXfNMPb169GkkbkGKLy1aCkrDkHajKs5jVdpHdAZ9csqn1u3UE4/sx2Qkk7UE+dR2MsSiNVdYT3QHrwtzk1eRi41AWMqX30/9FUS4Jo1xgpCAz59uh5uBQ4dCDlWVn7iQmqx8QXxjLBHntilaVok7IAJyIp4OG0wKb/LQelcTMeunNtaV6rtEPPzyUacKqIsYiGHek/9axETgt1nc7oJs//lQFKDjHrgMVZX/zm7Zc5ugX1faLBfYO0XM86/jyyL9+gRMxWbNWXTfI9MFJapvB+Xg7Qnd8aXal38V3VsvqkjZofBXTlaYR082VdhCRvQL/WMxNNCvKfEHACZLq/zuKV2WiW+yfGgjHuNPmxbHKMfOFphNl5+3wJReDMN0sh5/gCajcWlyo2Xe3WTR0ddGWjgHYWWb5KV5SWk+/ceI+CTBmVGGO5trHE+CDdczQr6Xv9uNinLUkEDX7jB1OelZvOwNAiiqOVNjT0FdhuP/RDiMacSWnnd5ypIcXEElVmlLPf1CGTyHa5DOZt8J8FmHwyOr9LN3li5FTBC7wArfG9sxoCE2XK/FfjfoLGLTWriext07R4nKwKh0PyeJstLKy9El3TpxCjkRzo1JwMNfMvNME+97t4Ux9YNiKybcnFEc2/6eS7ott/XycsXXIIPCPug9R6wzh+T6vLKK4C5vVmeYeDwlj62k9fJiq+ZQAOsRCz3c87fbCfwYWfwIbJOcQ7NwmZwq8aEXnncxMS6ZO/eiDcAZzTlcMbVfQZ1tUT+R/g7T0OrrgU6k3yHcPOv5nGVt1JKs/lYw12V0xtM9JS/N3FbkjlpTC1Y4Sreedx+ZZWKd0DKoopsrQVsX4eeYnBbquXZRvzlDBVtb6/lbAi8I4bItsnThPpMIgtgUA79zLtKqlqmkzOPNcE1fa6EGmEx9L1gwnmTXeYm61BB1pZSJk/uZKyrBMDrFOq1OgGPLNswhZ7EMpSTUytUkrxPYb+6tziOzBM2IgQkxKecfzdLLjN16OKcDqWYedSSp5TFVLI8hZydOs5GGXmqWCgwkaZMBMNJNCQek7HrS5nThozu+UM2E/YFQlAUC9RbWfTxOgepVDzYgImZoEX0VlcVJEbixEUuVjxhzFqDdHI7HH/S6PI+PExaXcC9RrUKxfjGVp5BkMXO+eLk86RSg6eNx52Hc4glYmHfA/yYAjyX6Vglyvxqg44/Qwi/rz0mUFdw9/16Y7YnX3czIXd09pXhirOOzjAomxRolqXaHGHzHJWlaZGbAYgpWBNwaQulmv58OJ6Ym8FWtmQTJUiwemdlnEBSpYF14aC0jrO0GCsi/uTFU3IG1WWZijRH0FWTJjCGzv8iGsYj5tStYKqSSAIMt6RMWidIs4yDVamxGqwnjEqBv055mRg2PiA7RLcAGQA88SJnfBcOGuCJu/wKZI+lQo54l/lKeJmXuqlLS8fzRLYPEtrGxLaPIErtZWB7ovciTMtX9gD7UZbHw9EI0BPHcDPqAhV0WQ9pfNQXPTuBhCjfwV01hzKsps95mnD/3cyWQCgNjBdAQQUqNKJTL4KhtlYzR4XOmT0rJbVqVqdmHp6eHU2Z+GGFAv0Ha18eDK0/g3rmAWpAnDIxGjHft4biouY+AbEGGzXX29+cxFmkjrPsklb47o4rSD+mgGCJlDOTX1q3P14TVLN2FroYW1sgYpej5LRUkN44tZJqXE9lUxTYqWxYp7ygTvfzUo69KBM2FFCLJ9dVt4mgS63FlV/lg+kEh1rjPnuiYWqjtBtOZP27GSKqcEHSimOsRIOi3Zc45tS00c7+L8PeoHqb1aVHBsrAV1fOLK2Ozj0VmjjmK9dnunMg4ylox60WHxTnHZVH9/dhD6nM/fyt5IrzD7kJxRHJMOituCDdIAVHYWY/LX+6zfKzYeXSyI2ouUJRzSiHZzNq5Yo+YyIReS5HbQleCI6diFknYi+TqsxzjPyI/Qn6IY3vv+P1jxEwPK9xLyZlRizGB6euw0+TcHW8dcxMK4MZeavjJkkXqI8cwoFoRp+HXXKMwIzH3ABwQY0qP2sc9t7wBgBqcSing04K4K75tj9+OX4V5V30sVM9ewATEsTIS2oQDw9TKixMJCQJkoq+wF9kCJIV/OV5jtL+zZuExJRAsTLiLZZXSBPGMPSFZwyqw2uYQB8qRI2J9HEf7Sb0yEZKn56Mt8AOZCOKMB0wtqf3fB5ZGxPkqdZ3kbhINq6H8w+0kTuwb2DOOXsey1MbxvAwpwLlMmcpkZc5FcSXs0fcAEM20RJw7olBunzXivN2d0F8gAxqy/+Drs2cxS+tMwKKezxzQG45vp6OwOw3ON5jwURWvnwifOQINRd3yE1oB/iuvErhL+pNLOMjlIuOQPnagkU+nw+0nxQ+h7wpDIYLovbCbfbl4wMIgR3a7X6uewEgAH3Z0A+mjWOqOF4L0Sc9gCIt5sdr3Id9XelSTFVguN/rMrjDSizGBOrqVHdxpmNNsEUFMScsIaoRI8Tf1Qp+16EmVuysf6e29ybGxMrp70GQid/PsMSLeHdhCebv8GzCg7hWqI3DIQNV0SoEa2mEfoERCvb/otfvgxfH85yHtaKX1yjM4sNQUZ/gf22wcVYi6cah0ao99viKgN/kgoAP3vVQFLrkkdFqthgmMH8+Wtf9d+V2JmdfVmm2oi5KZYckd1ok0TqfZncOgqzSM0ik/dxkAOoOHTqi/nyb0SLhzAtWFJMTzgBOIrDPQbIUPAU/Sk/E/ZJxl5E94L6D1ECt615nPGz203TUEuxoOh60+wEfbkyEyLxAZKaB/CYOZJ+vjWUlzAuBb+V8tIikn4++WfIcMaUVCHrI8J6FuclCqfwkKvrjJCZ4v1xDsQXXvYFYAt62fLuOQIRTokd/vrZSNTeebqFAtw62ND7+eDucm+DUJUA7GPR7g7Q6q7wn9oTT37PpKB0v0hHUuOK5edMeJx9/TQeCQHaaze3D9+1B+1KGXO/0IZwQjCFGV/n2hmPpfghIT3FRPNKlXxkhHnrqTozjsEgVwXhb7c4V4O4/73HJ5GoMiTyCJh+hSevw4OgY0P3npaWg7P3WZvO4tbm9fdRqHh+BRHHl+c+L4qGm/79UCZqcHO23Ph5sHR8cnmw1oIUA2trdUCx3NO2kC+L8rnXTm14nXbuanq8thx1s7za3Dj40jj623jd/hQ7eLzQbm0db75IfE/Clfba8uAyek+8OmsdrVpLBztckG/RX+zT5AXp4v7m/Vsmy7mhNUoabdCzdMt//bW0V/hXd/0Ab07WFXpyOimk/SvjTS5nXG9wMPzmRhUCFlkmlCH+3u13pNQ1/w217kyIjGoTCgVCEnmJMpzuzjZVHcnhmq4Gd3yF6kAHnXWLGXiOWRveBCmY67XWPh4qxkPOED/iWzmTGPEg+2UW58yyfUU+mjhGTtywWG0DpU5JpJ4slx7Nx4s0k4LkAQQKm4rEAtosva+SNPzU6XTToyz9i0FePPajsqLKgIT+VAfJ1Q2ucsrB1sLOz0GhU0CN1SnMYaDLqq63ktF8RpznbPQhYNifVKbxkIeNAxbwbLBzk48TMXyDDK131w+7R8buTt0sohJtGoCX7v4qJ+UAErLhaJQCDKDWj2VlqqchCMtWLlzUD4FLxS0apwx2QmZNRV9xKkpTb3tUhncJpFVyWONKi8EO73+v2JneYOgSFyWvy+A/LBeV/ZSi/fnoFdX7ccLkulRDytjgWlbSlsNXs7XRqloS04iO0PYvddCL1Jtr8VYy1bsuu2583pfohmCOWH2tQyaSlI4iZF+NgPVo8WsTUUQJbNUfmyvDboL4LZBBI52cbRXLwPs9MelQWzjgyeZxqElDIspCAM9sBbAPiyfQk0Rcx1TU7Z/Qdb9ga7BcuVDu2Fm4Yl1I5B2qlYBaepUMgcu+V1kpCCIkzAabyWpdpOXR6DuAukpWlpeTgr+iOkdX2D453dz5CRf2X40dQVeAIM40hUtqkUuJILgGdjBsplkesGuyWbKsSq2ygqf3rX0lYoubA6OtRoljZKhZMQZ5PwWjCJFT3vTMz2zWSwUceUahpaNxGmLZOredUVoMsJuLCua7WzlTmlQnkf9Cf8t+dupvK3oGSHlfO4J1ovp40vQ9bm1vvGuLS2T8+Othj6tqbKcbE1fzMCNKJTRwHiLpOejKQqdRILgu55UMVg3EFNXILMC2fiZYrXktzInCCmsjaauwxCS4MdVnYGdXtEMVnZesq7XxqfB71xm1i/VKa4qNA1vLF4eAaJqI3VcgjmXupeLocuTe9gU/G6Jucu3bQlaMl1KNa1FdYZmASS17w76M39hLCSIMupqX12e4AWKh/zQSvXgeX6EPeYUOwjRqOdZBW1Rh+ownPzerFdNDJsZHQb9KAjwMDiEWSouuef66S/lVNH48hU73S8GdErCMLt/WbgpSgp7ITcvndsgAJYDAcMZKCueNxMDfp5ELX/AfgOofUgajvZDBOLyEX1/jd9LwackaPfAbi8g1GXuJtr0MevUAL43E6UkJY+ANU4fAHvijVChSag5SzurwE4nZRy87V31SwTzmUFhjVmFyj7ssk6nExBrFYNEImMR8ZfkqGUeGFS9md2KvrVjq4oeIlRdCMLVlru3Hc2DoW/MR+AwNVvOOBMzg9I5DOuiMn0/IlUNo++Z1qSfeom96EH7PB2zsVFyz8vq+MJWjBhSjQE6cF4BDeyM0c6NXTBnKDoYppTAQ4U3mfbqc3ewLbmxa5lpi1GmwOQWVNBa3thP2+FRfitcfjnmAAcmoMBFw6V3l9SFFObh9ib82JuMupJg7JbXvc/WBY1SVPEtk7fyetBcbh6mUb0zWAMagBVLR7lEIIrdx652kbkDrY8V62P+ymf2lyUlLfN03UMT70+43j3w6O/mo8YMRZ9LC010lhHuaZQhpvNz7sbjVae7vidEoF++7xR9pDN71oT/sTGWEOrOYFip33Bu3xHUYw64CXiV1on/dZUa9GXg/sgutv7e7vHu+K0SED4UaysIyKd/eV3n/z6NeT9419kOsurHjNmyeHQHBUY2wwolcHdXYOTvZl+QtULmhXEww63u82328eb72D8tWw/duTJjySFl6iIg1t+PwTnq42nITvr8g0W+8Pjhqt7c3jTSj7GZU1/vZu86Spp7+MYbN9cPJ2r9HaBLjJQgwZkrcRCjFYjo635LKPGpvbcu7LGC47u3seVJYxWJrNPbeK5dUQGbY8ecsqs2G7cq+UNan7xFQ8YWqe8FX3DvZ/9avCN6aqAp1fWX1F1d/v7ntV3RdcbfNvfjX7hRlcXHG74UzVV1T93WbznUCuHWVQJGrDG65FvhJktLdazi2nv5403+JK4ifTU+OYdNQ4Duts7u3hOuInquOuY+Dj3Q/xuoeFw9tVchm0qHUyyEZpp3fRS7tNWdIY3ETooDfMoikid9ug97/TdBfQmBMKv29PrhbH0nCwCkEjfgLl/ItX9WTWAl8te5TC02W4rY5ERnV1QWGcX/E3t5Bl+QOZElOw+H7YnfaN1ebHHfESktmgRJFkEOtJRdWo1P7D0/yRPM3jcy0xromR3m2EtqjqstKPsC3oSj1pdYfVnn5F7PUG4p0aVgitU3M6U/R1SxDjt63jj4eN1sFOs1z/JZgcmAK8koe3UmUh8BWQXIl3xQ+BySpw9DgFTozSA/9coA5yjoXred0zUgxnSl/YotwcXVBjK8cP1519Bop6xE0nmBfMTKwYKjKGBW651Bh9Ysl+1X/KkSsljd4L/l1g+gbl7TVAenFx8Xo4TjfHl1ko9IOFbyPDDhV2506pZhYv08mOOGIfBT5Ua57TqvR/rlaWVIIAVfm9eLReyeLlWg0F0faq69pqXFSPGmiBFwKp/244HWdkHt4Ya+EY73uD6STNylRtpuJQd7PIjEbj9KIHBqEAHRM0e6Lz0yWnKAeDuYPF97MEq7Kzhs7Fg14D0nZZ744RwBOhNa4AonckAwCm4pns81lvcSKjs/MVF4EE14jJmZ0LNh+790w0A/ofM0goXAW3Eu1u5NsdCZwF1SpTc70oeTfTlIuXzocADRZb1Vv+NMGWorzhBAB72E8VhXANqfFEZ5pNhteJGMJZTvhBWkxH0vRCnFytLhfghgfnZAit13z1jd5Nz52Sn1JAEnI9rPB0SnWRp+aMTHXWiQbTnG2SnIbEXJR7w0vDv1VFbxfTgXc5EVZI1SAaf5+LQ6ZB7W4XJKuC4Apmhhi/0JzUmkM9VRVdUrhxH+nUn/iqX53yRvC85jbbltIOzYKGnRnBLNG0Klmn6mdRQHKcZlfVMLXD9HwHIlJSShZ3yAHOnddTSjn42K0daoKiEs2TKG2CVYD3g2cCgGZHTWMZy3Xk0WCa+ZbncvKjqYCD3rl1lkiihwi3c67XbgrRcJNSrUJndrgFBRIBN6ErYkzqoZ2YcRd6oquV2D6QeFdQcfFqCGyxMoMzM5bfwNFK1gAm2q8hv9ka4k3Z7g38OuprGAaFzozbRs/2yB29dJBNx+mJeSNpGeD+cHI0HQwUP/NPbJqU86YykQAikUvZNq+T50sq2q2vd1ASJql3WFllU7u4HvWsnRn2+XDYhwdPJ1V1IB2F+KL0MOZ+CTPOPO669B64zbMs8xqhjXVaATLpoKftd8R25P7B5MUt2iB066I3ziab3ptVrJ6DnYvO7D1yMXb62zAb2fFbRyw+Sq438Y6vjnDS0bhf5fVviJPLlSYwCIIjXXvymYeuQHflkyJqWTEeDidKiuORzHW/n215IWLHWX0v6i48TuqJahJwUkSn6oeZgDl0FbSkIhqS97Hgot1Cs9Z1L8uUKuGf9+u0UF877s7hzGoskDUXYRXKIP3y4Qprxtct1DlVDc+sX7GCC+aXuY3M20IL/KnZotilbiCoJ4ZsPFVr6w22saG/+K8Fe7A1IM1yGMeY+9xIiArpWyOVLaIYk4twGDpCixf/+hcQBrE3utp5+BVEelI3h05qsSgIUtVrSywE864EyzaeN27SwcR6RQaSQi+sPQ8P00sEG9KbSbR/cryTJLvtqQfWzWQxvWFCJsu0sZWnlbV4VlQ+oRkTdkKFwZJ7Il/0MKg+SvCuH/Wnl5d+7gIujZ4bO+euyAur4vYWpnAtJcaLEIKwGtU21dajfbBTqbqeucSA0bAtHMjIw1YpVhM9XMQtICc55HeF6U3Vlj/L2XJPyjw72NluHhtk4DB3mT4exBa+xiGZDh5wTDyZ/0P3y+vmsfdLDzf/DYtLpBi9TYRMK6mlIcSByflFTzwb+iWZvSVGhm0aFvD0UY7+nj7LgqeNuMEguT1wPHXNu9XhTTZJD9uXMsVp2u8Pb+UP/OzVggrEQxGxilMS2XtLmlTBUYetZXpVPUgfr9E47cg0MK7WqW1+hhngiwlSYlr1IFNZBsRXlTeSm2GvSyWlpp+YOtF2GKSAZMYEGc0E6Sjy0vO59eYxNrKG8YCTtQP2/OpWmljL0sWr9rh72x6nOAK3zEkiCJReqaoIH7A6BQFKHspxKu29rYAORqmrtqcVcWJ74lCCCrdyZr+2uzfpeCK4IqUShBIzrMeMW2yBXjEf+v+z9+b9beQ4wvD//Skq2t1uqWPLknwksZP0OLaTeMfX4yPdmYzHP1kq29WRVJoqycdM+/3sLwFe4FVVcpzuycz2YUlVIEiCJAiAIHBDb0A1SfRWvjBw5gWFznuPvuWjvJ7kYQsNcCAmPkO8MAVNKK86IOAEg96bDs/jbM3Ec4eRLSQg9o5CaDVBggiXK50ZFdJkLhqSphThxXWuFs+culDTrqkaLV/bjsbBNhNLEWgbGmZvmmV9rc8Z6gttioQLqe/wApUvnzHAnu5Debr/kZ/iN98yevGv2yPhpCkWpt4SxRZUc1aow7NR0P8nirmrINNKLHOi4ntHAYCWc5g3dx/7t5/4eGKEBXxqeAYLUtBOucZhQfQ5Odwmo/XkLSyWcR+Tao9AN28QN0EXOQV3NPdg0/CJmvgWX3EdqCUey1Y+g2j6B1BrYVZq2Wzut98ii4B6DUPwGLHQXbA36DhhkZh7U8xEXboWPJq/c7s/OHMrsoIgiK8yZPDaHEPbaJomva1XTItyN390xUIR+g+YV/OV5pUTMZrwIqvXBVb+8EEbXrXiIjCXJMGZA6/ASQIB3cFjYpJc/Mx2NW5+0xs3vAb3kgP2ggnEQ7hCoIPU6zM4gPOEsjVukZgwdJYYb4ru/kizpIhK8Za7OMV905xoqi4QKhJijGBo7wkbLibT67gYdGglYk9gFUL5uWglphGIshRzrWP3RkDHDbau7vaZsMVmkKa3uh5pXI4cidLwYZiW1M1Jcu1b4pISwXwbmQeiNJan1QyO/tP8PNZ26r0F7i1WM+6DY+n5efuEU0YGSzAqGALhD1tmQ2EFG8JeGjIK42rquiUT/4P3d1CxAMYDDpzg7XOtJSw/PtDmMcmVKsWe8Puk4Nd68Ofjs439vbcb79993PzFBHxpA4Jn9/oHALROWBlLZtr5ZjxAV6H28ppjEEfCQrql10b/CNUPeHIo3fKnNBy/IaqKXos4jG04mFqxcoVdTEc+2A7A0qTJqFNwWNYyO1WeeDMPb9aMW9DYkqeQpOy5j6cZGmdARDMbIaBL+b3qXg+VKtlPoDokowAeArkmAhb9C6Etbfff3DHNibVG9L5h2+BFDbC4ar78gQy1aefApcoJzpWCRcsQIg25aoK5Vhe0Uplz7u3J3saH9R0251Yds4q6RCya6bHhyFbhp2JArVrjU+vUtdMQU1IOvm6cWKgs1smWCEYvTp85jthj8vHY4Lz929z6sLP/ztu9MuXGJARAewOEEXQ4ByZZAsmQmJB7wGDrFcxV1XujWclqCXGZvHGxgeZOGbfg4TQEvuSfIwFgzsQqAn/oeLsjUgJjCHI4HiJsmU3G2xpbjS22EM3H/4DHbfa44xlF3FB4lmG2mfAUi3zeSiuASKDX8Q8wa4g4KTKul8u9EhtrBnspHvTZ5p9kSa8EE/K3kXhzsuZCjNanUWd5JfoRf3bg58ry8qJ8gAFR2yvPnj3rtOWzpdO1AOKhiI8OARV/jJZCYP0pd2T2vYeeAB317vnM3xFwL4SxgOpWMNvfypoXjNZ4plr47NQPTSEZ9rpA/z1j73DhgpHKX060W8CuhNqsKwBzjq7Lj9TrVVmGiifODSD8bsZKSBUtH8r7Aj4nROjD+KIuHHNl4+YUXu+pQLA9Jgcj1wNCmwO1KTAVQjan4bzZnMr76shPHpUn4w4a5mFZ9+bajDTTj3uMX+3xDZBtfh869dAuh+YAjqBw7+ESA6Dteys7mJ6zigQqtjXPiWYxZsWUjbKTzap7tW7B4xJ45+TovZfC4ph2tQrqkmwY2vxCZPtoGQRGkLiUhXqJW1o/7rXatT9ESmdg3Iyvm7VkpoFVwWjMBsiCrPV/qrm+Map6Ej5FyZrLjWLHZSl7qpK8sobXl6Blj5eMnEOqk6LknHvI6UTQee3fsLmf5URcH6Ld4lF0OqeNMgmVG9CEGCXD8cwRrCUnsNjdzqr7bMnz7LlNFo+jk4dNhw6jl38fKksFQNKU6gCzKQCSvoqtyGBHQglgr0oPvCsc9Dqzt4zM1uKYb/vMomA7Da9d2yxqXpwzrm4QCvGLYMK2hucI8gpWveHLvOVuK2N6bjs+Sy9I1/CIB05xx1SBR6AGTSCBQZnikVnwglcBcjnjifZ/xHO+B6kNFjtonIY5tAhpB9udZ6UxDBn0/CsGLmxBvD6eZwOQfo+2BLYntpjAL7aLD52zlcP1n998PN46YiqAfgo37jbh/vuaRP39q2hl0QiQyPOT83t6BydvmLrDs4XoYHpAGZ10ENcHUvQ1kLAgBru6LbBRgdrK834DTVXmRnh0vH9gOMOGgsPz8pLw/JeP9h7qa0S8GBmEiM8XHNOXILc/5TDKb08MksjbDkMFY/4attF5nENGR9kDSU7D1izQrDlTWwgxwH1hc/nQ4empAB5FGXjB6Mm/iKfxiC6B8+nFhWF2RKvhqD9eM4I+cuyE/sbMYhQNAamJZqXm5D2ip+2VqjLcFDQO1n4xQxVk8LKOWYyQ65Og1tOnp052S2lI0mWNC0Swu4gG7Gy9W9/4uBqOh06B26K1q963HdkX/+vF4tdLxa+Xi1+vuK/9ngN0JF3PS8FUSwlNvDJgjeASsbRpMVPZdnKuL9W1bUmdF//ekDWrlr43HCtw5fFi/sHbwHAXfvJxrvl2Z3/9+GxrcdWypY6mQ75VlBNFgD4NwWLyhlkLtFdmLdFZ8llr1TJ6ZdLEngOCmILqPKQDXHWq86objdKLlYpNhXDIeyCgbdtzAtgZK8pxOL7EZMdDQCZ74H0MhP6Ej+aRdfPYwI7ANz+v2aVfCEMVqgx1syJqQgvRIa2JAXSjqCWBWU3BzBmOM9ievteVZu71DJP2epb5ej3LVBWZ0XrCpFO/Zryh3ka4RTiZaWOeE/XgR4AA5rPYjn4zVEh5WX/MsQBMZ5Fv34in88ypdpB2J3ydqxb8yAOajNObOturAds81GukzwhPdYXxR5zlnsleNtUfPtHduXj/3RdPcd8En2F6V2DYHnuIgKz9VFvzXMMwBPvIlY/KxGPoPX/llbmI5VTNX/b61DqFdaQGvX/54urY2AzTx0iL6B4/Bk0wIloyrQ9lMTZPZcPxNr88eRDo2vH8ypz+vky+L5Hvi/J7q9lq6+/qq/7S0t/013hRfyVoSW2kEc/01+f66wv8dmrclAbbtejjqdX9ZMg2tnQznZ4PYjBEGlEr4kt+yY643XAf4Fz/GHZHkyTnh4DAI1pLz0i0BfGSDLhoUksDQUHQT56tEOVE1U2dPLl1kx9hzMMvw9VA4jKC5BfgmdcIviNmVM73qAkVpgg2EvIrtolXioBmOmCbqrSYcI73/EeB0esTYUAuRIT7tdlPXrDh0ZFEn36K5gHDqhwPNao4mBAECke36qhCZqs5bM0aJcdYRo03Rl7S2kyIZ47tvQH50FGBZonZxfaAFy9EBDveMs2+BKdC6NfO6HHoBjAsUfAlnvnoi+Lw0FRIgRKq4gBCYypge9BVgFWDpV/jcrCnRr2NaRvbuB/r9eKdHBKvgieTBKp4wPS4jCeeGEUYTokqe8ZNcCPY0icFe+qq6T+nWT+vY8JdMuem8CAUpEloVwCizmJNFbqHoWAmXeKCLfyX6P6FFifcfX80dt+EbArEKxUhfzEgNX+h5vuC4h89xZGRlRdnTKPWrdke0HnW42fUU0IOECvY/0hVI0cqqKDz0YtnliesQPLaScLOG4ioP3Gg07VyEylaKyBFG5vPpFUmajFdELfPZ4dXHegB9Rm65vpZEBKWguWOBA6EPe6y5StmEkcDg39Rh8ohBM+LjtMi9Va2ot2yhSo+aOgloI/BjLWp6GOumrcg7brLJrGWjYxS3aLxoyZdLsfR9UNZ4lisLUMy8ywfnH7J5YgmmRZ7gA3GHm2PnKdqlY6JeiT5MjoRzdeANbIfL0HsRrMwm1O1F7WGLTPipuq0mhAyCU00byvuHRYxX3u8KgXV5uFzrVpDFFleowYCZOmBSyCjBSeLq0TottvKhRqOtnNMJ7am6KV965AP/jVXsFqgGPboumnxxdYw/fJ6uDKxttD9fO9sC5LDHwcJVJC/tmrF+S08vZKPbf0Ce/nKdJwwqAOswFeg1TIL+ECcKaZ5AM6LH6MAK0hsVtCdpAk64dpsYDQd0gNMBULs1vledw/MQ41iYUw8QyGCadhphmVoI86TUQd0UPbptIPzGfnGcSfmEotUHn1bPCsBX8DJqmXyIqb5Cl6n0KvkwokIjTpMRrgPdZh+DNOrsUZEJb+22OyOx4O7Oo++hPnd8XVdVNfwjYslLjFidFibvAPDCSLfBAhi5ZeHlpdRiJqWM7x5RqsJZkn3dwBG9Cq+/cqDantjU6QQk8FniBbjNtJp0DvgZcvjBDLBdeTvHMN1Mh5DpM08NqPf8m7ONlxcq/tag+YsWmnj6TDGkCiPwfJR1Hc3EBN+pX0TwcjUSZ72kTYd/HlJYml6xl1ariaT8erCAu4+XrhlDneTF0I919iKAVckOgQjSfb8Ado0jlM3KRfIFuJq73fV3Cs9wfIoqK6Mbi8uSrdRznbm6Q/cb/OVDeUZq+Ireh+2eglfchLnigdHcUL0YqQzMK2J6FbdvpE3Eq+uqmY4pdXFXYmFbE82OunoIEGbZgJYfUQKNb40tZhQ9bjjWnVbsRE1TlM1CqEEZxa24LCIdrK69xEzEM14JpIGcPy+hA014ovJG0JcTGR6rWIDLtojE+Muhwb7Sydcb9avjZvkxFDDIakPni5jIhDcSpR4qhqnohroDUWU8KhfLj5VdB78L9sNIfc31J02/lrehDJjKPga2AIs5q4oroaZcO25iNbt5BrzhjSwWWtR9IOqURQEZ1KP6UYnIg+IzQ5mHLlTbcYjEy8D0bSMW0IW6BG5r0/hB4LGFrhxZdkOe0/uwopinhj4n0Sr7avjaJHASo1LNtZmMZAEpkWtgZCB70+98RvcK6dzvLOe0KTImdigQRw1ixZqKdKQdHYITCzoEQnVEvNh3O4rYbb4ipTE5BkpiQvHKbF8YukS0pdiDdYi2EqFSB9lNKZ+0bKx3iCwbv5m457uv+z0NyKruiKJ8dpeAjbbcaa5nOeBQK4WvJsrL7AmOGULlsQ3M/8ffy6HaaOncsGkZcpKOriOdXm292ANezjx5VZEA6R+PHuzfrQFPnNHnwzwU1+kHs8mFSwU6rJdILhdGYBEWyUHIgGkTUIMtfM7MZ1l8B3McBOigufQjQc7oFA6BKVs0Awkw8YOIUjXG9GgumxZw/QSzd1IS9X7rW6yMM2dJHUws7A0XHOr6rZXqwnFx7JTb3kCZe2lGFjNJKRKLCBbz1MKXGB063o66MNdwyHEVvqpYUXYElzybZbEo/4AWdP/LQQPUf7jFkRJ//8jFkZOdxX/YphT6qobQLvyJH/MKV4+snavrG7YnGEGbvAHdnumdW333koF7F4aZHA8iBx8G0/PLa+UCiKNRFFFb7VHqaARppCWxb04ueYppQJ2oaJIxap4UVQ/1i0IVSJBjZB+GIGGATRZQ7f7jcLI2EJM5KAoNksKGdZDbhJCQB6d2OhRnZCiyJ5ojK1xO1cRFX02z+A6cA6hfOQDeR2YX9jIsNSXDb1/oAIWprDdvmSwiocqNFC+pNClg6Qt+J7o6VjaCeMgolK40UvyeJTzzEfTke2ny4kPPs04JzhoUzgh0EGdZSjXnLkm8fLp5hmXulO0ZMLRgBaMfqZ+OGv4LYXAo/zxDoiQ0DLRNqs8ueTVqx64DM+4L6orMW6MOpxepLf7pOGBy0s2D8cnYbgnrzyoo4ICFN4KU+mfeoTWa98F5x3osvqirVsF9Tl+rHHyj5QYAjlGzlXde//GbO4OX8ab/LuotTOF6w6IDkog/X0bqap12gWBV96raLOmZPOfo91YVPhPUmz8XSc6zcyaC00mJGrZY9wgNMvmnJ109vk2y2B72kJW1IPHfJzF1/h8RunHM1IKVcU2WwNlD9Lsk1D3xTFbSv8DjYuBKPhiOZeSqFZbC4pa9/++64ELGWyjPYz/PoXsk9p/gK+DjD/nSuh52r8T3iBc+pj0xpD9ICLnsmjvh2iP4khRIPCHkdROMR/fHx8fyEZYh0aDtPfZ54cCtD3JvjFHFNFo6TCExYxsL/y9TF8qQmXSGNwag/z2FAAoEhwASJ1JTnI7HNO7reNoYZROmud3I9dN3O8lI+qp4FGih2oGrxLTt8VCEXRSMhQmUchaZEayX6+1as0FFzm6RaoMZaISySPQSMXIF6Xo/1Bb+65s7ZkjgpMCx6A7Tpq/5qk5CAKJ6E5TLB7W8goZZO6dGSbR+E/y9NZyA5crAF5NG75YI+rggEDEpc7wSnMpvb33YX1ne/Ns/fDdye7W3vHad346b4+uoSORYjRA3HiUTi+veLvW4I5n3IOUFt1oGE+u0n6EQml3BE9ODndqa4GdhjiQGK1//fVaP0lTuKNzJ9s+7H6OI0hdyGZzDI2Nkpx9bM/HIwxrFW47TdXpz4AxY3pISF9VPU+nyYd4Nq8TJ5vXiZO3M5z0rTR3p46jSnNqer3maEUB4DVPDSWjHuIO9qjvpdgAbquG4YBxBUZh7EhFYyrm8Ss+TVRYU6E082Hir9qn9DLY9YmRYa1tZ2hQhU1Q6pOjBpbmaaOzwBpi+oqenF8be5BE58clb4nzUl5fSRGZk2BUflawf0qShkBqczzOZqRvgrtNxKnMwJymOBRWacaBvN838SLFE24ZgB5edfPDm/UeZrpplEyqk731k+P3+4fbf9kKTiiOirVplMT91ajbH0Kq6SxmDyZs68yRvyRZJXbRh1BxcV/EmpYSv3wsRSxHV+Gh5vhLPjvnBI207GcIfY0mJmKqQyImEupcCXadEslO0KHjYb77Z1uHh/uHPjhOsNhNJ64Joq5Yycj198QnSggXmMCWyK+GY6GIrCTy85F9VLKa/zdlEg04jF/Fozqh9xwlvk574i/NySMqWTNuZ6oUzsZb70VODkqqrZc4fXOJP8kP425/fzS4C/h9zyaF+WUwqQWru7j3tuheKqP8Z+1/TJeowmS8VJVxruTla+rlyoZN5xwuOSy01DKwbwXUMuGXQadIVX8dw04AJQgTeGIdVAe5q1M0wF0NOPbIu5rUKbSGZ59M1jbs2bY3sMcXWCd6ol6/ZLflSAxox0k46CJcYlfHam2TOkxVO8jrIypHvKtKL0KhqBa8twCYYDvhxIV0b2cxxEfE45/VaL49J9L0rcKn/JH0V3k9c2pDg0fSFRJsT6uKePcFtg+HEcr1UX1ZGMa0SivLmO0FLhn2EvfpMX4M9shpSZqwRCeogqXKDNlUy5PzAVNVUrSBdXuTCFQZofqex73ulDVjxKVfxp7YoxiaeZnkjASVpJPpmIkgeuOy8hc6CdKBy81xpkbIyJE8hGfYJQMsg4IpjhHqFjX2zjwv9Ey8IJw26NEC3+LbSdblotgwl1YA2wQH4Eyc+8L5KrBUobSukI5s2eqyPVMrVmaEdWRlfCteMEreJolbsx5qXuyK+NZaxpDWRKQ1KgE1U5i4o33l1TSFDZAYbcwxMnqLCDzht+W7MBlQTLgze+Me15fv4f4VYtbtheRrRAOSFeI3hBlJVhS1rS58ElTUDP50rchOaBIdYx5k6RhNY6YMLIRTrNY8V7BHWN+u0y+iGrfS0f0XrL98/JUpb0FshWYPhO0QUa2FZo+w7CkTvNEx3N54ddLRv+XMo4IlYy+YO7JahOfG4O7N9OJCDghcrjUlH77tCDC6l2DiNd42LQj9xBaKHSHEXX3GYitbz3YWYT2F/vdof6+Jd2Hris3Jm+aqyfpCt84dnGW6ffelc8XlTAFN1QAU+6oYVraJJYO4j/7/gz6KStjwiOER8a5BsVH6OplPIN54hValCX2O70SCYwbfcEn1iQGccqsQA8BfTjJZ3xiJ4oF4umKg9BZGNf3AQRLdowpXQfAgylwEFZaA/1R2cpWlN1bROZOpGXdqjN57Voqmwts06wlh5lAkPSy6W11Zvwbd2uxJgdRuXukJK9hfoEyHNF1D17bsgXa2WccQaarYPh1boN8MEU+UMEKty0y1zg6h2aCM0KP0781wSlAJXSCfeGebKCcTYzfPIPbPlppt4nUjlJvMWC+qhTOcEM22XOz57hEKrPbpjLOe7b2WxxkMUF47/VQjoLXTte/sLDBcIXibpcOPB3VfIlvKs/uhwS1NM3kkJw0oHZJaWj7uO+8kcdThpvV+NxcJl83HPLKuWfe74rq94dK8FWJyHEhl1HI6t8dTPouclBq5SAW9m4s3ZrdGRqldLkaaBZyuhGrydsOuwMS23u+fwD4wHcQazwXwVAtZDSfkarSXQpyXMTh+xn3YBmGOHvWyZDypVRjvgmGWYS71BjX7jKkw6vVwfWWzJEg6L8UI4gIql0yj4OzxUqvyFCyZUsU0Ck4/py8GY6z36K/d3FgHPk4KkdHNIk6zzQp889+H2EHDeNaHOMsxu5QHB/A7C4oafQsR1NrNdqu53H7RemGtj+1RgjvJEDcptryG+aXN8iZxbyJEYACz7kzkd/kkHp7Fo2swXx8dbR6YGheijoRxanPreGvjGPJQgGuKpTOQAT7muQ/fsx0PMtxex9ldvVGgG1ZMMvw2i2PoraxViUI677N2YjGlnypuLlVPkawUHRLeYxowtaAocExkKjq0vC+YCyHzn5PBAOlhkkk9dnzM87w/3u2O2MaceVPNUIDmHUyGo0k61kPnABla4f2D5VPaBHnKo3Mjm8YBtZoOY7h/km7yxZnbVGAzr3s+iLdue/EY9LO8biyMWD0XgH0ShFZj2RrNjMQ40OFYdtLLk9EVRk3ti6E/jH/leaEtlHQ9pulnVUzB15lQ2s3h5sWYYzIOc82M1Kp0pIpH3clqJKdsTSGZY+orx7sKT/lXSXeDU6EOfKgsyKCZgPZDfA24M2s6SSPlnadVnGnuZF4Zmw6d3K8AL6fUltg/5PFVmtOYxOnQKjZFDUY+QR2MTypIPN6P//cIDCA3yaif3uhvzVH3OrnsTti89TxrQoPXL+PRBN4u1JODbv+35OAqHcXsI+03Fi6bE1B/wwXJUaAii3RutM1egpT6ENNyhixFxU1hU+WvqJHJ4LDkbMKpzXCpbBhnbT6UyxVQ2v6XgR7kVbrwvEJ9ITdOMiMr1WXGYnOhwFrVZXA15Zs5BxZJOodzAk4cX4iJAAMQ0W2Uz2mzJfaBIg9eNNS+cWjXgydhF1TA+/QV9ToN9buFfjlG5zkYElB3rzudXAW6+CfaRQn32vHYgDe+6kUJ4wAVeASvDd7qqlZrBlkkmG3PFFwHy+pucmCibAtORMAkwqdGXgwgCKMmYn0asUZgmrocwFjng0eppBVBXH9yEjSEBkoS9qkRKysKzbtVe94ZUb+As+pSXtulCeKbLZHk20XzV/M6jpBNyp64plWzLxHgiuX8yHC6FXwe2ZQsvAp7xUIB8XkZwS1DpXwdFyOEzVWjDR1FL26w+qZDj8nxn9j+ORxZPtnmEMccFga3gmE3Ydst+5yDOu7N4Fd8g2UitFaOhFnOjOF/wwQmctAqLHdYtx6jRcXX0f89ALWkWWeNhui/IbZDIp9cxpOf4/MjJiTHE9ZOcZlKNtI7h4pwvWcjE0RjhrWXfTZDJUFh4jKqBNFfuSD6K5vxYNzkUv+bu4/9WyWN/mpbS5VfvVXi06++sJPq8J6qFfYZIYfI4mF63R3Im4nuMeAs9yLDdyK1tC50F1lhzgP4/TOGfJKrEP5a4pkTVd97zZm2KqMPqWmYKg8VHqLjSPWB6A2Sj8EAk3DH3giDWECGEwzFazzUKwxWja09i8WEJu3aKJ7UPLfsinRnj/792ytbi3ZO0ypoz65/jmO1Rg0ajheOTg4O9g+PtzaZaCIsLlFf4gS/djzUkk4kTH3uRucMARs6NitcLI2QL5wi1DQ/rxUe33ibdpJzZ/sPSTaZdges4xFTVNqdZ80W+7cN3i1d7m97cvRGWGvzohbeU40A2Ag9ePAoMNOMusmZTEqcVYhpQniSUP+FG6Dr2U4OUU4dmthGDtlmt+7CnYAoOrzkA4g/0qZYqBr3hF46WMUDTWOnKKV4MRG4d4ParkS07zO+7qTrg85tS/0WzbMejgXVLrlhuDbqOYLccOgqOQnCrF4GKxDBcdiTJm+oRgwPbHmt6BjJLGkfIN0XHLTO7HJV9dCoQn+9jiP3Dz6jNV/7dviwCfAgi7Nixv0trnotHvyHMxCxskXMng1u/5OX9dtGVKaKXMbiFS01XfhdAJj6uAKpEU0sibIT41lGzYldGSoSvHNZ9YiUyDUgUZMQGL10yGrc5fcwUOpjYsBhzPTbUR4/fBl5Varav+R+6iockjyO4gHumoUEe4ylA+43kWwCns5Ioax73U0GXSGVAZ6INTrJ0tGQie3VRJ8H7pqz75gCMY/k85a1e5rFdb2B+ANqWBvjv8mmWJ0Yf8z2SZiDUt0Vh7hRoy9scDdGcBl4lE+kAYu9hBQdaFF4qp6gAStatY3yM3ARiQ1qeqpNQ98MU3HI6uEsN/n/MY9//ucwhT9mqauJ+L9pMsK1DZHayBVViMaf5rFtidJSTdFNFPPqmu9iBT/IbZ02b+LzfKaGmP04GVkC/5cK+lXZhrEoLXOXNDWaIchghXiOrT3XpvuXofvwPlkQjeFYxAy2NpM4yZvI0Xha6Q+4dyzWO+pZw3zCV/ofpnI5M5DoCzrBCduXjNsXqz7X7y9TvHy4Hl3zctl0ZVWpQ9GLwfqO8qtic0se4vvuFKDBEgWwO7lCd/lOLE5d140jnjQzs3nkS3PozVHE5ivw+Rm4/O/L3YG7Kuuw5Jzkopiw6LPJdpzKJSh+aobqZfkOVjjdMPAQrmgcClhePA6iqq1yL384ZnXl4aI8c0DUgeWnzdtKdGQSTxw0XdcdM/330cezAkc3Ye/2kYO8dIns0MjZ2LxEoGcwpLBrB6MUtZZ2MYv3nDZ4lyFxp/H6kfmcwzwCMhyTCACkvRkWysXvP+hQfvjUvb3Ek62bTepqDjIS8UgZgz5eVzACYoTnsLvELEROKAtz9y9soqytPhsv4Om4t+BAL/cPXblf/SCOx4y7k7i+QVbMNko5su8gAHTvs0iCwvQ1gmHN9lb0NLNhJMjyoXwJ1fkdBYdJL0ux4Zb7cOV6S+nrr8MkKqw14U9Xl3fBZJAEUFvA745mNZxI/2gFs+j42R1pKMnFQPw6U5tvN7s0fZ/PNGLdUl02OFomxlITY0k1bKwAodk+FeIGwsBwgGgesVstomGTANxwUJGVGIlcSaONNMe8dLtlnwzzaY7vpf3Xu/Jn6WXJgues3pZzimrnjXzRCsB8SRt1K0l7xdBas8OY45us9c0Rk2gMT9CNq7j3maaEGlkhf3kkYnpR1wmFwuVfKBdULSUm7e/WfhGGFk8W/vZpff4v3fl/tOZfnP11/vTH/17gbpoq+ZxmfoX9sH34/cB+Kxsf8PUsS4jHR71r/jaXsfUSRF7zSVFNVmDynvHTujLEWt27uiT1mNBF1RyaLiz1gEuL198Fo7UYT4IGSld+9G3IrnRS5JVR2bZmSJLCrGZcWZrdrFYgYaObkfPYjdAd9AxxCciQJOd8J+YbYAbcQT7i+kjPgTHHDt+LN/knq/gpXq2xEcjG7DBNvOtrBE8fkHVvMNw5D4qBaHiT0DQEPw+6WXeYkweHoojxLL7gzwyXuDHxEb/lK8hCYYTv6/Z/NYAkToj9OR/drhkeSS3ie0Rbzrabj/sbx/tnG+s722/OINLz2f5bekgyBsdInb7cKPw/bK/ydVWwPF+P5Z1bv5sdVhYsRGelkL3MYWE81kO05BRUwadP4UYHq8F0mLuF6HG31GWX0RWesQ/5NDAY+iJycCgSMhQi9ojZ4JcMOWvcLWv5bce4lcRRQlueRnX4NY+/GtGPDpJ5LLsQ1W/514KwRFbJp7Kbcm+8291croOrnhGef3Ir7S5n7P3G5FYKPexNs9vvs322q+MiyAzmiMZKmMrgGYl60wHbmc1dORklk/yqe8NTNvAFll6IL+Nun3+5BbA5Js8xSCMRcaLnOxBuniRE/6znv0zsjnUYs4rnQJR3f2CqrCzBF9vBMhEJIljTGPVktYJOuiLp5sdmHB3VnqqbbVsZRNFbn5C0iUYeYuw1WPVbtqauXn4ftTvPGw6MrBzCcdGg3bx+UZj6N1quebQ8BrosxxGRlstyS2451tyQowCv9HNkX8/79elTXQTH/dOvp5TQEQ7wYsc+tvgczb+KVHWq5G+M/UcvX0afbXuqn+L0zatXnN7maIwg/bGeEsvL5lDwitvL0ObnbPGOPASwB8AuU19ZYpg5TUMGIbU6rA4gk+vfiEHjEKz77ZXoN/3EyAhF/I7bK5aPMSHk314B3nBKzYTt5nxBe9Zrdy46Zxv5XMTWNZg85+R4QCAcvc+d4y8ZmRZXz6eOTNGKvxbFL0ws/WnplKxmmBbQgc+sI89Zhz7TjsBGw7vC5km0yLpDfj43f7aXrN8rp+a0+gwDxcnKqDqJXr9+HS22nduFnBFhezq+9tS7gGKZoegiis4z0HaBS6tqnkbt5fbz5Vars/QCNoZzxgN6rMD/B190QD6ghlqdQKie/AE0PIdqFlus2DmvR74EcqvwQV3s0/fRUufF0ouVZ50Xy94OdUSPlh7eo+fLL549W158sch79DfWyL/9MZ1ZEp1ZeXBnOkut1gvWn9ZzOjw4Ouyz90eN0kqrYB1U6tji4ovlpZUXz553/qhR4o1pnQoOAcKLB1bwzlPBOSBWdhCqcyo4CoPqBaEWTwWngSszQailU8GBkHQ2lJKvjt6vtx0BiyGYstKf2s8WO8vPl9ovFufYVOwsdhYXl9rP5qLO8kpn8fliu9Vh358xqMXnz57PsT3v+fIiWzkdqhYkcxFsRI7IA3UaEg+8wKYL2e6E7QaLHab1d+/qz2XUo37qHiUrSQ1QYm2Q9IG1pyUZ/ZpTRO0FrKc2lJ1+etnJOQilQJaWLDtxgkrh3vsKZDahVwj9YMQEa3g3H73wZgOBTj/nfe60AumwgcMZDcq4ZP9KtItP6FP+sQTbB2zZCZsDiw32p7O8XCVQ8kY6HE8n8cHRn+t5DsHY4OaVNUnaSPtHmymjER52fDplg8iqlt/lbDydE4T6RAvhQc04ZWP+WQwkWQVFU8mdP/xuWQv/a/OG0pnhnT2cBCagvbkucx4nJTjoJt+iJTt7lBZ3FleWlr5Ki3EwfC3mVyRbVXDg1PxMBOUH9JbPQxgcZ23zNcLnDCwP+MZ2l/aLzlrk8T5R9MDBsBkA7yRKu5320rOl54yyzw3ugFsY72Z72drBDCGsZTMGvyjdaRXwKCS/3UakZwulXrkPGa/a5FXbfNUhrzrmq0XyatF8tUReLWmXGtY0rRBxZRBoz/YbJnY0HO3JmSRgbeC3aJnGZBOSszb2+ulTxd4+K8ZGWFkJMFMuqgM/rwhrQd0bShifiiDAvVgxe1S8TAKLhcydoiUT2hjVwul4NsXw1cGr+JaEgbAb7owXgLM9r15rgfPp3nR4HkMwypz1pNGcpEeTLBld1tsrjYZOM+HZiRgavhPdr30HpmBxV7Mp3ZCQKPQFmIq397aPt9d3INWEsLZQCDupDYB0XCTK3gzvF833TqBpBrJkgnzYOjza3t87290+2l0/3ngPIMteLG9Ojj7C2xXz7fH27tb+CbbumdUB4ScFr57bDT/b3T/cOttcP16H1y/M11u/vF8/ORJ9aluU29w/ebOzdbYOhMX3Ft1oBg98bxHt8HgDKXK4tb6JHWpbVHu7vWPRrG0R7ehoR3eN8dLvrrsZngBIC5+GBfvcdwsLkJRj4WI6GCysj5OFu7Q3Sc+64+TsajIcNH/NOYIjPLzYGl2/Z09B+MdsdwxJPOrn5DVOXkjrOsmmDFGmTuzy6ZjN3maz2c0up3AwkRvbkoyD8oqemeErcVZiB7AJBKG5Ms8LRPCTbr+P5+xwxhmzDapeS0dTWTiThWtzUR2vHxsnmyJqjBEbB5HBsTF8ynUvqq57gZtWcBzrrQyZYx+421fZIQriHRscfQ/dPfT/qEuwsfKXIvjl9fZKqBG4Clavu7lTAl3OzWokDD0Ga9rHYAr7w/zMVTBWQoKSdpZdunlAJx7uJ2+3n7ouyaof1CLf6eJMjYEwvxcJBA1kfwocUlxHFGvFseXS52G8WKm3DNkhPqiTSzvwu5mO0FGR5CdiS3hixneHCuBpc9IFH2nu2qjtrA5G6EQhQmx63VIvSQUiknqwCvhYz7EYhJWG00cgl734GecaKYISB/OH0BNuscj40Zyov+zuvNcPNWEJZDMdx6M6RCav4VIwXFctSDZlsqQf7yZDnq60BjvMwnjQTUZrcIaf5fHk1e08BB2Z78cXySju1/yYRkAetp90JzE/+wcLluVsgn7wpBAWOYIiKCS6hyUUGFBPMQNsp6VCj7svF1sWnhAmG0rNOSAzOgPW+WLnUxWEOQ8SQ+T0Htr4MZ9gJDieaWM4Rtd7rEyHuZYBFth0+qnm1PNdSZ1yuiPHoMd/Jv05HzwmR4I2/nt7NRhEYHJEXYWpkmvgnosvZ7DlaBFDCDKGSALzV7eQsUT5sm4WbgiBiGxkrjTzDmSEpAfvbHHGu0Ny2cbdC4UEw7jo+d2IrD4VmZC83mdLTUd4DIII16r9819dqITV+785pri33rDlMaAx6QTSUS/2PkRfK6ksScsmjNAv7w/rt4xoeuDmIpnibZolNL+bXpHc+0f4WczxRWC5dWAiL54SmAbJM3slg9nIB6JXzmPsgicqCgd/8sqLRV7C40RxgCycFlk9CNdMSElrD1YfpDEAdO1wO2GasQ0ADJjsrxmMjHHZk8Nt/qaJ+aPrC3XhcXb6dPWvC39daNQ//e2vC386ffqnxk/49fRpo/7XheaPjQUrZBlHZsa3glrlG259V78WjV9L5IoPabHnPe0bJMh4wyeCrrV2O38HVy9rqwZrEhOPPGFVrKrKwnxHzQh1nwZinMkZoAIDEPOscgCQ44j+MheDlHEE/Jqx+ZwO6+C8oSxcz0wlnf3YSW/AASp3gsZjtrD606fWDKiOAKyQ/A6s2zEZGoxMWeMR7bCNtSOwiiyjspyksQm+3lY3x1DUlDk0ruJbCMtvvUFPFNHuRmHn1jsz4cUTGNH0YsR5cjlie28GI8oab1CFj7R8xAZIfu3pNzAp8dl6x04CwLfD2dutmhRuuVwjn9S6OP1Ug5EG38naqW8OlBTmXcKiPYsneeE1uCZVWZEewo96JXB/T8cIWMMHJcCSzFhC/vDlzJbbkr2e2WiQVWOOEgyRLNfsdydd7xDAW6zeMEkygR0GY1Xth80L+E151fnKEmRGw2Bn55O0W+dt0XbLeycbN+eLmKkmR66QXNzVZVOMqJR/5wcJsAnQdDqUAf7dCfEp2TuUUqH3/k6jKMqWmCKA0BIO9o+4mpBwNQGijpLIo04pJqSJr++5alfb4PSYB/0BilbXICzBtXDIB+m5kCDfsK/1T8YYn85F/5yw6lfZBBxDoDb0EV1Ie5N4Ms9GqJvd1WgcOjEmqKSm2RD95KzXcDEAhFtrKmBDKlHWELA8lOVl7ZJfoI/ZqHwKWUC8CyCQOjqV/bygqAacy+msD0/D9zztq4L6kidbIDPdka9tL+zzFtYCN+RRwQhd131iyHZmzU/UPdRqGrvw6rrKSnR1cjahxPMrJmMLld3cBzKMyAgN5HnIZAIk9yIHNJnhKdaqNZhQmV+hPu0qw7ZuQlJt8UqI6rjmqLtc+TTsDq7iqgFpDAVHAfX1NVSQXkhxr3nq3vzz3rfhmHI+v5LHD3BsfvR5xNRyuN1t7kIYpWDNPOazgterkv7Y9SSswBHWDzWoMhDJnoQPXbPNJboQ2EfUL/TOsdWYUPfC6863+kDbVtKXFzdMX7BKdgc4MX3pQv1Tgyxe6+CqxFJhnd/BnSVo6k+M4K+IpDhJLtgTLaw3LBUWIQ7s/RaxQezr77vnuYWOATvofBe4zi6SLJ+sO5dz7JzOmkE51gbrNN8xNYD0L7lu9BOdo557exJu1UjKFzZzVGeI0AOFv+HeOwuYSMi9Rnft69X/T3XdnQdlkEeHwlyxm18yiUAShK17tLD1VGwDQybQeV88wSwEH9I98ca01R06zu6gTx4TqNgjjP2zdLsIWKRMLN6z75D5p2CrkfHnwZGPzfXwflO+fZtruWi146ZkChVkG3v9Cny2bKzSQH4kNjJHKuHPZWas6tXBrikNzEc+q/NRkbWZWpyP1B671GqDrcJ82PGXLpjg9CjamOUnI1Cv0iz5R9wX4W2d6R0eDHdALPmITSUhzK1fMll0h5EpqzdmbLyUwYyGa/Hty5obsLwbgQDYjrje78d9f7sp43eYkr9IFPUGcTeTvCpces1buJqVuGyYZKoXsEGAZVwEb4n79eCd3/LBkle1jbEKDJHvqX82Fa65xfJhwR0bL3w0Ar2pOrdFwCBEFznN0rKt4ZtrN0sgeM0HoDfNMiYB+HtBNmAUokUAAR7Krah+rtPTCuZEwxuPQ3ZkdWHW6bnGFJi+vnMQTwHRC9ury4Bx46tWYADhA7Lw7jUje3ss1ma0jgoTawXSRN172V6ZLs/4aZcZ1sgZHS3j2vK9IddrfFZkovuqJ2DaodpAJAOsaCOBOPFUBpN+fM0joKhDqUlvDBaMLzlIH2fxRXLrGFlp4pH5dmPtQUfvjrB15TtoEy146unfFx2TO1KQe0i9ZoGL6FfcNYikbHZyw1tizAxC0J2dLruaNCRirZked2KJeUKXubWJnNso6G8VnNujUiqybFsjs1Z2tG4lf3bt0KVH7X79VbMXqMHnmOpOlRmG886XwbxpZzD3EBPYGKdlGcG87b93PGT4uqd6Fo0TABTspcNhOtp0NDFLRDs0c4r71KRm9zzNjJx/yj/B8bhzXQqoFx9WAo27kQ+RKXuy1YkQlWJMFA4FKsIUcagmt0+LMal1wb3oHN2L6AG/inrJYMR3esoPeb3xLJNfcIegIBa3FC6VvexuPEmbPnjluxFwLhUOKcq3VGYAcYj2Vqaw93thgIOWzwUDn68ZsT66/WQUYw4tWVsTfGy395hgeiaMQrTEsNtj8n1mFdld31jf3DwMlEnGniLbBwUl8uk5o8VuN/9MixydvNnbOt5dP/qzr0wmb/LojuyfHG8d+mBBQGLC4ebeEYXfODk83No7Zk/9vWBS/0VyaXZiY3/v7fY7H/w4S4Zs1ll1HBxu764ffgzUkcdsMPtuqaMtVs9muNyIMXl0u6SF9o4PjrYOP/gpAMcbB2xOMcg+LXTCihysHx39vH+46SvX7Q+Tka/g+ubu9l5RSWDVBzzbmCoEvBR2Gx+8yOELSclpkc2tt+snO8cH6++2vKWElya6ftFi20cb+4wW6+CG7il3c3PzM3iF9NPLTRH6SpX9mf0Dbvab++82t3bWP3pnlDAxnmDSMj2l1nd23qxv/PnkcKeo1C73IvAU3N1im/RmUdmtUS+FQKi+0lt7G/tsLb8rKr+h4/r6UGwcbm2yRbG9vnNUhAXyGjMUDu0kGnFtopR+R72rWKbTsnEcbbzf2jzxj5+iZDIKtoFN0NL6d7u34fLrvwTLj9N4gzMVY7Xvbwmm4itzDTuDtE1rXm+5qGl2vLn/857W6ayXW79sHx0D02h7X+9s7/0Zr1Z0/K/X9872/wzRJLyv2QLgr5e8r0XfSPQRBHB3BSUSidOGo+NDNjtJEWdXKC3hbgqlRcx9oRTc3RYqdMPcF0oLuNtCecc9e0JpIWdPKC3h2xBKC3k3g9JS9m5gFzjZludSIiubsxOUVmFsA28ZT9uyFpQBcHx4smWtKN8+Ys/70H5R0h/PXlE+N81tAlxNrA5ZEO+2jq0e2SjwWlgnDBDotLPlvN0/3A20RcHAiXegOQbM2frh4frHQLsU5MbRB4uDOSA85Be/9LVUWuveCfRguQhua3d/b2P3CG/pFoCt/+XkEKbSsyKg7b23Oye/bL6JVPQeP9zu/zuGMXpRqaNn//sXTuPCgTg4PH4HQO0q7Tv70MGIRsWwhbPEI1VUnus+UaLi0rIliOrryxIdKtZnSwwlxVxxoaTAGeqFexi1UyWMrDnJ39cnk6zOnauYzKE0w5sEg3XT4JkQthXSzCvFsLZqRVqlKiND5iTEbK8ZiLS+6GAyVMkKqJQa6WCiCmYFRFq7dDAZimcFVFzpdIkkddEKKLQu6qAx1NRKFOIqqodASnetgEZrrg4iQ6mtQmqi0LrENrXdCuiUnuvgohpwBURU/XVwWbpxBXSGVuzgs3XmCgilsuzgIlp0BTREh3Ywmfp1FWREtXaxmXp3BXS2xu2g9KjkVZaTVsTd9WQo6TMg4/p5EJ9S32dAKdX2IFKi18+AlmjzQcymxj8DcqrkB7FbloAZ0EvdP4iaGAdmGTxhEggPn7YZzIJWWArCaLUpoQrTVQYEl+lS20IBKiO4Bdp9myERwDwnuIwnel+vUzu7CNZEM470umwUtm7HCQ8TDDEgg65vprMvOTSF27v0nodgRhuA+0N3kPSTyV1D3TbjMJ6EntKDscR0bQeE1S6lqtfFaW+AQFpcmZVCbjqSr0+JkEU+TArdv3JaKIHrW54sgROIMIVUr8sJpOXIb5lCoQOXMIl0v8tpxIXkb5rdeA6YCngN9recLlrq/5ZpEzpMC9NH97sKA+IKzbfNf3yHh0Xsh/e5mDo5pc4oviEKv6DR5EzJEPIXq0O41IsSRh1GCqR4gqKE1jXnFBaPVKH1xW95pEKHtuGx0v0uHy1Co684XkSpLxwxqpR/03tX8Mi8YPcifS8fN4NSX3HkDBtK4dgpI8i3PHABt4XwqKlelw+ZJtBXHC9tpCocLGpl+pbHK+wxEh4y2vfyUTMoVTZwwmmc/dbpp9CE/n796P3Zm5O3Z0fbf9kqTTDkXIibi2rKhDdJ02iQji4jHgIBa5vz36Oz4k4+eFIZBsvCeWVYG7/liVXgURSeWUbvy6eWSaz/0LllWq8LJ5c0P3/L88rvdBaeUrLP5bNJUecr7i7qZKBwnIhx/1seqqCzX3i0SM/LB4yS6SuOGT2GKR42coryTY9b0NuyYOBI3yuMHKXU1xw6euhVOHb2cdW3PH7FHq/hMbRpUD6ODtW+4lg6J46F40kOC79pO1zIA7nAEKd7Xj6AlExfcezosW6lYeNnsv8OI+dzAS8fPN7/6uMn6PU7DKE4TK80ivIQ/N9hHP3O+OUjKWlQfSwV1X6H0VR+DJXGk7ge/DsMafByRPmoEkpUH1hKvt9hbKkzSXB4JTCk2B7VZbhFnsUJFMpKLZTFVDDJsU+F//LG0rlIHVX+HSZj+IpN+WyktKg+HQ0K/g7z0fA/qjTG0mPo32F8/defysdW0qD6uCqq/Q5jqpy+qkl1wlXr30Ku815HqyDZCRrMINtJqv0e0p30tqs2nsJH7t9iPL3XAyuMp6DBDOMpqfZ7jKd0cyw+51cuit/0OX/gumbBOb/qd2j0IBhG0oveJqO+qKZOr+cDldLzX3npFMNSqdv9zTMo9TZLh9ixurrgYdzkFzF9Mfc4hKNQ/ePYMGaFrBmOEYzCEa1tvd8/Tr1VYSgVXwo10XR/R7dHMp/WXW9ya4YlmKHfNpovJwNpzqOTQUbc4RE4P9ArvnW5pigRjMMlCQBT1+wFn/yklSfjfncSG/ghiZcId0XCwloBVmZERKO/3pffXZYdCHcJYtuQlZzk+6NBMorpYucMS57nXcfZJMnjPraQBup+UkdAyIxhxJGi7CwZXaefzc7VNf+z1zWOZcscyRCKaexEWPYTxRnKSXYXaK2vvBgHXqNqNiM03t1yU2/oGDmD9LJe27rtxWNktMkoMvCvskkd24Qw5wr3IS+gwFop+Zhit/l+4wCiCHMRHn1ocV5x8U85jO7EI/34EH0lrQArhFSGl1sNakCt0awFlMkFeCz2Pp6Qgm0t/bq3+kZDlbDa4e1TdzpJ67M10UV0hFxz+6CunIvnotykSTYTLY6O14+3N5Aa+lpcmBB5gACZr+NjKHyV5kYKbxGsn08F8cOMkHYm83XVa4ChObmd/ARYMLQvojM2z0DKAYHajn+eJZeXkApCzMtiMlnGTvLWZzpueHz14ixJ+0lvw9aUEta4DI/q04sLBlmtHap4LcbMcjhqAhMMxVP/oIkqdANHbHeU/MKSvyBalBs/S7yQu0Dduk06J4Mom/urKEVCXD0R91OlcGU6PuhIFjwW5O3k7Oom6bvNYdTfY2/fd7P+TTeLt/tug2TdIoUcdchQaAWnDTXCFve8oopu2ZxuccMRcrLcS3DaR5V1i/UOC5DuKcHisTtSr9RmU6QKdQDe/e4dsKU9uz+Qq9e97qNDo3he0tAontc0NIrvNQmN4nlNQ6OE7yHJVMHh6zmhq+jh6yqlJaqHRgncaCgFrx4aJej1XlqgemiUQt/f0kKVQ6MUej6WFpopNErQZ8kfF6DIb6a0ilBoFD+ADo1S6PRhz/vZQqMUHWKXz81QaJQQhAqNEkQhQ6OUHNHanS4IjRKG0aFRimFoaJQwpAqNEgaxQqOU1KpCo4ThjNAoYTASGqXoyJSGRgnD6dAoFTpKQ6OEwUlolPL26dAopce/oVkyQ2iUSkdAFZdW1dAopWbsivVVC41SYJrzFwhE1oTEY7mKq8nTJvd4NAYeWtMOpAmBRH8l6YrEVQMRaaVmBG1M/hFbgY7OellPP4I6Qf3hdg2S5UdVsubWIQo04aenNvkafroVy7fsl+eWCMNo60m6as+NIFaFH15Wbtn2s54fXLVGRoeFcci/XnRTHHSZMZRX1ny7vbPFtqkTf0S+iyyOj8ZdzGQpCxxubR0drG9slUbwk72x4ve5NZYE9XFqnCkIELbiMUIAaeo5AQkMwlaIbaDI6mIiBP9akQ10a7/Fs4niaRs+mdC9Lr9Nq0bhGyaQf5kW0Ef2ucLBDVbx8GMbviRnPq3gtVY/sqHVzHhgg0W/1nHNF3W/+lHNrN3/TzyoURvu/x3TmCR56CENn6Tf9hEN5NTYSIfD7qhf7/FPOu+n0gt8ilGzalKUTkc/ddGCL8oEXQqU9V8G5tdVX6TZsMv2H9MZFHCvudvQrzyvpGFK1y2vcVw1dZagWD0QGsqCGfPsc8wzA89BjMOcWi+f1LEM62H6mc5UzyU+Moo6K41oAFuIjEB9mfnNhPKNhrvLuRv0ANb5uDthjGoUphSMDECyjn86NQhInpRQsZ9k31+84h6YvDpejOB2iYoZFepEk2FVyhuSSgvSmToTmOgSISV03hxP86u6Yv9cR6tL0E9JctrwkdARaqDE1i0QTWacnolqMB1kQdUPI4iTqBiZLm1QZeqqdj2EvLJ9UELfRHWbZye7tFtNMoXINcpG/YrSq2g9K1jrVHNsvJ2Th4IFKINF7M16mF7HThsfzjP68UDP9isyHn8A+5iOMHbiJBXdxDnxGGwETlD4PvV/R4NlB1JCmXBF4urHgi6pKx8KchH2MTtQr9DWRzgMfPyGVzkGDKnGAVNiQFGsYEdEG1R3NFEWRPXAsB8KyjICRefTZND/EGc5rCCL8dXazXarudx+0XpRswYFivbj66QXH/WYfjr6OelPruzyOb5q3sC76EeZdogXO0hu48EhKOclmN/HyeXVJID6Cl/OhDvJD67SUbyfHQMXcxBrCvLqNw+22Y71YgXUDHRsGHZv6xrIocFc5H/Ju9GIFrw1vBRByq229rpj1qj4KPlHfJAOkt5duLVnyjhhFbHQ5l60hv5RASk3gk1j39gxqm4wmM9vwBkkPxmL5bEbj6alzd8sKOzpSGFdxX0qqqmgd2z0D9KE4TmIs3dZd3wFWdXj8mHZ9ZbzdClQgaMg4gNIhtySDKtqpbJ3KhlyQRc3u5MuU/0u4+wB/bQKl3TWrirc4/l2tS5bGCv0G0pwUR7KH8WjPM0q9dlX0N9fbxUPHV0fsrJuisXvZdjBlY/QYU7CkYV6UdQJir9g2Yl6/HtBECsHDzdboPuCdnMM5Q1nPL5yqxlsuMmA6Avau4mH5iWNBaG4cmtpDle3uYiq2uYikh6G2nYZj+KsO3jLuPTb7jAZFGyFGqYYz5HnuNDEckSODV0c8HYjjS/KcbBd37u/51IAqCCF+NoxTdiLt108cgxiYCAXCFKC4eduvn/NtKKkH48qYFOwJWi3PVjRSo0iqcLLim2k6WfG+I26OI4/x3dEZL/OA7I6MXJgDawCPHh7y3R2tsxzioMuF8cI4TM/BLonO4cWza/dwcCgPqy712uzzZdU9PQdnXXyoTQqE64kX4HkPGGLO70QG9MTsD1MR2z5J6O4XyPHuaoNeQmxRHXNSSp8jhtz0eLKcst/QDEL3tqIKQc1E5s7Aw6noxGrdn+0PupnadIPr5ckFyCeefQzKi1vur3Pl+guvZEO3IVc+6+LFvxbCyNg+3/slmuPb6OcSev96L+et+DfMIaDbt+IXSFQdIIFtkeMA/J6/Y2O/mu9Bf/WSlCU9n0d/q1VaUgBAbjxXw6JvwvBKt7H3X6FlrZazzq9bq0Ejb/wzVUyicuKlg9ztSb4hahOq6RYaMd8zrRv7463UgHhF23lw2k+2biKe5/fphk/ciyQWnoGoE82d7EFBK0nr8KIfczMAqFCjgkY99k0QMuiYQ63us2hCrrKATxdFCWdbjlloYsGVOTit7sB+bEhblzz6Cq9Oepex4fxkI12nDnHe6RVECcBl8T7JGcc+K4+SvuGtRx+o6sS++RXX66SQT9/c7fNUN/KVN76xAZPcdjHS15SnDmwJ0+f6r5IxB2BOP+UnMpuKEcj8by5Z3gcSUchbDRxErLPYfWdowEs2wtRU6cJTkDJ+XTCkNeQMLXTNX8pMPdhNU3wWBD7nMTXMAvxUYRCT0zBQbUaXm6xgWPo1vuchx2nkur41sxELw+Fz7oNo1v3zkE3GU62ofepNAt94SqHcI9ijG4QR/UnQ0C+yyZSt16rM614Hi3jUzDjryK3ZqXI5g43jPrjpFFrNLFknOtGcfxoRHtpemFB7V3xjinDbS0qnfOnRpvOo3kGzcDMeTJOrlNQ8M5ZG7oEDad5aT+weMWeRNguLKHP5g1BJsL+mBDuAcs548h1jwQS/RQyk0arrNtrnqXJVbODbtYd5tXX5h76bVpLE6DQ9S8Z8ZJF61ECq7Uh/Fo0u6Hr1L9Ej7sZa5SxRmHIxKqTzaArsmEtYMrChZKKOGFlctML8Lc4a27Qt80LvVwLwObCDMFcieT7eRZ3P6/Z/WSy9SP10quR+/vA3pV3lAE9WjdBqvgq3TSs2t5+vEV/iby0vwLu0bp8qJjJ43S8R41AqCpujyb1R2osmvAetZ2GUfArtJgLwo/aZGUPfOy2vk0H/Th7XGbGcVaVTIJNvA8Jdifb/wIbR/k+8QH8AXvdwWbWvfxLmg6/hMgf8ZileW2h3EKPiX4RqZmMcDIew/3wHNQYMJHAzbXaTLNEHWqRw6zHmTP94uOyr9Ot4Mwy9bRvYpaZOuBjLWRbsfy60yu5HKVZ/AY8Bh6pAwRjJaZpdqPxZbNoNx4y5eckZ0rrNzGF/EfDXzISSqqefceiwzgsPGc2S4HchK+b9KgWn+S+EqWTMnCm+oeRxTq+tVBbZCs6wF2zCm5MmbI+/MiBmubpr7/M/Yx0DJ2c/4tNscC5vlnUodYOliigVymFuNYMNxnk5Z9/hUlWPMfO3EaH5hf3gYwnm04JYcFrTq7gDO8BcyzIgusJ+wPj6eO68t2jcN4vYbwneXxy9KZssKvteFPEJfeUr7VTo30vN1qs2+A3uq6V4uRaQxFS11xUivVkuwChqUGU40IxqLDbQcGxFDmRFgoqCMgU5U3P4w9JNpl2B++n54820zTKrz3hWBUm3XNkvPlud8RIkSFtGAxeAyumyH3o3GPjcOPYSDdjHV30sh6+t03gnrMgAblme6QoFOa9lJ6+He+BQC4E70b88GEUvYw6yyvsCz1zgMvuI9lHVeQzL/KZFXnOPmgBXqQXfR+1o5+ixRfPn3dedBafL0V/Yw9fgyE6WpXfTNp5u/RpdAroPP74AcIQ6rPHix2IASBbZ1FCY5BjZBAM+shaPd+26EUOaxhu/1ENLw5/oaPPofOyQ3V4+jcs2rvqZhtsVq2zDaXRYCTrLC+feroqisy3G4iu5Z6RSe8AcbkDl8hcFN/2u3c53aP64vLnJp468qr64F5wnLD9qQ9bFn4Dgz8vHf0YdZbYn5WW/NOOFxt6ksVwWRn3vZr4itc9+rA8jzfk+YGoKe1Nh/Fo0uxhc4FCMiY9v+jGZQP2c62GDeCo4TdcH3m14Dkjpj03dmN+XZ9UoNvcZ9JUP+5vyFbw3yeH2xvpcJyOIMiu1VTS4V5XlRAYmvl4wGQC1uiCc71eN3yoh3OlS07zxNlOD2cImx0tzt+imrPOmjnjYJzI7Ya9npDTNOE083b/QsQgeGVJ93I1EUTkVhabS+Jb0VVRedmAjMwvuzt/n6YTCMFhu8BPmlk8HsBl+NoPtbmo9n13nOaMdurxD7Uf4DGUX6vZ5zvv4gnDzYMxTvktefvaDaPLDy85xOu/jqLoJReEuPj4qvYDmw51V7T5SewfjD3VMDpTDRbBD7UFhYNsS2FUBKgEI+w97NsP+kLU01f2/sMm+C9DQIYXFBsGaI3hWBBIas4bLkrpV945SU5Xe0Sy8s9UTlm+IH+AB7wOSosQQjiQNg4TORF+sPIrql7ZjSfviKTivOetCqj1vJmRaGexDaCgsXZVXlU4WJcPeobKgrpkeeesElUr9ehh/ro8Glt5HTjYRSOKM5mL54HRFkebgUYZ55+qPYU9xuNDPzriHVwNF7oUFeLSp3jVMOqztWK8jiNCGKU4T/GjU3w8dA5TjJufhRW2FEGqtlUcVBUi5DAVJ19ocsFLoZcFJp5lxFZGEWdTsABhV8hAK4JdATx1a8VdprZmsxK/Qbpix0Odw45vB/psnzkZA1EvOUWateO+UyGzwornPNUr5pRxe1+DLUnIEzV/PJv7te/8vrkwWh8hRtqHJGeCQfIPlFmWfo7PFVSNltV+L0xU714nl13YTSF/0/olCKSTdCe9kWqvEu5qXV6Ide01RgTwXdejKo/yeaKg2m8RWr2eJRBv+X08uI5hROeivDvK51lLkoua1V3ues3l4Q9iks7kRF7kqm/g8lb2REYF88D5S2vk339P/c+LK2qA4ZJNqBkKrBpe1cYlToaIBJ1utwyXVD1sC1H9xQooXs1OA25iMsBVUJ497qsQGtHAQrziH+4wcwBxCUsvQbVbnaUCMOVjUALHJ+qzVgFIddeXP8fx2IcoeMWwVQbtWvFDRQKHJD7wklud4kKHzxzLXW4LzGdu2Vl8wo5TuNTtK668MGo187V9tuu00Dw8tcnhMfsvrrRMKOXJ6+mcNu9whmDcM+falVSuxF1zTid/lMqr6Tn3Bhtn6SRlKs0cZtLTyfeYgjyIu9mB+tnF7AvjNJvMYcyLORFtAhplxbqMJ95wl8MUIta7cQ4hmFHS8xYZZ4xu6TQ/OdwJvkvPL6Z5j41J3wclOsrD3NLCvNsOPFDBrUpQwXkBRHGhGY2ch0gsMYDanVyiRz5jBQed8GnWMrxiF/7214WFJpNvMKrPFQkXIpDARzNnSy5WdpN7A8FfF/67KoLWHJjm3MhgmqbiW4Cy8quHvvDhoRl8BAhvTEfcqcTXJ0A59oBN9+bWqJfdjaFrctrCU5hfo4278VWsEMD2VQPByUwXaYwqfHiGCT6CI8vvVemVEb0yL1exdsLos4o1jGUI2ox5HxibYZKJt+3a3g5AIkSaaV6Xk0kCyWg//xMtBSDREXt6ccFd0OKb6ITtDO2VdYwhRFG8fh11CgyCHIff1MLffUpO6SEr4uYzLmF7/NJchB9MlF1qzEXtlYbtRI6sOJ8OwQ2cI2ydetrT9rQnmsfHhklbYvvbK90+WiVaGyXQEwXk4D0tIKywJNcqko2h63isVE9lNjZ0fd0QVva6bDWjWPuUW9ujv/lmjmGYZ1PBByKsogyBoi3kFlFo3dpaS88b6InfBpf/ugPQfvaigwDPG77yi51nKwLBsh9B5/nKM46h3SkL4yUWkWQEj7OIjKWBiFMQ/Q+ZbpIOURzGrLrBFfM0Uu32DT0BDawXTolXkU2ZleXO81b0G8dgnLr8+04AOv7Bpfg4rCGMPsQrHrDW/eu8Xmu1WnBYpKrR9g/GEhuCYc4vNczz4kqrI+arQw553dhb7Ytsxr77Smy2uHfSHdeSFkPbrmwISOhCePCH/CaSBTacwBs34WyJxIhXALVIIcRfDRVRZD2qhKciIt04NYFM469FSjuyBoT0YBfCkYNZjFfcVyPm7wyRZWRVblFfr7SY5dRtDGxxve7skLKMCVc+PXKn4gqtdqu357m++Sh7BzKev1NS+pPNQUhPK4Sw6M47JsoGyCWEXDXfANLXPy4TO5iVwOlHr17TOnQZT0VUgnX70XXj0mh52OhH1w46Y8jNDuaNdDSKMVQg5LILZQqYkOvBZqnNOO9lydg4KZXOY6SwFZ6+vWofEdckSiZXNWtGAPqOA1y3VVapftjPV01tGG8aRvt/NvEvhhuTjkRA2EgVESYYt8xeitn0oFzcl12wXHbYeoB7q78MB5i6z/KsdtTkAWGEsJvd5IY061Nm0TNKlkHnKFER9Y+SyqZG7QJ90liI14+lmWNt8KykJlHMVwuWJjV41HzeJ/G8rE+6uLdPEgut0TQV8NrYs7KaeDFvLVDa6JNhWxD9mVyV9gWL+fvBSpMaLBsI1gDPSmoQxXw1YGkSUbem5lsJTjovfYg1nhIvO+n/wWR6tm6qWMvQYhe0kqGRzAxJK9a54eMRZ9kwv5Rx7LcgIupurryMTLuQvD6dXoJNuIkBwcdZLMPSw3kr3nhWSSoNO5m6rIERaFWsgCzu9tPR4I4ErrpIeAWMBsimmdY5uox5MFXiPcRjfKvKwCp5kg3qpBYRlh68mg90O4G8rOyc6HtDRn89cxI3GD399OQ0mqW3yH0FP62jDxZW1wRys1eNmnIDMqm8aD722yOrWiSt2+M+lCpmehnOUEdtw8WXja2erptJ3rNmrI6Lb/TB1aM9M/Vk5B86f39Fr8gM0uVhAjmtaDyuEdmyxT4SXbMsYTJRPRlDkNoJ93DkNnJusTBc/8yGGLZsbW8X37xGd/4lZHZX39fCtQW6TUOSVGAW95b0Hed5uQCONw7SUZ4OYuQqhGcCpyHMR2tobFmvLizomaXNuWTiwkb6hM5YjU5+AzxkfioLtQxKxsFkS4mTgtsnuxu0e4pjevtGd1ern4Hm+6lhY0HpiGNQ4+gjganHWi0xLPE60kmYlA9VDYNY/1SjfC/cgceeA8DPCwstsX+kIcgH4I4InspUGAuU0AiG+4JJKebdKL5lakVgkj3m/PKShakQGuIbHCKTtKa7CiW0LXn8ey/n/4J/av+Si9NcUxWwkM1CH/L5VxRTo/HohQ7vHnuwk4zwFBucoKOKg0zKqa9Pox8k8KuQ56KJk7t+RT8UTIni+gCwpC4ACdXjnzahvgngsr4pkzStM4ATpk8JPgAJtt+ZaaG2M8DiegAiTCZ7KgZJNLkqJQ9sFXY9TyyjXkk9Cu6V8OWPfjAmPoGtLbyuKafAwD4Nk//p6x9/+fTTWXL133vPbtaf3Nd41k64gNPn7kLKk87rnAKXeADYCmLK+yVfQsgw8dVJrOmzNkpgv7BJUckS10YIWQOcYBcpSdcH3Wx4FE/AipgHe4ZejXNRejMC68HtcNAnd2150hiAsJLCbqSjfoIWQfP5UTrNenYGWUla+mwzHnTB4ai9bGDFXDYDwbGowsPaPsEO0VtVLapUyWbiJ3k+7mYxJvfELpLJzx0jRI/DIWfR3MP7hbYeUcBj67FpoNwJ3CKfJEZ9bRvrUXStVhUdhsLaNF6rwg/q2mhpZR/oVXTukOmr6oN1HZ33a9iv2iM6BbxdGfZ12CFEjnOpGno57QqJxfGd+uNRbt3GPQYm0y7lOIxzkZFsTixXtiODv5+9Xn94yScynwGcoZKJYzuVR2rsCKh65kB/0FeE9Ki5OIdio3sHgcqT3kGWjsGXPM6bMZMUxzEY5e0BEWWRPKQG/B10hRdHMarB4MTLvxlMhs5kBUFYny7v434bdglWI6emGCCjLrVA+TtSiyjjq+LIgGX4eThvdzv4EGD3H4K8+4MR0B7CKzCChkLLvtRRujEDFwSdgDkNwWmj8zjqRuM0Z7S4Frdhah6mazeNV+hrGr4xhlHNBk/XzcVr10LL+gdRvZel0MepPqQibVdsAlYk9yzu8vRo1EEmz3r6B9nm19yDuSNjmrgHczneMq7tbu+RW++m5DBEY8owGYmR1nDG7XX7FE9iXv+lDHP3thizcxgnUK9/eFeCunsdZ93LuAj9vUuzDXslB88D14LHnXLUXpMWwmSnrXxNlgmNWiungj7vKyU2qfBVUY2vvrDKRV+VRTW++tIal3w1viyq8uWXVrnsrbKoxodWeE8iv9x47tWjkoFYfGZ+TOKW3pAb9/OWUElevYRL99GPhP15Tw6Au8htpLa+s364iycGdSKKPo3aDbItukcOAgGcA6UjfeDABVZcl1c6L13DNAcQoIssiRnbFHFvEB2eJxHKm7uzGKywgKAPn6CfQuKRFh+LTUfkvfimL53/99HW3tH+4Yf1nZOt/67NBZrUKMfz/ufN7c3/lhkkAxSqgGdvfXfLh8akYQVEJ3vbxz5EUwhZVAXBxv7e5vbx9v4eYOEjUqHU5vrx+vHHA+wD4+4VShwfbr97t3Wo2voA4u/t/wzF5dSFyybHsjxbVxIFDW+uMm4KbA11DOhJJW0cw4XXEs5siAXBp7dsMUxXhnSax/2oO4pilYEaLXBxcxjncN/ZvTRgqJTpjaE7g9zOw4G9gQtj3ewuqEAzvQCO1vNJOnZOxtAnomUeYKVj9xkHxE8PMHxQKwDCBX2TtCcXh03HIVCJVfR5N84uYy4HHcIZ2cw9JgiOPH03XjtU8BS26eEicPpgxHQLd2Au4mebHG4n7XUH/NKp0R9Yy87B60UW/30aj/A+nPFGx3XXrhDS7gU30+BU2RBb+ct0JMRl+804iyGR8GbqfVvwqq/m7tu4C/fHPDC9i8uNq8u9dJJcJD28JZsfTcdgJaSXvRQ4KBeH2BxOJl9H5Omr79148I+N7qgXD/SVvh2GLEAS1vM+1MWU0h5bvNv5m2nuRVsFCFb5O9QfebtbxpDBwMR9vtoR1yWc/haAuXfFoBFvuRuHf5h4z72vLyD57A7T1QA1CCBs6g/tlYFAmnAhMOhoERr5Xmm/xuyF5QH8lLXlTbcfwnE5SM+7gxJyMQ1IUErGv+I1TDPfYxGpw36MXhDxza4fl3i74Ucpy/oxnyHfv76UGtDedHgeZ8297p4NtCtUuWIgoZWFgPRqRLZ2GHPqWjTDfSi3mwq7Yn6c4jK9s1/mksfl5OHVTX9POF5YnhNSwhnZr0E6DmQT0wAOo1Qh1IzoSpapWN6NgriM7KmDJJyuJRBEB0H9lxSEegA8H6FIiCehATQ5ZUBeB2rXzMB4fI6CvQHf8tZgf4xAdGS0PuHbU6GOGNZ2aVUHaLbXGBjw1dOn+pE/XwpPRAzTZX80uAv5VQuW+9tv0RO6nXhSIZm3pG18ZizUMxPYkyfIwmaYggpxFeRvtCOwlrfRAPe30sRY0s5gAFh5kE5Zh8fpjBPfzhnoMB3zMMtgGrSiXWXvmbUiWbJqRcpkNXNFomRJRcq9lK35991cumAZwlaJRGJdUPYIJPYVZiVY6RfcW0/s6bpwveG8ZtynF8uMYYY10uEOohPiMjPhD/J21suI6DCGp6WAG0/zq7rLQ1xUnKE0XLc1hNpgmopfLTCQEGuuKCYt64Jp+Q30RazRZYrNgMl/zWmzUXnlGt3eyYrNswK7s8LAL3rqORuYvZvmOYPdQVrh4/ROnlHYXeNLWPTMtc3P3jF6wGF3i1T2OL0ipmfaKX4y8YidomcrdqdIZY/TKXGu4q44fRDyiF1zz2bc1WZV/FjrjRzsyDrfueefNGak0NC3N8lBosfi+UNNB47ySYSyHGWABbEUjfafNukZrR0fURapvVzgbQ3Ho0ICs/4aSpHf29arPxk+t16N0IvMD+og82iOYXQeYFtaKG+YA2XKAcKwcbaZ/pxmn+vd7NK+0OpX//U+Tg2GhtoDfncSPxgX0LMDAhOgQZHV1ESbkmXtjiYpeZ+Ordf1fjyYdF9xm6SEgVSAEh1Y+d8mt0yiWTSt5z7rAREyuAaH054C1RXiOdUkj4m1zIJhCDsaCk0Su2kWV7XIugQGDNGQofCaXUusrkETQmF/9GnEMO7mU75AQz0EggobgHFR6avYFAbSILtt6r7i8hTyJPPpsHuL96jkqzZ5B0vnmD2TkbBBEi/WpyBI2vffK7KoiCjFapiU6I2W2zjmy9VCiytrdJw9Wxg98ZgnpF7Bks/iEZpITo436oYX0QTOZdXiwKThcIip1gjR5z3jrcVs2+uvzhaa3QZ9jE9zCHkmymxozYP2EGpB5xlbrNRFipbT7aWYWIxkak6+NCeiaQ0pYgCUwbKtGrKcr7L2sybmaDK8TOHNebf3GVyy4Dk/28TNFL7xtjBmGmoLBLSQl+Zrc9HFNJtcxVmUJ8OE7d3QhTTLo5t0hB4vuF/1mzUz2ZPEbVha+G03TpNXr746UfrT8QCU2ZhQR9Hi9++9tpQJLuNNEauUf2ueK8Zipb/tSt5twn9qnTZNb1idWNcHXlAlhDdxcVWRAdjeZIkAga3/3H4uNn3c8zHvb3CTDzFp05gk2LTmXnZweOT+ST4p3deSa0YJNORPshjSh5CBpzZYQEbjyBhAk5TJedrQ1dJvhR2DYxGtNqBflhnOLLsqLftUdg4aRzSIsyy9kdK7bWwNG9D9qJC8zv6hLK/z894VIWzHLiFGUsuwdhNBWaCO+/bTSE9YWT7QD5NaI/+CRfu1ufRCuxwkSOCB8kYw7C49rTVWFV7uSWH4ew8zoSeZZ5DygRGaLSGQ+aVSANFx8WRXnLQncV43+0T1x/AZs/OWHjErpjY0h8/IjSVG3KniZeQrCrFszUEnHE/6rIkyn2ycGpKOqA2lJ4OkrdtBu8xaQWdYgap98c92gxMrLzlvJ9NxhT6mY7uL93awA9srwRmeORulmln+eWfbuG2tIHwQVrj/r+JOw3VnKgz0ZOXca6WAlQAWxgfzSG0tgTYGt2J0VxDKvLuoPJgaa8bhXR5rZSCZNENTi+d1gU5JFcYGRv24AIN1TmxMSRXok7SnAefTTJDy9WHOV5z25SltbMOMqqAPpenP6m0QXHTOV7xqG/QJOP05Ax14gTlf8QptCJrVjNPn0KGrmqIGNITTTPCKWA/u2FxC2Oefkz7bnj0bmF2yyQWLvfgGOvJmkPY+1/lBqmdGeR8WrzPGxOYiRlewJ5VsX3h8Lea4McL6KEUmGQMgYzdRlBFlPvWkcO9uE47FzNFlfd4dZdjX/Ci0Awg8kbxKqyg1H0cu4X1cpiUcULC/WuMhjj22eZCklVSmTemG5T8ZV69N0+MUT/TewksoqqCO0yM9NXVkGGqlS/L9EbdwW4d4hkeYiVES0sWWo80PTjffqo5Y2AzePIDHQeshDI6mh2IuxFjIe8WxwFXP/bdva4YHtreFBt5Q84RRK9g4HuWDSuIcbtjMu9fxcfqWzcIr/dpnjrRcREXQHKa69fAkWbtO00nJQPVwiAg70ixpKXD34Vg4Pve8e32eQ+ZheDIZR+km/uIJaaRTJce92qMw5BciXpOTJ1JGfYOAKNPc9HnEBoVhraVIl1VpBfoqsOOiGPI7mmUdUjdLqwX+JVF50mvMPzlrflUsJms5yBg3VdcEmpFjyAKiCnEgrtPiG+5YYZfqD2RiAU7R5ltIN6J+1gVWNuMJ2WvOcuwPmuYscbtOKznc2tg/3Nzee3e2v8doEHj19m2onu4UDC7gx1xcz/rJ8f7R8frhsVsPeeWpR1Dv6/IY3eqvwV/4BmG6zKrjxbH4om+c8rUYOFrTfMjZgH1rL+xfW+0UTu7/0bCbjIgNTksIjo4TsvMYQtUDT9SKKmCyoBPO/csPbuQz10eWOgoFj+9eMuQ+WbLAk9oRGYMnbe1WyxYNtTe5eQer0MM55OVccG/s3suIH+sok6zsLXke6UrStDdmU83Livc28QMEfVJydll9YCocgRJyFTCHgmoawe4FB2DenMmvX0Udg2+a03yWTiCzku+UW+BaQBOrePQrwb7+2a9Pdf7Djjy/xknf/x3zlVLkmznjKzUnwokUeJJPpFXCMgkXm1T81t6vdhL/Vc/iv9ppvLIxmaKgJ2H4xMj+rUDaFEbzBS9sx4VNx37QfAIXSfoYQa7XHcDxYmwch8o84/w1N0LRa826gQJVuwRXuwqyjkDWKUHWKUEmAlz6V/QoncSrUf45GY9RYOUDGXUnHDc04SmsUQYHjC5T2gDvK6BoNpuiIexJI3SoXurH0/jOnXwAsjGIu6OTcb1R4gcZXJvWJhTgAzB1nbMdGwTzn3iXuohGAo/nORtMRkB4CInLFOXaF/salLFliEtvWX5NfNYZP16mt7Zr2w0gE6OTMl5BLiU/0HdBxh0Ie0rYXgZRHvdqDW+s5kenh+xszYnYXHgG1bG0sypqh9aOEKdj1H7gzrP2aGdhv8fxllt+9mMu79nHFxx3VWxT4bHXjG0qPf6qSqeiY7AZ21Rw5dY4dHF8nO6/K9apC/Xpf/PTJqbjROkFNQGthTxGrGN7ZW62n9vGLU3ZivvGqufMSgTlt+PvlxxcmdaDe7dd0kDyJS276eZRT+Cx2hdUcMtU3DIlt/Qme2UCFYc1KAxsUEhd/8778pWzNT2s7vvvHjZY2vPjAa4fJSykfJMt2bdfGu6H/3o+ANrOry/UhM7qfZPjS3r0Jf0J94bPDs28SAKCh5HB52f3lWImPDgWSTFTgLb3qYJD+HmxtoTTNxCXi+m8OU/QXozjx+hFC1O8tyCNo71spKgk4hyA+aikSb4922JAQ8dJ0+eNNy+74BXe7MI9W+HwFh467pvG40Dhe+1J5yij/0JjZU38WYfMyyHdrcPvZVuom3iHIuiAW6hGFqHa9Q+u9bZkjME6pPmU2MTq+njRb6sXVHoAu30os30gx4QuaN8Bn9eEGTqDn6aaYQJKfTqQAjwQYpHnArXwA7ixgRgnY2YkKv9JJw8551gv7Ygv/sJm4DsHiRHUKnTQKkH8jdDOUaHyphuUBwkJLeUjqw6SYnj7uwfL0tnEILDPfaSKm5Xyo6KVOobd0ihgtt0+ELYKU0y9gyiVvc+hmxLFUbrCjg+W64PwB+S5k6YZxuLgJxKr3sudhYbtsJeDJ+CNmMr2MisMDcKY/BNv731BSwC/tXeYhH4pzkA85KZBQ3WB19FyvNgwvRMoyzBcuHxN0S5dehl9PQLoWv5FyGA2SO4zeh/yBRt8gB9Zgf9pcZHK4DolBpOpDtKEfTuIM92Ro5hxWoze/QD9v9uDBrCtJeonOWTGINq/XzF+4sjt8qZSATuc1clXX3NwjRHUD0mcQlkRNY2h9fs68k1YpqXTNe+rLZNwasmwYi7tmTkqZ48GhGbg8K6ryUiDEPcnZZHUfDK7YclD/6NRX1Xc54FlJ7Z7gLp4btvm/FpBwEzelwz+FVY6T4Nuii5JCOv6WeFkYTMVPQME2ZlQAxvfJOWxA/CsTKD1HHhIK6HtMhbVGj6/JYdXsI5UcL2zyjKh2U9v/2mIljoa31WjBwgxQI87w8QzQsGVz1iSn1DLrEGAh0veJh0C1y9ossRedzCA4fQlTeTJegZmMK9wVFMnsFZVOnBW4KxxeTWQCjAbAsjM4ymGw4gYXuRdHNBYYZc96l7Hruk+nd1JH4tlhcUC4rHIeYAzsKJYTO8R8LYSVPJ5Zj6v6tbvm4XSzf9CxIL2h+fRXt4aEjIb1xOeAnmT+CzbcqUv0i316DMsZESvqqYaYP87M/pwl3lji652PG7dBS7aiJnsfnpzGDTt+wBPXoW9sUMY149sjNo/28Fo+F2b3kVPfFu0qFDMMEtlui+6oGIgkFOUzFzL2UtAFJautRfy8ur58jAxYA0Wz6eeDyDkoINXMfefgwMc8CURfuXJJI8oa9CxCgQ/IVEKeKvWZru34xYiLMz0fzWpkSlqZF+TGqlNjchieYQimU2RrCJFbC6aPZQoRTO0ZAUUEe0LJ1GODg95RIUlbW9gtNrfqxm9Dd76CN3xaISsFVan149+905TPYlxLS4Tl/dZc7jQfROrdHCGUIKEPfz8/O+BfOvrLcDcv/xYy/6ANUd91CVwo8o9wtI0E+R+jxQp/Vd8im72uCfDNZpDHlSIfiSFZ5SReBAarzzhyWTiAkr06IJ6iATekMJ5XdYkc9LtMgnqtSnsYzlVwi0g+tUIpS8w2V8oL4ISIrmCwJusar1w7FumqoJhWvYvAO514OjIUwq9cy8MC5OKMEJ1DqqmmNQgdJ7jKrz3sqNZiNBad2rXjY4etELoOwG7xTcBivIFEDKVZRaYWNcLvsglqNoN84merDWrRGnagZBJOVCQ+sJra0ugErhkVd31fzVKLkdpxi89kOvynG3YZgwewiad5pqrWNQBKOFk7CdwOOCUn0EWE1Q69xcBvX5lUcSbMGG3MGWcN33CbjA1njeRwm4w351h2yp0yHeb7kTbG1a5juD2x8VT5YKA21E7TF9l/3BD/7Wcw/WUCBqGzGjgtjOPFSKXZ2Dc9TqdfC3TE1LHsDmRrUnzdDZHAIGV4dNoVLA1wiseNxj2OT9vGiRkardX/nYWO/zIY/hkjoTHcs+6ctOCRQ9F+Ct6OmSERXYLCDZlBsgwssJ5Y2To82FZkniE65hb4gDZX4oelshzWjlRseBTiJxbV6+cDPTeFAMaO3nAGSsTPHa297YaOu93WcKJlg/EzvXQ4gmk9tiubaePim8nrMu5lVzKTiolKZZPx3FWh91/LqrVhCThTdFS29tnmsYWpDiHLHm1gnQtPlDvoakgV60WFL9grmqvDlc2Ko2wonGXB8Aonuwyk5J35sna6qOUTY/arGkLKmQZEDW0qkbSLwmAH0IXimFfEno+hK44enylcO/WQIrcaXyM8t3uqAu6NE2eJnKqCBs823Gy99NzCLzoP4YwMTXPrqbnO1Y0ygLe6y8M2wM/azgfGGZariThSfXJSM521rwiRDi/2eQ7yQZ1ug2HGl7O0QWF1GpDbVorWsZP86jEfIf5i+iDtaIKthhnykbdwQwV2UXKKqy20Yrd36If/0mG3hICguAwRm7F3nzs24z7vefDxDhFPzY2LvY7x+yO/Tica8rXESwZ9g7G19BI4ORMTj8Zj4HD5sBDwY7z/uRNzT5KuGLYWUOb7P+3WTqEBOsSjWXp7w5gt4QLwbHrwqNa+ytv7a8u2a31xmBMEY/34YpTJB2N4lvGGnEpQONDy+bXU08B0/JkNrzIjPqEgJpNC/UFhesrw3x0BRmoR3FvYvmXhJNqkWxTAq+93QSqtxYFe/pzN0d2xPSzq9+TCcIQXTUewLEsGjA9hc3EDTYKE9oFaP00g0Ms3/xYq7rynSnoLKES7uzOS9Yqg+0P4mxSrx0z1oYmzBhPDsUUvGMyG0OWU5VZDHDAA63ixJMCdOZkMOOTgXHXrLs9ukhhiUPTSavVrURQEU8Od/DdmpUZJZk0r9J8IsRd9mvcnVyZsjbcVlW345YaePf5hrAfxn9ubm6aNU8KFFFuycp2YqczMbb7vXhyk2af14UTzkjfdzAMnwIs6sfXrAr2MWEjEvdXicWTFQ1ZOpE2Y3UIKSGT8Xq/T289cJ/xieHSKoFZMxKmNVJPVk8oLgltHt/i2TgrbyAmAbgCuPlKsWZOYCY4OKdE+PjiJcW9gbLKrbGgSmUjXLKA31mIYUzSbysZz8lBmxMEmFPULpaneIYeW9jUy0XmMP1i+mGyH9BUI26jL2BPrEEbbOPmB/YqKVDJWoKO7O5w1TG3/MlJd0RepFwnGwqLVKzPW93eVb2eG3Z+3F7rOXWfJ0ptgw4dzXOUN9852ZDUoCju58mLlBclRtLJGP88Sm9GooSYfYwg0BFDSqVgajILQAspeFaIlKLdfELSitaZir3dp9TlYMorWmfw9exERgu8WU5VQtOCkl8htSlkPg9nNwURVyU45Y2wjhKxxj4Vh7sTpnKfTycQK+lTbXuzdmqfMAI8EwUoPeU/Nk0Z0pIjUXedUBzezYfvJhxA3jkZFjp9cV9FcZrJvon9iGxDQ4/vDeHp/MU4iy8SiINdLyjUzKfnObdasK34eXVeXqYYeaalqRzZ26jdEi7I6464CnMhejdVZyh6h80nLW32iekMWwxNHWn9kI7y6l2ffRoXsBoiNqkMn1dyjUzL2h9/js8PGJamOR/7OnjEfXgOS/lJzV7qkEZv/ofc5r4LBwotiBGKgs10mIzSPJncWUX0C1KALqr5+dfRJl9Aov1ic4SqjDqCt1u8zA665GVyF5O7cewhgvAINPXki6TvAWXLIbFOVgRWMKNyKdXDGZmAopB9FGDovCe+0ziqQANWuccHwpptHtnZ67mmGxhwd5TOhell5WCvvkYKn/FJTNz90kvbhdDeBESJV+EAsL/9FpUAHWztwae9idBpU8Gp5mFz6pxpRoF59Ya9+sK5pbEXbbywhW5GkinTAVoL3cPaY2qiSPIuJGmuTCEqZ1gv4FaF72pZBYORsx3hpSLE6DEelW1Pv7rbkxQiNm1MkWq3PfpVdqpftY6hJpLltHVf5LaGddtNwjUCq0wcFmkxs+5SXg2u3m+czrvwvVxYAYwTpXo+B5jm7A4XyrkNC314ZNGO0cu9LnG94O0ZZ+9j4gST76+2+snEheqVOPKXL2254pSdm2y12unG7KRHSFS15THmgkqnk3rdUJMcUvlFTSX3zGFE3rUCC1ax6FNV+Cn1XLP2463wxcwCaeRQ3NoYUi2psljha4+4B+LKBxUUWGG0OwZrsFBTXY3WBaqi4pLl6ZQvWKloIL/pqwtaknE7wQEosCGDW/BKHrfZjadZ6kpNJX2qVGj+EmGcTJ/1PhOFbgxO+HgnQWUKjyvoP0BJ0rsQdbD12v0NRKF4xBV2iVJuv705G79nmEvXlcnpRQd7HosULJoj78m8LccqQK+Wzv0HOCPYsQ11cZaJ/n9EXrWbX1JFjx7f2mhYUX77hL09OzrZ2Ng6OgpwRbusCOIVrSJjzLLmML8sYotn2XS0Dt/strNyoeaTph+K7WqT6nraM3do8DPvxqP1Q9MHN1iJYOEzVaLZvq8Sq4g7qnLiTbZHrBmAqF5UZwgB20s7IgYtPUCZ6pvvweknhoJw+3rZciCxjEqWTLBW0x1aTRTDPfh+7TurPGok6EjRct5ZZk5ukAzYnEUHSph7CEnw1J+Df7ewEKXnvy6AxX+BMfKhLPhrjk4hhzGEitlNr+P34EoSG24h1P2JfZ90k1GczUXCK2WYTvN4k/VzB0PAwptJOu1d4aWLgXhmGH9l6lL8JDRXuKF2+Z28T/JuD5xZPfdN+8k1RBBOe9NhPJo0e3jeuTWI4ReTXbY/1Kjpj4cisvvcfL++t7mzdbT9l61oPupYDmyi0Z5ih1iEFz7b2No73jpUey+vCT9+lChlg5v55I4VH4Nlhl/NrnXPMUxCXPNCnkMAfCBOrTW+jRgkU17PB2yYA+DszWUm9K7aJOuO8jHbIkeTWqAdCczjrWsGgYcUcHPGD3qT9CGQOPbLii47vvUXuYqTy6tJSZn8JkGZ2PBiYvOPqd4lZD/eP9jZenu8al0cVdX3phlnK7XRzXyGqGwfdQ08iC8mgsphIJ6W04IxkmBUazafMFUaXtpub5MCfVtu/U8BIpgrwCXUxBmA4+A8KzTXanxZfw+3372vNE5xaX8zMaV+h4Hio1S17Y/c9IeMVWsORutLxurN/vHx/m7VLueP1efzdMKk5y8fMd78yqsrL21+qGH/UguM97oiK8wfiRU+1pDxwarY+Mdl43/MEqs8O8G340un3MM7itOyoK/3HhGu2R2P41F/A46x67KahiUadPt9FDek5FivoTDZZ8JkzSNYlhdHwRNvBte8UihBkF9fBiXGvaN67WoyGa8uLICL1c1iM80uFzqtVmuBFWOoa/BhYYPLsOvypL1eg5CMb9JbAG5FLW4vAzFQZrMgoRlDGOIsZ3IhYGg32yXVoUjGQC3xqrgQF8qCpUBWvjVzo92ZPzMh0Jnim5aXv0yGewRp6lZK3wtS+n4cseXW6PijSRQu2rtH6YB3Lw9X9ti7rn8UHqs2c9LcPdLI+LF+2TDMRhfzaVbWAsqFk6yHOvxD2RtHYLAc/shiID3gb7cBfuMvccdK3M1SImMFslkK4F4GvbhIBoPVm6tkUqEn6bjbSyZ3yK6bz5YdbutsZxwLBetmEJDh4UQHF2BqpuiXOD4Wz7U+5vEBJnyqjjdeOzmCkMVD8KM2JL3B+TUP8fR/rI79E2vLy6h9CnGbO9RX5O4L8WJRjrxhYu+DD2fCLzv/FNV2MWxhbSeqGQC7jJ5NtH/UbzsNOwsO7MEE4s4DQdcVYqz9o2aPtzWN+mwg+40SIJiXDM6hRDLi9q2NdJBmpRMQMTsikQ3FijbWZpLPxNWyiLfFe6dUGuLInTUJTu6oceMZPlDJM2VJ64YwsewhvBFlsoCE/D0v+pNLUEJONkEq0fteWnmLrIPG3Oq02Kyuw2TtwBcdIPRymmwebL/tgt0U7oFgirjCNkIkBZDILrM4Bmfb4hYDOIO88wH6BCsuulUUoWDpVgBGkYLBdspgibjDwBfLwInAwsCXqoGrli9XgxdEWanWdgH9rBo0g3xeBikcGD+xKfepNRfx/57NRZ25aBm/tFv8/2f4oINfWqdzAL+CwO02vnku/7YZzJL6YM/gPS8Az1r8lcC8zCFaErOquaVLrHDoNn48Rwz87xI+4X/bGr7NMZBaOrKijuoLAqluYDGCbYnU8lxXz+FFD1qEIM8Uat0hrESVWFGkoNSBj+eEfG3RDWQDK3P40eIfz/lHh3888/1a5h/tlvfnkvgpyqyYb5+bP58VfASKrJj4lwobs1zQjY6B3sRuIu8YyLwfVgH29/S7U34J+SOP8h88ZgI387koRu8jtqPGF93pYHJ2q7/e6a+o+uqfXKk178RexqODDA0g+k6AenPI9sE4w4MV++2bLgTE5rz2I35pHutzFAMSz2Ys2HdZ984MsTToAvs+EEc+v2ht2g/w0QYIlgyWkCh//v/Ze/P/ppGkYfz3+SuEdnaxnzEmNjAHgZlPCAHyvjn4JIYhy/LlVWwl0WBbXknOwbP5379dfajvQ7YDzGz2IInUVd1dVequrq6D3tnUlYPk16/Y/YzynoE9kB/XzaWnEKSbJeNDtOZtlwcUs6lcjL9FRlBtMn0Fe1XGUu6EoePdIL2s1IfEXriZzCAD6MF8OtXcmPVm7/aL7BT1sQu2KGW6UsOj0IYMYwgyVxvSJBkP8llIsx1iI/S2Y/z2NjRKgNSSbHnb9LLXixCpVAUOxVA+Qkfj7em53p5lZBocCMbM2NDANFX2Tp0d9q8nJAQnYMhczdYknCYNKYLpCeLYKEZ6KH/1WIQnFlgF/MoOfiWDs0tXBQF5bEVCXkuI6qtYBRN9bkVF30u4atM/8Rzs7iV7gnWQ9qO+Y4FMjrAra0i/XMAEMMXjnBRLiKFuL4dW3QNxTC5//Z7DfVDi8utwKRKoq4ZQye6D8SXulzdoSx7bWGTQdlGiD6Fq8VbvEdwHFdWVAxWRHiOmKwGTmCksxvcjDamCYZajyIVjGkyKjRO50Ely5sBVC7IR2ZmNKmzL28zRnt2UPDLwzUmOXWEgx3rEpQN8/MRzfzHOE126GomXVf8I6+/K0N9FcH9sKQ7r68LQ11lwX/XSHtbZmaEzcgj39mhTh0T0FNUHQ3aRwcGbrdgowbXm01R6OeBykpuNvJM3KnDizDPh89FqHL7Z3hScwWx+XZsbe283DiVbrQDo96+ipxC4aAV9HoIdcNVTrlGwjC4X2XSUX3SzKcJLBEjYmJX3WJiFIWkfr0UwfhOtShdgS7ItArhCXruNtmLYYAxdHTXp6sze1ZHQFdqAhJ6kL3bBCREcvIcLhXDyl7rgVNROzgTuWSSG+9n17H52BrDa344dA5VDZPesIjkFbGgkEydkTYBrgaMcnYjfZuU8GWefscJCpJaJff1xHOejK92sK3Qg+bcSiT2gynXtLko8fXETsUUdNUEFXb96p94YHQd61RUYPLpLY5qRsqrbkjSqLFKnLIbU8ZTnQSvPoCOIC0txjORQKlqIi4/iCuByUmCwLUCJ9xmfm+JTK2SmEgqiEFt5WlZFftWSDOY4tArneEOdWbLcQQpuplrX1JgmMzQH2Z3+Ah/F+w/lZUh+goPgmZiJgpSfnCBZelXr83BLYmnEPg83jsdgDBav+LmVe0gOZvBVvkZfyvBKufM/IkkaiYmlS49xQNQEAf/fNJ3x69AL+1yENRVrfr5Zu+5onSPCqXgJjsdSd9qM1Y5g9LD+YK4s1z+erUwXrXsDRS4QH1fQe/OOvbQxX1OLxjcGuTEdgcsPVG3anqDPUJc0iOMlKTcvOtFZR+/8+ett6bus119zftT6tXibxWGkCy3dKihcV61kW6gHze2JlmHzBtLABTjT0CUzZcDgDVthncpaxGacBDGTYoHRqx2KnZGGezj1yVN5R6uzWdvb63XYbPqYSEEzvu5wnLEx61Mhcv0V5yJ+WMGT4UBsNppKaSh6K+tZpiqTumaqD4yfr6Co8//YVm1snqS7kCA1bVG09UEbBNx0YlbFXLKiC9ojuar+H20UVHt0jeUoZCxHrrEcecdC92J5MKfGwayEm0cLcxNs0vf1oUuDXk70AiTPLGQiEy2C5BuHeQAybyHlh1QSwiWP+rLLTM0yqDPU5nmRXBCLe9lyzL/j4FnHqX113BqXkblHK2HuUQhzB+R4qvL2aAW8PQrk7VEQb+k1gAz552At//zPFZ1EWLnIyoAa3Gd3ieo6ZVEImqxRlj09cH2SDj2+7YaM1uLX9EQoyUIKMsWkugWUMYqOU0jWmA2r8VVEzFDnUmifZv/Udgf2YrldiqotNzuH2lqjTaJ+s+T+ZtO+mgiOTYEKlJx6jPbNbY7DodlgYGjSiDENkuPSaKaycZVV47aIchsX7f2ugWV98c/DOQtKHitb7fOgRLRPxGa2X4ZdzrnwHbs5V2A5dszFcZ2zsJYcNJejRVgzgJLs3rkcNZxLiI64+EZh2CeEbdutSUhnv7IexqpXz0aqiGGD0NQQ2yaiqyDsErYlAoJ/tlMNEfFcSOb/GoE6M9G7SklLY7AAQcGJAQtBw5Zu4uYhVZD+JpQh1ZtaMpIz6V1iuzLtVsHyKx/3Sz6SryrBJvVAE2GrDqHLcH3535JAG0nxmXzBxFHcyrEgxzJzzdZIuY0oewp00GkMaCw1tPoNStECVnnUSt3d7Eb8ZTbJL6TtfSlNjLs42C8fr+XbNuZYYBZJoYEojyKcRRglx1ImiYbypNipLymIH3Md5xJjnzlm9kUvqbvCs6vtEevxsZKbXAT+xz9qpOpKg9fmvTx6NdjdoVgh93V1lkYzKFp7kSFOlvPhWYRGjgvaEsS4rOR6kMnaXNHUYl4mRQecl81KWU/5sjoEno+aEEUfIH7ezaZlWlTPUrTmphqyDmuF66XiDkPG58EpN9ZRf7fM/mD8AL65nUNxwq6XY/aVgh+2+fOEN+J3iVsajOjUk9ulEFRZNU7V3qFoHbhQtHD1CakcMMHIq61IMQK4yONHpQ0gVBiixhfU7H2elVC77CAdIT6JKfDcW5PFVchi6Lb6+1hsp2aPGpOaafTvMRynrn3qg4k2G+MxkJBTBrBszGbjK9Fesn1ykP57nhUCmTn9DH5leN2Uk0za1l8bjrYp86Q8OSzgNnhrFWPRq+Xu70kBQQePWYX72TgZwqqNQ2GyaRTfra9WDdP8IboLca7TnCzxsAmg3vDcunfbVlc6XWlyuFO5FyDiS0NdX+gk6e0krT+zmE+QSVQkF5so2j/+Ix1WXYS+yOi61+aZZWdJJueSPUhPxtAerQK0siw0eb/2QSrUeS3quTWp9/Fa19LqOVkWxddCLBB2pTwulaQZ6ImQN+MCbRFp1MoqLmq4wQ/Y8VK6zKDvLqV3O7XLX0TGVb8RRyLV34Bciji927ujFuDr4B7ryYOIo/VuN53OgS3PcKEEiGN5R5OwHIm04LcXIrsOh0V/azwhG1l3Mh9XGfqqn129bb1NIaLrQRdXwzvCftMqdjixvYbxicvlrPsOl00DhQh+f+J2DiLNjgSQIwfIKylITPjUKR22y/1ZOhXS5F/rtBLa1J5mBdraC3A/+yd2UgPXWYF09VpSik6tfIli8Q1enz9cyYCLlDlRPuvLnoqXt6G5dzUlTFjJpMb0EP6ZRfdMhTM3PzdMeZ12l4evH1mNiHnsUv3neZ26yAqMfQjVNOWjuuy0XOwSiGJxCibE4QRxZ0q/lnqWK12TLqHWtVjKNcrKZykaNelP1Zmcg1KrMFX5bIsWwvVPTNv3jM1M7pIh/tPX9XeBiQQKFtKos/q7gHeAuh4oQylNwu2tzUggzxKwUilh+S+woUubJxelsAyiDiF0uJo7oEx5yqyNDdkMrW11zzNDFlBXX+yMQqLuMDzqHsYbB9BCSScK9Z1jV7mYX7SyHiZe4hS+sKGpsfUtfSidKOvgDPtSQYCQr0EpimD6IvDehdOLUSfKFvqmxbIh1wv2rWSON/fOk5tZepdSybc1I4vda1wnYw1cA1kyr+E0dYZZN6K3Y748dreViiUb/neWlCXSXh+TYN7r4AGjSX+B8cK6ufyAsbzdIIUx/lVSGCOcz77AcIMJfP3NWVGs6+coK9Hx8EoPYtcUTLb9izMSJyCMVxqeSRN2KkC6b2r4tmsAs06dXS4Ko7Vd6Vhx1Fc74ixtWMwXPcqMR+nxHKpdicHP4P78uxjRSuIHnc7UbRVBHfhOfnlw+aCL9rcBS79JbYP3hN46kfiXT5LErJ5ij8IpbVeffhed5vroVEfawglt8/Cw1aQvWVngrjG/YzMAM1AJKuGsAE8DIoiz2hSn2cQUU5je8khteaS2lKxbglGLt5AtZfKVqnHvPePZDsSPKSU7Af8akFT1lHMnAd3V9QkG+37tQxcM/OjErD07krtma2CKUxmgz/c5id5XDyZG7cU6h+N5VSG19o7lS/bMoh66ZbwwHhs0hTVAigZYd0IJj7WiSa4Jz2eyrltJHCi9ZhJx8rqRxJXUhJdZc2YgmXXfBeQgmXWPAtOLeByv/XlM3M69IYlL/AFkATlNAmLLfPlOBFGV10xhh3zvRPKhWyfFU9hpSnHiX5Kl5UtS9BZar0QMQQtVs7XJNEBb7/ICo6wpQkvpexImfcf6Kdmufb/A541TgF6Sj5Q55xm/Y6H5Fflajc2PtOZIyxC/W+uHLUEI36ntO5baS9+l/cuVYOTv0PGpGvJO274mJSx1jUc5MjL88BTRe118DHOFp1fSU+rtprVm7kMygB6B2Xvs7yMUV/9x6Hh/WHi8Dx57selADx83GMIPviE8erwI1I8hPPZw09vJTwt3ouP6eUGh1MJrcYYl1u0TnJi03h/qNKZsbRM+UnPDdREnpUsA0vordmF1B0BRKgQ79Ik2UkIq75HPoUzcecppwyI3XXoDaW+8WiJgnCf3IGel8A1G/WWdRrynadb34kfperyNUegm7nADN+wJGwHbLVLQOcAz33GafV/3PHtfh31y99x7XvuvaRbYkP561pbsAOzypr4Xsh7JjNkWRbORcAmjWABDDGT11YKq3lLDoDguzW5Y+wOoqqcM3FxPDCTDMucChZqWw8GdkNOBe4WrF0TnFXzgIhl4J+9zL6cUNsVb1btqnRsirW8L66PUtcgl7Xpyvb65lFbujr7Ee4IsfOuuz7/du+p6XLj1N+K1M3QLN3Sk9CzkBtFy1kTRE5YqMbp8erdO/2A+5yujvBtdOUH0Lfru/V//NUV94qIB2GHGicBE27vRmRPGSM+75AI9fXp3D3bYMRuHlPFPIoDunOecvO6bpzW/MDX3z1Bx5NPakvWCAJgd7n+L4gH6MHAdhRewqMQSL3hlzmxE0PAv693uzr/neZXqztMcRT1SJHH8I3s3GUuRBsobRQzrBf41FE4njhUb4EaHJVMpGt+JwEtH9L0BV07YK/b4NTT2zTo/JT7S8Or+hvBmkk1tb5JLy5v5NBPTDpOK5mVgFXOc0inFXgPEh+CeEC+Lfx3np701ig+n6OPNW21+x0unKrQ7KTKkSI4N2VNpo6zcn44R11pSVXWBOAKycVJWG+en2KkFquPmOGtQi49FuIUWiKhg2M2mYRg4sVUMyWUABnbhTVkj4IAnLVntJl6/8ANtCdg7sxV/v7exu/V93MFkZaZXY8ONty/fbuy8wY0Z6ZwAuxvvagA2TzfA9h4HoKR1ArzZ2x5AY5irXCi8qv2vr9e/009ny9S4MGg0tLix22EIEsOfJvPTVEkOj0aKpLesk8a7k8VfdqKrTkSTwsvJ4Ms5Wl8Cmks+qTAgVhr8EBIgvYQnhnAA4S04gYNyugtREs+3D1/vbBz9stap1TD0IbftWeiFjoVG0xx2Z5IOb5ZM07HcEi7gd9OyTE7T1/BWuiXQYLsnaNxdWp5YYCfc3CfjF+jlYV1Dy4KBChzaLSNcyIK4tZEseKdI7xuhnaOHZGI3+ZQiyhdpdJXPo7ME7TZJhB0cZ3PUnq6OCGyaDuFiH4H1EdjzHDXDGaTvDcfZ8FOEGiXROEfqM9bwSeBLVlL3aQB7gMA2z/K8TKN4kw2DNMIkihFkdAwbYzSfkaiZeseh8gBoHnI0iTi1f03vSjZ4ZmWIMMvh1lDQH4mQqXkDhUIENRLBqIz+ep6WQ/T2JTAiG3KEsGJtjMdCDzUCwWdW+Hq6fG/E8rAJZcpxySS+wtdeWIAG7xrZtB5F9xhvF23FbYM17eIyi+XvWXXWirnkf0zkbuO26MrhG5/ZX9TkLObDpPiSKR+KAtEyGV9wW+xVjdQNg6LRKiWnFjG4xaSWSC7n0tHFeh+ucrj+u4tDJnRxYEd+KcUf2ifQTrl5lg4/0dCUkelGyY6V0qIBcq2aAyEm2p3T6gCOWkgNEg9qSiOIKJzjiB4YSV4AWZJx96B+0z3Y2tkYbL/dGuw/2x+8EpA4Y0mUg7IzaNl4HpRHagxm8amxnNqoJbzv+Q5qknsK3ozMEch4TPZjoBq3wQeiRFrgTfILh184vOoFT2uWKBU3q9JJd16mBS2ixJ2A7c3PszI7Hsv3qYIbNxosyPbbLL0wgGiGKwoH+wZr7nKSqgGwJRc6QkrAaVqEjU7sBee5pF7Gxm3OBevsheTJNfVDkto6OlFAnd2AppIUn4xzlwxjDDdZWRrBSJN2y4kydEPjJhl+kd4Cek6RopX/KrpAahVoHSOVftFv9XnWsFuoh1eqJAlaQ5erYx+JeqLnNGpwUK7P1mTtuqJhEn1IuCwFQk1P8j5Ve6At6uIMnomX1lDHEk5axbC7dVkV6GzAWrYweFu+tcXP8Jwgs6tyTRuDWhXzazFdLxrmsys26o+HgwFdb2pCdciYuyfou2S6SwePse26ihNUmubd09V4BaPgXI4f26774P8v0XmWDYMcir8xxlG51AmIBvSy3jOvwrkn7SROpjXpugnn5L1Mirej8S9adAvZW8kjZRWCszDZZXUaEGYK+yv5vE3fKh2NAUZcGcziwmH1zgzxP9eCjdwc3SNqGQekjVVpDWipKKJKABZvjFO2WxLIY5OJlELeesBNp0yfJQYoswFPTeJgMfMZTyLMsLVmzEWA36LZnYJHfcH3Bk6zBlFm0gURHEDd7tz0MP/UueO4J0XaCJZFKNVACoucpwViHDXe8YJS19K1hO064kl93FYMy8arjB8QwH0JojZ6+Q/LMDAwSiHRmY+T4uW3ZpsSx8VMVBvCM5ORqoEFSkQfZIgSAf7y9qhv2CAlysA3YZfSP6Avap4S6eE2UAUOlNupQnv9DNdOvq6gUdnQEOZEY7SCSV/pxmj0z3yayhawwH6C7W7quhBgfpNAbtYKB6k2YDEhKfhxycE/oY1OJNgypjqJ8B6Lndr2mzfcyaL/5e130oZtNONJI/yTWvO+JYPGrWWxkaXs1rT4lzIt3przWMeiMraIQU9cl2/tel/armfhXjPLXmMW3hr4vriBz6TFBtr5oAwkpHial60S/xDVL/KEZgq0K1yKQc50FEG97KXpCO8OFOtTJUeDAoEb7ZBQWvJHQ9OkjM+YX/LLmzAFcmMnyPa6nayKWyS1c2LvSGLkNLkfar3sv3ixs723FZszt2rNQ0ZEerc4AwacGPxG2m/IPOuXImUUOkqvaPiEI0Q8ZAFxjMbiteoTHEOWznACOQXNNTs6ZFXWPAuRyWDuBDSIqJJZ29s+0AyfKEbGYGu8CbA2ygdbCmGNdtq+uPl+lJ1m6FBEfTK/JQO+IvnkIQ9swgb959LolzTpU9xB1nza9taQ7zTkU+GKKLVuyqQvy/A3YdQ3fVZf1KxPSe626AePMtzkHozSaAwXPqsAOzhrfbMm8LobvO+QatB41aj1FJqZ3dKPBKbA0O7+hCZ1SpRlrOmMrh5DOmuGd+PXaPWoDodFmk5pCKU+8KaI/wzGeYkIX9Yuz7Zco0mejevWGn9rjf9WrPGq1nHDdnlPd7cW+mALvUJJwVbv2kNNNoIFTudsmDxodYGTtoKLHa65ZkkSlNhWk1mRDhHzciWZFgHqYuPX/kkr7lpS3WNlECf5rzPNcGiasuxeBOk6elpYrmuC6rmcTo+Yd1h46RROsNDq9n5FvdBgK8MCVysU9PZW5Uvfqug8a3ah0oRxt3cpX/wuRTm+fEvu0uSkYDCL0/4EWWnqWV0fr8doG52ivfStnqrBeQERiE3e977ONcAyusBi1GpqjW9GRaGn3Xruwbju3eMJUdgmLeFc6NaE9We5D/AMildCMVpaPBZ+z7k42FSvGw+DjfVm0Npc38AGyKzxp0UyO/uGjPAkMxQ5X/yelFtTmzFHbPiaV3qR7orx5Jjl/iX8EW6wdyR4AES3dni3Qz3QaKXW91F9dkd75SnaM8sGDNGBJY70II+KOY1KAJIhLedzhOv6oDWs+IRk7coNSXL8bcqgfjAsC6+Kzxvj7BTEXZxx91VeZJ9BsMf4NfoqujtbLwYBGN8WlRHjW2DWUMA32H/tRkfFVFhW8KK+g1vt5MkIScNueepGklq/ejHPB3TxbeT5ECZ7tHGZlTd6z4Ln7UnsIQxo4YAJ0k+ZghnUjv4Qv2+K9Wrj0oWUE9F8DaQSHWImcPPXaXGUIFiF9kD2K8D5mosPbge0LzJsZGutdYi01fu9KBz9MOmoO2mvh7C934Tv+C7dTjONBmGkIxsoA3xnId6lQrx3KvGWIdrlDRJtgqfnIJth/o4yifnJCbiOkX25fN1QLTBAd49PlT0AUtJvFKfHrd4v/U7Uf/SoE+Hf0D9eXKY9BbYjpKZ6QG0bmR+y6Y50sP3y1SAE54J70lBK7tqURQZoB4v6D9Gi0V9bq/n0wIvLxqKXcMHoAbZrG37YJRUHK8rmXDLmjzIu/sqFPU4QidcnlZ0YpKUvH3+QHv5QetCWStRELnUID9VgPMNyQFcXmk4vZHKG5cYwy4kyRbxCwngIOB/RpHspVLkcZBM0ryk6vKJzb3eQv5lml/AMF2hEWhi2BfyAxvQ/0Y9r0qmWToSUc5x4ow99+oU53Rfjlt/PgigdfItoQGBBHzGNQsVMZswucU/pJS61XcoqEFBOyOXaVuwC9fTwCIw5zHALrPpAFRbTvZzY8IZ9TIxJDqFjfSS+TGG4UbizRD09+jGQhmy4ZQsJoGbDxU1HdSpwtMGnIy6onSgAhhiAJyZioD0ITGV0AStZ3HaBjmMti3CJ4OB+uk9QNAX90+Scg6ks5nqz8HqvfzXZhy5uTMzh4BClVLIknwCok0mRTNAqyNpuzKsc6jSAqfeqZcLMV/l1Z/8g5oDtEDHdkMB88fUJu34goIUWIzbmsrsN16bkGiaTcwsbzNKGIrfkMkC6djBAisivLStd0LIR5Ar1Yvvd1vMvn1eQr2uq/5PHi+crC4HkRFTanIesibhdqbhdybhd6biNCbmbpuReYVJunpa7O07RVjgiwUjRb/zBY3/K7oCk3atI272KxN3Lp+4WS1i703cLIQ7WFN44+X2G/um1lQT5SnJvX3pvNyIl8bcv9bcbmZIU3JcW3INMThjuShnuRiQkE782pxT/xl0ibzhJK74DMidpxQu8u1bHN+4fGQxiHNRXSJ1qA3ITLTQrAr51uumsCKZOVuVzaRqVx+XSl592WY9L71CMMCYVqMZDzQ2H82OGhBU4VdQhFwRo4wKLXsOCGZF20d/MS+Z6IFrjjNjtPjYvS0fXFkGjF0Km6N8L7z8Q8zSD5Bql99AiO0TgKw1qDaMeHzBq+LLIcPFLQUxoI/qgmRfSClNi4NWYu9kaz/WK+x/ai6hnH94imaJ2dxPfU6MO8F6J75fju4jl0BKtsEU1gOY/RHdjKhbdu1BQxwBGX9OPGvr7AXXyr+mBcB+OAIagnY4xBNAJ6//dOMR5AYZELzX9LgzQmFn19qfvsO0PqwoeeyxVINDwPQ359SpbOwysIOYSgRVY1S2G+pmx3mst078jzT/6xz8cs7/jmL6oVjtLiRmOpG4yqLfMzgJkXyq5qmhxCfxOR+kwnyDapYP8MD2dgA9RC9axDlm0Oti7gtigxFpMPZIKoRBLC/e5Lw38PRZMsLi2cTqukgFvc3GWoVWmhVA9IajQd1d3hkvRcLNOcSUwskYErd9PoahN7wMcWVOwXCNI+pw/42HjwwT78m5dDlO8DbQlvMdzUDDUEwmeGOmGvWJj70MwYT1mJKak675hOOAxIw6T1F8lcxFHMe2rl4mEfEPqhIURTXvicZi8+lW8geV++dy2OBQsibb9dmgwMMB/ZmiPo8hmUOP63VGLUz/j0+pE0mP5uCIeB8fEjD7Tzn9YtKZ9w+lk3DTrBlHWjX5/eJMQZFfwnZLWhcXNMkubZKihI9wzlN9XK9MR1qrrMAdg8Z3qxWtczO+4XXzVi3d70hCThfw95u0HeSbGNBBm4zyH5+lCZOsMHIwjpGvI3qy+0YjbB5ak/BQWVzAotUJ7Mnwc5uQWfnpcO7OquGCv1dsF2li/7J4VKXhkEbZiN1Pp81NkpR2cCNtrPvV0LH73y7qYNU4FTi+n4Gum5CVnVn56EA/D14F+bFy6Glt4YQz6koI34VrZZ2Et0gIDrys9ukUoeE/POISjk2zKTw/e+vYyaHLpAB2lJ8l8XFlgh/PCCnst6R+EylYVZ41sV/Qg2TbdOFqZKu0MYx651oNN4leyWdy7FyIr21P0d/UattWyNeb3Ste3MWpKeBgW9IWqeQDgbXzal45PU/nVsJBHMNOMnRt5pYSs/ZdHspk2e0FIJ0R/Eq7fFleH6xO/pIt84Dor74z99kPUYr8yA04MUS+PIQUgi33RVL0P64rrao0Y42CmBJMPId17JYu/o52ea0AeLuqqZcXB7FIM5D//ie54B6bsJla8Ndr18KnIXgmrD3db/oLb6I1VM9zusfCUWTLVU8idMjglne1g8cF8Xb70EcN0vPDo5zrJ5RO3uRPlRBXQB9m+kOZimTrVzkSNSKI6gRUTADRQR81KqV3D+gAukFi1aom2C9O4qTLLtDJu0QhoTE47EiM0DcKsFK9m6ESZDhy63Dh86JpSvpKxU3EJG7vSOHTsykegDZb5JgSklRANxdh+SqxL6MxKzNLcuEtvP7pJ+allu+YgwBF6SC8Uyt9idRs3LZySB67xGky5TkKTNO5a9XTkXq8FjQpfa7MrWHJibjLHtACJH9L41AgdpWG2/ORbIoBxAvZ41Jhf+Oh0IOsXGIoH+aY8ntoLyzMNtKJOhxDcm6UXreU9r8zCJJ0S+XH0RVaU1U52XkcWY9+jk3EO0bG1szXIG/a/bkf3o176wHAmJZ7dJZJL4kfZkjF31J5+MEBDxZQsGf8zzyfCNYXgBGC4oqBWhjOwzQwhJmH0nBzK1asQmcoMfVJeTYeRlX+0O9kGj4/xVEpW4c/9RV3lmjqqUc+oEinr3NlhTGxT6v4LQ0zGsjvVWVKMLpIi3R6prfENIYYwpOchXdfocKtyflySaa+hL0jBBitIcpGgFfOIc7D7AmEWFgiKEek82MhFnsaKFxzBMrKqXCQX0Xw60vUUc8QGlZV6RfxDvcYg/dJm7//4ALrhqK1sH6xLVf+6/k5Gcwc3lKHZCPDlxshk3PU4/qpTkOSXEIwNH601CAOJjcNSWKGldyIEtWjNS+zcCB8v8FZk38HW5v7B8+29lx/397Slq5pIcbCWlWB9detFEBo0Kjkxx156Aa+ejXPhoEJ+QvgV9qVgD6qc/onWI0RB+scJasaJslBGDxkFnAHv+OZiQsUMmNxQ8ZVXvUaHK/G+UqI3Og0oDBFvVeXbzJ786a7ggOC0CDu0fIMUqXephjVJtgn/QW3Cf4g2YZ8SrViG//ig9Xi96ImjOS3IseHPTQvLEaYxMeg55M9MjGvH1sSqcYir1JBet38Fw89SC1fT4BQ2f76Is7s5yTY64xlFBJ8Xoo4J+XJqXcG7CcinitAMF6arRRYFXy6WnsLEL4yue3yFhdysmwiRIVJrEFd4Lm4kvsQRylbikAHJ638RnwnZy4Ux9QerMeBlCmKRjLhQiB+VwH8xtcW1JatC3d+TqLe2Fv2PJD9IdRD/lNx7lrznxrbIFnZ4rYdwX+yNR3WsYcPl39uxvWZLqKyKXxZpv4kWW3D0HLUOJR0i7IsxfACNxvNf/p1YtLlDTZuTTb6zpCjTbTDs4cHVJ8VeXzbEGdbdQ7bUCr4i9g3IV0Sc5fIJLyIuQvAi4p7AdLKOWzYs/aUhr4zaxJg/RW0kJgVS3xk/6adRTP/CxxjBwobm+t39+1F+/Md9uDq9zzNq7U5PJ1X3jxKndTt6NxnTCrokp5sph5uSQlKqt8vcvul9hx6QAw3xP3tUzinEx+FZNh6Vz64kSBq4hzr43+t1udMuBoDBljyoCD9Tbk7L9/hp3SnzYWRzpUByfDcdMoI2jRF/rIZBMuvUAoMk1gLDuIIGllToAzyeV6msoPAcJrwesk5SePIpvYJH6RiveQwbkKtsOdY6ADMvcUB3eIuWtA864hZ9ZQpAk6cWbehTE+VJnX39TYM4s2vyjeGQqGlmoZYEuoKzpFrOpzQ9PMmmyXiAbQfSKZ2gSYsJvK8dMJX39APE4i68rYc+yudot9pLptZRn8uOrixIc28+OU6L7l6yJ0Q0o9Ejpecc33/PkfCioaejWM0pruXalOCmGHGsmr5Zv+duaLJDxLIzAHkVazcW1slYq37JAIg2TodI2cLMNhshRpKrIHQEWYnG0BL60lKox3pthY8s8bgYSESuUnCCGFmccYEgxvUWr8gihdOck4Bbw4fwsY71wCe3uq0UA6GwjEMoHwzL0YXt25adQMilRSqwl78XWZVoCf3pyy0kPybDn+HD4p+8tvDTr6XeO+Rxo+1sJyursA+d6lzqsn3MPknSsdSFkLrMSZcOVuvkfVIeuZyXkGUWrDvTVFFrd/sXU26lJOwF9ebjgJwC4j0kVRc4T4hUngy3eZYMP1lzVEFmKpKoiv7T1uFNWal2IPhJyUj5Uc6mYKqxgxGyeJ53akZW6e2R8e3vkBoWvXmwpr97hfPFopd9+WUdw7v9XJXBHOgKwOgFpvG6jcJTmcI01q/KhtEeOj9BLmGcY25P/GDYhyvEUVEYJGHJLIVw5fm0TE5UCPKwDvS+//7/i+787fu/t+6tP/3t3ucP9087UYu4jsX/wNGMQ6SCJIhHo3Sjoge59dha8+aGQ7bhyhEkDE0PK+Xwt2j4IK4h5Jkx9npMTt3sOMbadhSeCbk8oVsrFGZsJ8pFnUkNmbMIgnGo0gFvJn68AWfLXLpdJKomgmSddHUl2Zv3kHalJz5kgUFao/cMxQclKaewvMvnwrpzourS3slATRdvvNnTp/WAdasnvnNiupV4oM07HGrdALQ7LytguOHyjg0h3surw+Q8HW1P3+3u1LtNjMkm7D4mW6yAXmz63obzg88oi/OkU6SmDuG9Lj3b5SHeASCDc4vQqW2CNn83hDvva1Z8qD8FimpdQ2QIs9FZNSCbOVX8yLN1C0QibvLagIx6vQkN/lzBizoReIEf6qSv1WEiV4I5cBMxIJ8YCuGqoKQ7pNK9mc0giqUEZQxcPffe7Oxgd086oDuqYqsPvazv7svdZJrAFezGaIQ2bDIM2pdx5uriK3wUnai0gDhY6MYnjxGRDqyndJBtW2ffWQdgZsERKIgQSm8jmnV8BFcXLB5U0aaUMw7NOYha/7YNgjk/yMq6k1PWcY+aj4/kvKV6kGuMkN9ROA65xkcMAmPlEyqorhZ/UIQdTmyDgzey82rAbIFi0vBbMMYOdL0Ao4iy6aLAUFZqZclYt37gQ/UaS/2PgPcZ0sE+NSQD0sfI4W+BOUPCf9eUaVp6kY3wyLwQsht6oryLMPiZCwiKRWRDBYo8dIEd5+ORAgSPXCAnDTZ/qo6wkxbhtK0RJRX+cUe2ikS/sc8G3rajx1Fvbb2hmGESWkfIiF4nRUBdDlE/olgxMbHhqHlAfmn2kZ50KS/gRxNQ5xbCvDO4LmDf/0h4DjUKPbY0cnxGnr3RePGv9k4NWgv0Li+ry43iOM/HaTJ1DAOrObVEN+O0m4iLjtziQiE2kNMomNTSIr+Az+4smY7gWo6ud9ge9DjCtzlcp0Sn1hZ/1BUMIORzR+/bcQNF5DvfE/nv6wY+E9hmPRgccCPBx4+0so7pUiQmSVyjKqvGabzuQLKZVOlpXlxxI7oZlRsJvobbTOYlRP8U6KDPconYsIo2CuPcuE3MNTJcEQhfF0YDcPAmx1T0M6+wmwnUialL0SEcaF2LJthqc5aOZ9ipvMqjbIRGnJ1cRWmCVhpaUiaSZlwPzWwlrV+LllIOY7CWisYeycYqU6M2prnZDc1OceJJsvfGXmxL8l0cVxirsDweK+Ps6kSuMTsoXbfRyM2hbTQXzZMuwnMrpIf0uKGb7CKuZQkvjasJ6YVxdiL0paJvMJmWM/y5Uo0NfQtn6GPASaVIexOD+AhcLOKtdCYJGKxskqzADkbJRuCPH80Wk/D1R8Xn4j1q1SXaHtpuInTw6MZhSJcUAm2MIXIAtbhYwSxp0CTZFTua4dxizIKN25G1tYNtcuzg0IFYm/yihNYTKPKVMMyJmCcuyofD+ewKB+aA7QbkCu3QJcJ8nqUXkF8ZneEARVWhZ+J7YvymA9gWxjfBZZXqccMk8GzI/RMS5yi9nIFvDtr+s2n091CWLL2HGdCaPxC5jfZ5KCgMX4h28eH4Purbj+U/DQGV66vYSU+q2IthyU9AHEsDXWGMxsaWwne1EOmLXI3escTVbTQOcmjb8ibeSQUw72h1zDtyM2+Qz2IvghXx7qgZ76p8xlh3FMC6owDWHVlZd+Rl3ZGbdfjmcHm2UTRuXR81iZ3gSzKMDaIBsy60QXFMDsbg9xpTCJSNIeyO1sEMclW7PDcYHhc7SJvYjWBJhtTjaMCRM31cAi4HT0gDjSkUzsaV+nbcwRbhpnx53kjIXAyqy61G28/jAFxL8koeVwjDENgQqWqgDV2wpS86TvGJdgoqGOjoyTR6NdjdidJxCtEkqCX6CJKonKXD7CQborkhratIk9EVZDgroQkumppGM0guE22fQBN0Vk4nswoXaq97Qw8zHAaCNKikioo8h43zHJTdZynE/uEU1+jNu84RUutOkEiUWPH6lM6QPgen6knC47RBYhD2Cfz+z7TITUdrgUhmSRQaaJIoAhvEUfbHkMQR/IXB4VjlQBSDM0SawCthrOBAMUrTmXC5L7ik5aojHLXk5FLmZu4pyTxD6gtH5dmiV/0MlnocSRl26ufuu3z3Tf6eeJPvusdnN+dlcp5qN+eN7sy/k+/KKcI7TS/La48Cww1A1+DJ7rkip760kj2a3bzDEFVLNeE7/Eu9yqn8kXyt6Yy4k4NJclZbIH/9VyG7oTMhhPjGTkTdfl347psQWgK2dEu8az6150XglSuTcuI6zTwYZQur5TJgzKy4tSMARmJyxCDNkODn2O8o1u/cKCIyDNXsq6KsLyAsVw9+g7s0bcg1hU3rYI9+sbFzaDayWyzl3jsGM4nNNz7OPhy3KKwP/evgfmai+3t4r/SuCthwk5Or79gDezJ53DbpT7qhtvZJLkFZp+uOUWWVNiSSWp4ZSZ7i3POtDIq3UCMBiB1af4nYgZ9k3HgaQnibZRK4meT24pxtGTLZkt2dQyaz0hJuB9MjzjKPo9KRtMI7UcclFL1cQnsL0gWmNOU+6k+4bYJ1pUWW24reMOk3SPZboIV2iLuEUoTl5zQxy934/q91yXr/FZMpTIK6jkobnqT25ObYXDV1naAdcY994GUu8pLIcRNMdBHUMJFr1CaY2NqtoXpGXrhx5ebNLxxGdhNr0BfxVgkH4H5I4TCyb5ATjrr5oo9v/4LVjbwiwT55m0Wm/8qTsyknOh2tIIWAFKMHdwicqBROJSRMhqZXFbxtX0gxNLylI7wSl2sTM+3aIitRQyEzoBi/yCvJsST+cDEpOErjv3knbYjPf/gzuPd5Wz55Gj36ScoySDutIU1QNGGzVmdOCbBcI1GcIqiaO5+n19Nia2Rii1q18EaJE9WUPOy7CbUECJeDEbm6F/B1eHApCRE11ouk8idgVKQQUjigE4UcAPbx8MWgRWwsrLPDtKoQYeu+aXsStbXHMwJroX4saS/H3qoj9PQgMnhWGp7ZQsgwDnsEmfG18dypfIry5IVcxw3joPUBCGnf77Twp6d8qB/YQbY+wyqrC93QZGLR5V/v772xjw98FAIWfsCALzgYl+7WL44sGI3l2HJt5+SCs1XxGLd8icpKEKIu/TZJlT4bLkE5HbzQ+L2O9IP+nbBdXpmQiX25Ghgi4sktxMamD4F6aJHu2QgjbTo9bdPR41wV2qgEUAn9YV2M+lU4IO5Z1zYyBfbgJKMXh4vMXmALG6yqK90MPrI0XKDA0hwBKQ5c0BdgxSgkttW0R4C4Yzb5qdwXFAgB5fp3NhXixhWIRdSHhsrD9XdOxcGaL93ABmHLp2BiAwRi3t99O7ekQ7JsPTe5WcufdMjWqmm5jq1aTBJpbKAQTWlgmnp70cWred9kjWqri5R3y/bsze2gTTZwgZcy5dgWWnU/FY8KuZHthnVK5fv7tQ9SwrxcDyjQPqimfFOroUXhw81VBko10RSzqe7Ge62cNuybuGP/ESnh37uVEwiPNpu6tRae95Q357lPP36M246NWADhC+gUrbP9tiol0vciCIOKVerupmnm3m6VUhtNFtdOdIJjmnGBJnGlTViODVNBlqWXdP6Vs36M2q14RNJ2HwIpLu0dOmqdT9KGJJaTQSfIlZBL3XRIxVL92cB+CmRXf4EEbzx2gegzeUO0J/pj05oREWWVUdnDkj/E6aeYlAu3Cbg6h+F52xh1PpPZOZM4CX+ru4cUfCWEW9VD0W8ApBHpr294YDNhp2SGVHFA8g3JQoORgxnVoSljWsFk21plZP07G6zoO5vd/IrkzQcssFDmFjByJqz1WoodFvqjiYuQpYD0IS50TnbgcOVzcZ9vwEkxYiislq4uyHfq1aFtS8hjlH5ljRDoZlwlxOjGmVETpdYqEt6Q/nuejBtQsb0gBUlvegzootT0yZRtebBJ1leQqdVSw7x+CxRxreA4dNpBFfy+ryh9btKIBL3kl7yIYJd9/ud//hNdduvaquiNVrq6AUUvV0DRZrzXVvgVbhOesbNdZGM2G18p2TpJMgvRxUxvtXVJ23UM+wTL4NOJ1mq10Fx8e4Vd9equMArR7I42KHYMFzcruRoe2bpoIRCyOY6yAjFByBmAVR7eTrxH3BgnxeSQNrekpSegTd3ehFqv2KVsE+34g5xMAjuSqWiZK5s4vw/GBC2klFdD8PfyCD6In5tcQ0tN2nvH424mkLYtD7LmBCxFUrHugEKWIs9JviVH8Urt5s7XwYumHdiO59CqT40s3XKcDYU4dvyOJLuMY+ksXS1jbePHciknFW0Rz8sUJ2uPpa9DLueiCE8/TKZN6GpjTjk/FlMyaV1YMjOVZ/l8PALmmF0xvd8NQ/xeGMAHa2IjqbumqNRvyFR1ji82PrxCDkFIfV0PTEnRDXKFRUgA1hMPL7Z6ihuftJKKfenr6ro6vnKGBV+xMXaEG3tr1n1yHsrK2kCD+q1o5L4oLywZjTBkwZ+D53DU4IX6IiRdosMhZORI/wrQZgslLrGD3uICg+BMlMomLMWfRAc4dQNc+9xQuCT9VainFK6klsMRLHS2yy0Lra/DSGhwWze70hv7lo902BLePUtKgUKtmOMWoi02k+FZKiY2p0PM37vafzBUP6hyiTmv4QkMe/9E8sDX7ohoGlGpDjMxNFc5f0STJAr5Q+Ep+BtCzu0r4Tm9I5zpDgV1a7Kczfg2aR35TLp4kYqKcGze4iLsmrN0i2+NUSwvIl6Drq07KhTiDmw3GCy3PS6gCtnSBEs2tnDdYW+l7Pdgt5d3A8oHtuBmpAbLWqfmqCArdY+dSJqatHxjDGLpBmF2nyCXNe1QJPInIDK5g40+6VVcYLIU7P2nDzRFEbmgLaUKyMYpfZJ3DZ+DqIkV8pgNy80dNjxagkAiOoRIoQUIMUVpZWacC5XKP3PshrD3CchIGQMFu6Fe3Ei58hXWchVYLpvLyzZotdvYa6yzjDAw5DWX/KFHcg5k07TqTck7LRUxzZ+cv1cafjA6tcrQymWThmJdiSJhEIrnjd61tqApPeogziCOG5Brn1h/1EtozPr8I6/hjBeH1LzbRwN51HbemwpuJdqI6vvFR0jJ6CuVFiFbmhMI9S7eSqp+L0xkqcDa9QR9zOods4pNPAXAMD/o7iB2oV70ypn869EFiOeAzefIaZg5oUYYzWKySJyfYPCohVc8bXhi+2h5IKc1wx7Ox7Zosb0gxqoUk+ZP5IrcNJAim54n42xUL6hYlGNZUKELmv9V6lHyP1KrvkhJi62AGSsSqEImOJr8vbB+8aOh4VxoSatIo67BSlzP4SmO7Z3Ehvrv6rGS2Ekq72FSt6c4j5HXvmFvTE/n46R4mcxPU23w4stveRLPs1NIYEiDwLVp0Ixg3/IMDnP0ZZiZwF99yxPAJZG0seOn38CwRdPI9fp3+qL7bjJ+gY5Xb9OiJGUZ7vWstY5YmSOK5RWUThQqK3D8+E33eXoOFaQ2Tk7Q8PC1Qxzh5ENQYAmXKSc3NhfZeBwluBUOzh+l50htJ4XRT+ck+gzyTUnIN8/S4adDVkM63iY5l2ipaAjMZ0H5kAAMdYWwTfEwSHo8yJsHJgI0LNSe/paU0f6LFzvbe1sQbozwR28On0X3o720usiLT/KIYPOBLk/H+XEy9oyWV8Ui4oKXGPYogpJz3Sh6g0b6r39N8V43TIoiS9BHQfbfshsd5hNI/YSeos2KZCFIzpNsDH8+jr5/vnH0ffT97v7e4BX6ebS1cfA9RjRKKiRJ37/af3MA77f33gy20C+HW5v7e89JkyoDYft+4+3Ltxs7b7Z6pB3/feNd/fvexi7++WZve4B+YvATqJUekYJquGSWgKsv4OoLuPoUV5/i6lNcZYroOBKRkbRXeYQT4Fho+k2TU6CAQAA6fzr97+nksfDiS00kjTB7ECT44mBdsVVP4eamCLtvpCNscdXqPZF9vq6RQnp7UaT/XgVykoBCalL3Zu1JAQBdBMHE/Uf3y7gDv/XW2G/1o4fslwfsl37dmv3y49r9CW1U/9brs99+ZL88rFuxX+o2PQHBWY3gjCE4YwjOGIIzhoC1Rr9894FQ+gpuzD0EhjIVGVISP8vF266gst1QroWKHSeP/6CH9Loin7CnwJlSKiESaK5CWCkAMT3VlUvILb9QucRYWfEjKa2IposrK9Z7EZ8EswpdO8y6vLVyHGXpCTJxV8Vx2GuP1V1WFix6X9Yriyo6igC/HBKuREjrla/tOPtodQpF2Q9D+aAIQmmI37bibGVY/Zej6GOk/Xv7EU+Nqhx3udCKPgXXIcsGtpm5EDLxcbRptddDlyANi77y0I8VX98P0rK66VXR1pFhaDHS73Hx1bgTxb/if57Cv/ifJ+TfmI7/JJ9W8DUHDN/SlE7iekXztPRiWfs30IY8JkvoswKJbnSIAaLdAXm4mU/QgA6TaRntHrJHc6QtFEhLuyAPXiZFMkFqBP0rzYvTLCF/vErH5ymk7CR/bk9mybAivw+Ss3xCnw8yWCuh9tcBejalD4v0eI7UwqruGSnNo2Sa1As92eheI208A2X6y+yrtu5McrQGorLW7dEfffbzQSzNAK76v8zgDT2Zxr1xfkrOCiWMeBdp3sJfySX7i04CHxnlLbEePlIN0+moNFSIUyvD8TJXuVgjrpwjgBZ5JNY0MxQC9lR+sUDPGD9BqwVeWdqJfkZrVBkQn7XW2gGQPRNkT4Lkx/CPk2yqFo8T3yZgL+ut2d5DVjfEu13cjF+oau2wj2dPK4mXplMXQJ8DHKQjS0tYjOiMoRqIuOqxpSfqr3WkUhIdcrvbwUN2UAbN60UA+t4i6KkhZ5dUCxaMJt3n/E33+fbh652No19sDDg2FRwUqrBYAAZn2fDTlESn9G0t63znmwr3Qksi2pH1rcjW1vg/NmSVOPpHdtE9nKVYjemJTRK5mnVZf2jyc5HRbGWB591XeZF9hqx8441xdjp9nZfdza29wdYBd2HE7d7CIjQUWj3bHwz2d/E9LBWPmBwY445GC9Sm1/+J/9MOaiLIoUzVNfK/dttFiN5/KSGsJRiFNrCpJKfoDM/XXJJzm1ewdTQRfWDr4olKFXjLlsPcbBvnoyCFKskFiXxiFM5p4o2L4jqqHQUtu418WQi90quwMq04iG16hlQmUhJSDcCdHZXsw3ouUwMaf2JUXMeSNA/C+Bp0VIb2cD6ZJC7sVFniH1dYH0W6dTlLpqN05J2AMdusiRKrKYBiYlVIwtijHOlms/mwtvSeoEWbmJPT6BRviHLOVa0js46qNRNTr+o4pOgC8q2l56xWvBmZS09Ua6Z6FhB6FWFBB+EEaDRtv/M/o5EmXYE0cmSom+ZTnIDPAonz1p2gU9t0NBaKsbIBZSXBdJAmo/3p+CpwPN2sZBAugUPi+u+QlSGChrEf0+oWB4JvifTQGq5tTJEcUWQzGY/tyEiNcZnqfuzOw5/d6ms4EDo5FbIwUJaRG4Phv+cZLZoBKObpdHjVhVSCruspy6oBCELlj0g17ZCLdGnAaMjerOMrJXx6NXuVXvXR0S3etcUgDkS2OgkXRxjC1lf5RTRJplfRCC66S5oYPDlhNVRGCN0kGUezHLE0tOcAsbUaVayya+rKKzd1S4uocExueRFtBuYs9DbDQdBCSAvOAFzUixvgXs1SpiBl69Oq8K1OulXKhkj4BqEquTmEO/ER76wDBX7g/hNeTvIi7dp0G6lnr9hJrS2iJ2N0i59qimokgr3GItiPG+BevQj2ViyCvZsSwV4jEeyvUAR7jUSwFyCCvQYi2LOKoGywcwveLjraT+YTgin2ovKzkNqzC1Dk/fjCKp2JY2T1H7H79PGVcCSSepM7stTtktqI7FGgTSW7VHOxnxXJpYcVyWUoKwDVKlmBhxZWdO5yKVYkl35WJJc2ViBoDyuw0d3LCm6id3MElxyNEH/vI8RxKMYVMkYaaNABAUYMfAChvB9N6lsjK0t4F17O8KYWBgm43HyS7ki87CI3Jd51LNo01+w0YFohi+rBhbCHXErgTUZc06zMIci9jCHNLEyhONwMqS+jwpjR965koczor54Z/ebMEFc1NzP6Yczou5jRD2FGP4QZcNHnZsWbaVZF+Jou9iPycwIQlQGYFlMd9ZmFldeaVsRrkdCBGUox9e7DLf4cykyMsmFSKSKpdOjlLTSycBbDu/lKr2VDlDZ6y+pf8+BT87NXxLgKJov4lma1NN1FGU43aeYjYVcFaVchGiFtalcMGS6vfsgvzb3MF+7A3dxn0RBQPzcOxhhwBoML/PARhjAMUNIaK+OoPEtmqY1BAm4vh4S2FhaJ2Nw8kj0PvEw6Xk01cRvGFTDpuHFdccwksaq4dSM89lUMN7e1MOnYXT3c6tgRyKTarSOIUdyNIm6EemUcE4cbwjXutULrcY84G938qyEDeVi3d/KRYw3hpehz4+en4nzjYWjdmib468XNkK+CpfqIw79EPv7TIhllUPCTTsT+YSr9+TmrANhYq+L18Fb3kmrK3H5D5vbjZshXz9z+apjbD2Vuvylz+2HM7TdjbtAxpQpbgzFp+Arc+nvbvQpXK11/q1WsvB3sOpQWQ8RREohFUzdWeQSMnltV0yp4Oa48C3EVuARXTRZf5jroP/iX2MPQyzyOcAW8E0YXwLq7zIpJhipunHbuIZh76MDVjQZwd4D+N0lp6OU4m6Azdlyl43SWFxUuh5fi6/aye9duCMUDDrGG4oZ2kyjB47WLMsdPidPbJb9c2CjL7HSqD+lOq5ljTNvFKM3T1C1PQrije/s24PWLFcdeNkW+9KHXRIggoxUuLph9xjZ3CAGNZhjetqxo/ZglTmtmkTcdnUHwTO7E3gVGc70Nlox+3BDvzUlG7wYko/eFJKMXJhm9QMnohUiGohrSmF0xLcWfNsDliwWuiNQyha7I703BK1KLObh+J0A6NUpAagZq65yFpffWAtodZp/T0Lb7SMCLA6wvUbBffg4As4ZwWNr7YkQsYC9WGl4jdVLOj8XhkYjoR2HNKaUCW4u06oWOpwG5pkjdGKcKiBKyZASYVugzUOCeJ8WnYNiwmRGQHZwRDL6yX9aCmsJ5p/fI0/T3bIRzDvna7XK1bK37yP1Jhsjcw45IsJdFchUqdviS5Gb7CAvLMoCI/LQTafnQLBe6BYKzJHSfczQBHlaF3/wTPRNpjHA84qsGDwf0YO01wXqU4tInboz9JhjRZ9n+JmLJWKvbWLLbWLLbWDJnLNmXOfbfBqrdBqpBoJoakSLkNLuNYbuNYbuNYWsSwxarFI+/ydCyLxNJ9ycNYLsNTboNTboNTboNTfovDE1SjdVLBSfpyPxsJDmYwaZpu94xDPGmgpTUriyZxZRWIrM0DAYmGS4IQpizZLiSjmz1zLnRsCW1qxDmyJExGgYvcxzxMJZLmgDv/xPcMA7HuHJGScMNcpKC9Y9kzD4Gfp1n6NBMeFXn0z5O0YoIP+C8SVkKea9xkwRUxjIqs8lsnBZ8pBE62H8qHYzmQw3gN29sZbuAz8d96eYtQAj4xYzvQ0XfPKdAWaUzH8NE1CuXBmncYS5z6IRRIOUauF1dpClixkWOz8vpcI4ddCbyHDGX7UzmIwhgMm9sZbKAz8dk6d60EZPheq8Zo+E+sPX3dtyshxvkN51C2IqtM5TMiLtodSQHLey/ZfCxc4ylEfcBIEACMN5wKaCXto0kQbkdbyQUhECNxELr7gYlRJ/awsKSAyo23xUJjTK8RvKjwAaIktpbuFTp/hONBCwwZkIhe+1PGi/Qzw3KVNOQCqM0WSbn6bGRgBgDLLw9hAuFP9jC5SbTSBQs8U5u/DcoAk3ioIzsNwREubpqxHctOMqJOZzf7kAph29TI1afGGNPndhvkNHLhKS6KRIcmDovU2Ks4TQaJ8eqI6ajs0bCowaouvCGi44zWNXjsOaxJs6P74nrxNwrPaYeVi5Bxmk0St1WShNr/dBr06XDe2SZB51Z9BEGyIkOZJUVA36fvBidFZvKjF+DlUUm8FRj6ONmhaaBuipPaFVHG200TeXDqZXq2BtJR7gWanZSbSIhoXqoraeblZOm2qhJWAKUUXOfTUXCr5Ja+mkkHA0VU90nudmW41dNTT3c9JYTrqCaJMKnn+qdNd89XFqqAX/D3SNYVxUcy91838MNgxgu4fRzmmBugjOIsXTAJ9l4DDZtH0+FDgKYKbS2clHE6GOf7N/fgG/cvz+QfRigERvFLlbMTWn0DZgqTSOAqbyfBrzlQF4WC/hDOS0FZjRleOBOrlArdCu3dXUTzF86Q8dUmmOgKDTZws2AYSIRvoVbY26CRYMG3wRJBD4tBer+CvaVCgEfcwjvSWuF8bOkqEgqb+wpmwsqA04f8Hdf1gD7sIKFg7b3yATDGiYKPJaqoQT0gyTgJM+rRSSgfyMS0F9aAqA2841IQb+hFPSDpKDfSAr6TaQAh8sFycAFDqwL5T/Fu1Lus7GG8J6EAUqsX5i1GFcwY3FrD1sJxjCmsoDGYJbuBqULqdd2IWtI3Az9Spm72yyNCB2+lE3EwOAWmt+9STZtL5M7xDHaYKnYNeQSceENk41dS24RhytQWNbSnWyaWlJbWlD6hWEAeRHQ6Sotg5Gu4DJBmHSza4RsiteOio06GmH4Y9gyAKnHjynsMoE1dfswhVwgCIHKIXacOujYY78hGVxDxUFEuwLeiehWKF/S5JcUCuy8GBGMDhNQ3WOI6adubDf5cHxeU48YXh4gGStKr2nHuWjKKccoV5Bi04Y9gF+WNJtWjD6OhaTadIXqL51s0418hfy7sYSbrr6COeo/vQek3fTkVAjh7spTb3rQr4bBXyL9prPHED47UnC6cXs5HZqG05n4YvlEnB70N8Hqm0nG6eyxOav7oazuN2V14OmbJCVxMxiSf3i/X4bIz0pAVwZiW4HyVs8wRBjIVME4gwhRpYVDlyJ4A1hOGloZTfH42Ftnjwllai+Aqf04DNEKmdpbHVN7TZjaD2dqL5SpPTdTe2FM7TVgan9VTO2vlKn91TG1f0NM7Ycyte9maj+MqYHL70pzofowL5nz0od+BRJwoxlR3T0tkBPVg3CprKhO3EvlRfVhvkkp6d2IlPS+mJQskh/Vg3DhDKlKSrY6Laqa/HSSTTtgXu8QhVbu6jwrM6DGU5ImTEx9Q6KEaaxx/RBHp9IYV/ZwSE0EQ9H0gFPVkCRKZqKxrn/j/XWr/BAxb3qKIH6I4i5ON1J3LL59jGvfACNHughSzO6P5C1p5IBeUV4lPprgbQ2DZOOsupIPHxSVk56i6LH2BhnjjDevP8vG5ZNQ/NVQMDwAH1NvYh2ZNbxeiai3BNG74uaXDZUn0fEroldwTDyhl3Vk1oh3JcjdEtfuCmUf+g27luqBwwbGVjw/3TI8tFtUh6r5dGizlQ51w6icu3olC/SFKY1szkP7tLTItyv67Yp+u6Lfrui3K/oqVnRhlMKi657lvhh0bvRmkVEFT1uMZncVGRJCheRbNaFfM62EBiLFRDgD3eTtyEy9C79/1+92x66LBh5XmFTES2whIl3YvawuVJeqC5v/1IXuLEWVAyWrulUrgAy/HezrSPUCNJkqGWfDTnScj0dydzjJ8FMh9TB5XJKIq5IGdVl3d/aCdIDekF/EV9AnegE/GAEGfPM20AoPCW35Ed/xYRzClh+sVzRDhQUGQNzShj0RoFlsAXYmqoSIZ0AbnKZSQLyiPYFOMSj+AAhIr6q1WO2pgTqc7qK045YGYafSZ/7wS29sJ+YENIstwCsiWNkgOhM+HBvBSmtcZalET5aWGEn6Xe4m1VkX39i1emtr0f9EtOl9Vpyl6f6KKTlcfpMlPh/C/LtferMlC5B7ttu4TWyHDZnqdllPMiqrK6Q/E/Df5CmTh+Y588WSTZq2Nsy6XmHN04bl1ec2MzacjyjcYhMGYGW68Mg8WXEDKFlLw0TpfqHvf6PsFIhA5/inLe00K9IhOnDhDTxe65LbmK9ZAuokoHDLw58NpUXspVtoQj1HWRWtdIsFpO8AOSs+47IVkxRP4Oi5JCDdV8Lr7sH2y1cDG/D+CQikbirZPzmA/WMXn/WAPqN8jg7Ke8m0tTefHCOW7yV7bQsQPvA0BHIXPLotjnJbHOW2OMptcZTb4ij/7cVR6GZ5Wx5lleVRVluN5JsrtnJbHuW2PMp/QXmU+njllu3XrFkciGx14i2OsFGSOHwALqPyDGliUXJS4SAYiOobZpNkTMLBu6FdB4hLTaNFZKbuyis4dUuLrHBMboERD9aNSpjcVtG5raJzW0XntorOf0kVHWZpO/HGTpvjpWX4kAAs3N6HaDFxUiYTFraFQfTrGRGXmXcnSkizBGHgzYkraNlmJF0+PNKOeQXcWjguklA9ODTS1p+ZM7bWJm6FxEI6LNiNuLmCCEg75tVzs78ybvaDuNlvxM1+ADf7DbjZ93JTvCVwc/JV8RntzOw2YpJWZ/koDsS7Aj4qAw07VzAruHvgpi7MbBNbmFglYTCwSbnQCWcNvsBpwp/8BCDiJshXzCQ25IU5RaYg+yl1o72cZgCKLs7SaTQ8y9FZLjozIUA6Drn18HIbj9XPctzMx3eCy8N8diHnlgDphm4pD1ULRj/LcdsI0hgW+TgYbwjT/99Bin3BowJ3ITmydsHySQ4Dp3laRuBmV2YjcFMjMASIun+RSmiEZzl2MgQHjYKOHFw+ujspOh1Ex+Nk+glQX+XzaJRP7yIhopmmRukJ5Iop58OzKCGw3ej/meRGmqrVV5A3McmLjMPsNyjdzQbLyZKeuRaMNyEnoX67fwE5sXkWS008cmL2Olav40PlJCB5kIE84YhvQGCaZRLChkTKddgniJBkuO5VPS2zBqd06WOdllXIhsfJPncuIYZypTHRDqRLBro6MC93CL7RIGhrJwvEP9txLRX6bEO7VNSzA+kNyUFv1XLQ+xJysEiEsx3XwsHNog3M6iKfTUfppeJZS0ysTZz6MBYEsWZ6iH+6HNXhvnxYX5aTXokzDJoAWvhH+IqwJWAVbr0RIOqXXW4LBxAeBscfb00twXEhviOCzTWqrmapHcsSRmaGIuBSCsbTzHe+kdsFMQOXwn0tnXtr4zwtElCWmIoFtmC5MvQcYgoiJHFwLKvSAj2WQ1JcvheKBEjeR5z9tYO4wQNDwlNa8XQiyy3qkAmdWyIGKZpfLaCxC80SIiFgcUoFniQMqZlQCOhX5OgjUi9c0tDb01Oc0NFEz/ppkMjYFw3uU89a+AXHiE2VHdlVjmBwrqt6SCzgCxC4t+YTGQVfQtDYAEJ4hgdBr4jSSOKgHJwL7YJ4hjFa+UXw+HmlYXF842gXmo4gHa6H6FQwk6HtKxcQLfWdiwMKYcL/Sc4T0iwqp9lshjCll1AXj2S3vYLSH8dFflGi0acJOohW2STFDCM3p+iUQ3kGCbfhDDtMppAcl4Y3wLoB6zjSJjLYOMvH0feHW3uH+wdvN3bebH3fib5/s7c9gJ+vfn++/Rx+wU7A6Ofm/t7z7cH2/h78MTjYfvly6wB+fb4x2BgcvcZt9vZ//74bbV0mUF0+ehw9qapf8chad39Piil0TfChj0bq+M7d9vqT+6h1Nzqiox6Cu180zk9LOH2js/cIn+DI2bygEx7m6Mh/kWul6wXSB64vuD1kDXasMBxnyBpjxGiV3lEK2mKQ3OKmsQ3DEgLLxhBUDZaqChgGx5SWKazBZUcq7IjZVOIE79NPiK9FeoJUzqsIrpwnySewpxQpltQLbG0ZFik6eVDuIpUdgGUdHfoL4ulz3NLGTYLHz0cNi8xBqpqjjbaoDtMiS62K+Sg9SebjalNLZ1E7n4OrPyKO5AVPNO57vdXG64BCoWr3lZD5ti++GKen6RS8SuPYFDBrDui42rjMym3TKeJrxAGxsYo8CI60vVk/1ugHq6NvNyvRQZksYQg34I2je9H+ixc723tbcS3O29OsImFdHSQHCPu2dgYUZQz/bhAyDhrkqOwKHnCHXugfXeP4Cz7w/8JAjC8RK5HPrgb5IClO9duxOoXOnznM4LRIZmd/3SCD1YQPCHj4AnKH7FIMfMlVYvXRCUsFA2BX7C/swb/Ut3YbBPBfFgQANAZjZZBIQ+M4DNuN2CeNPS0l78L0gyqNIaX2jMglbOl0I0B7EbPPo/Uun4o7Aty6w+EEblWhHTqRZ2N8awCfF8bC2AWh9096rz7bPGbZWO2iBdS0SFANbJEiqsKb1nx9ra51kBVpWy5NpEDHwAL22SAJrVs7xVTAuZqVV0B4I2ungH8pcReJGSLv5D7kPkg3llnR2l/jYoWSRul5NgS5vnecJ8UItxrnYGJotFybhttkNRWALN8CbxG8pKogGpGrsIo8A3uh3aphgRxcp6sGkq0albsATmWqdlO5SttU3jo25Fjvnv0ObhPbYYOUg7O8qGiBNpLeiybRwQdOhRAEs5kK5J1IAtraMP/aaPE18/JhjhvqWX2BXEHc/uLZ2nHD8B1dxOui3lGUoIaxGz7o4v4sz8s0usAbOcFKFi9Y0i7Q2Ts6RpI0TMZoJ69ymc68MzOx+XuR4gKUgeySYesvH4t3G+L2Vw1xu40cq433ZJdT8+pYDflyTynxQDGlls7P02KczEyvZjk9IT8Ve+++po/1nE4hmax+suTXedBn/2/b81odnyoZmjiOtbVOhBGxf2RAqSKiLaEVaSVqJdKVxiwZYc0UPZYuC85pmqJdpD5jd2j5NXf+tzSoimRIijS/SIB5rN8gwz9j7W/cz8idkZsCuFcDq8tSDb0iuykfTaCWNh+P8NZKdSfsIId3VxyVj4g3zeW4EtqDk3riF8zaGz5Y/hlZEg2Tb8njuEwaxQ7oIJUjIecjQgD2Fdc2ArwIdoAeJaHZRQpL4TgbZtX4it5qzpDc4ZUxq36T0w0TdBbfYvJSSjNM25t8iOv1xUwztsh40kXQVrELPoRsDBFT70UxkpAzvGYasLciEWoIAxWEpdRMhkWDgZeJ3W0Qs7sjfm1on6nQ917iCF5ZfQ4P3V0oZJeu/w1jOmMHnsaTP1awK+k3Tx1O+fSllITz1Op8z/c6W8bRBcosm2jRuBCyTA9rQWRvDWRL2WNPpeOQ4sbKRr50PWMd36J0qoymGgW/i1xGK4sKbyWb3+JClRzPckw1odgBHhjGjH0UuDdOvaNReoHuzh+ylUdeqUmXloWavJTWadretEzXGp6ZOLKm5ylqQtuivRZrfbEfW5ALJEM7CqIdTlg0L/CChWYmU04egKWUidRGco6UoU2FTVTF2ExVVUH2BBLzWForZQ0YVyeOTpKqPVuidpVWIlk1DKZYXf1IYSaterQIsCZG22hawwTOIQQmDsEaQl56ukEnBrCCIUV7DPcN1MJK96eMdc7ybNFrAKuepo7FYptWWkkmahWDyVKtH9FM1aNs6W+tx3QWdA3eUZ3ovKiEv0iA+VGHadcdHBJE3j0jygH9g++I5AHoUJAIn/wFimP9chV2ARyZ9BSHpqSPwbf26Pv73+/u7w1eoZ9HWxsH38fysRkRY4Bg8NwE1ydsTahf0BTAGiRLI60CWpMIm0wY+5iW71Q3P9zB28I8Mi378GD/tR33kYo7xBjS6zewhuAf36Q55JFwt3s1A49DJqlwuRujdRKHJY9iyR+HyRFrqyGhH4ATh84ECqVjowLtwsaFXjjkSliED8+JibNGgNCxyV+uG6PEMwVSwywuAU60uEgELWshAmkYpWXEj5Ld/EhgGlJxxXPzWflSRUANq7iq+rEKC4wIeGuB81jgeDzoX9IKtyLyLmbV02grGvioV1AE5cpFE5/6DjPk3/M0/UwULsXoVyu3X832Byu/L/QMbRGxDTCAopJ/CFfQJA0SIbNojeiNpClCS5N2SDYy24FaVH8Cpltn4Yn9uELz1+IRZiXJPgRhVyALJfa8Ad+aaDIfV9k9cOMvSVtwNeoqx2yxb9tpW2wjH7olaOPZW1ETHeRkS7abmu8ih9lYRrOij10dXND1pfqpv6styTr9GW4H+VkTjfo1rI34wkbottVTbdpH/X1Lki8dTQidODepiofjuf4eRS22zEwgzg4Et2205NPu3AZ92shk12fwDvM+P2Y4hJdpMT7fFI/wcjSrFF5hcAsJ75FDeBluh/CyJprw1rA24RV1wwDhPfJRP0x4j0LDPFYjvEchwntkF94jv/Ae/VmvqPChXU8qe3sjdXsjdXsjJX0jt1dRf9arKK+h+SX2/VCLMToM0/97a5i4NUysyjCBPY9UiwRxR7o1RdhMEfiTvWl7BF04cExWgfSFtFipEyl8XTixxB4pKG1sMMgm6WGVTIx3SuCu9looIGMeafe52Kz7+mBrc/twe3/v497+zvbu9kAuaIrGAjV6lLqiZ5DwJN1Jp6e4znv/0U16sH7zdzaUVohQ2Pe43gVRg7VbC7hno8GO5hWRUnWT6X6tXUb6Fj0+/6hpdEiu38eWKCoV3TIkAlz4KR753ZJd/ZO+ZYpJ/VpS6YhNpOR8EqwpfY6yXtkpWS9aAZSEtiW0jb2oVkrFivWrU7Du007BuolKQQ5roaC4oFsSworL9cIF4VQsQYap6CK5Ak1jnE2yihCQFygDDSRNINXXyXzM6rqxgFOB1kpWJ3EclsIZYhMpk5MEayqRoWyAtgy7ZFPzeUsjHSN6TtvGLixBRyNMPIyTQWLz1Sy71JPTkve2siLkrZyClkIYy4bUW7jFc0zYyz1eY7hlBBfdsQ9NCE3wjTn1ISfg0sFxxEnGjo0kskp3YBI7t3iLCS0kTzER0uQlJms6f0qr3nNx5Rsnx9TE9+17nS9r4nvLxSX681r3VmHcEykhmGLoV3dr52tOsr+U5e/LGP5IvQYa9/K13M+1Y5ondThrXvuKx0EogzJr0szbDLOgEHQkSk5yyOwKJEzEXfGEJfxgaztSyUCn7EZvUPPPaZGTwLTpSTbNqtQ8A23wFrVDbSan2FRxmBQRw/lYtq60TuZTktTRbLnoE4TEziJZMbam88l2lU5qa+1R/YQMQbTI4E470dl8kkwLtPfCUbCDBTPJpmnBc+iU81lqay51ryTLsYy+ax7yU/NU1s0zlWeIh8q6dNh0qDnG2FEr1prHHaT8I2W+JKknbch7oWh7gLDnRrYWjG0No1vr+hA2wMhQrnlxNkFaYxXRegVDFYj1767blg8i+s9/opbVHvm/1+02MVnuJefZKQQErNRgSZWdnskMh41vfeEfk/2uvwAk3k0GNtNcmH1vOC/KvLCaEFG3zIgop6UlcM9Mfcjj/+VH9v+2lir3FckVDRtUzZbukfimu/FmsC/CXcJb65zxW9+Ugxzp1xYyyt5aNx1Gpylj8Tdj2mRf7fIVegVMIVTZ46QILZ/LenAezXqGs1nPcTjr+UizgnK3AqZVkaZvJE3fSZq+gTR9B2n6niPZYLEjWRyArhGZDEeuQciRa2A/cg38R66B98j11Y73XICefYuOO8KG66YLnwcBiU6gnKOFTDLWxQVIwGNJ1cYbSAnbBDhT2jZJy3AR5lmo2GjkGacn1f0iOz2rHB5b1p6WJdkzn0RpzXTyPXNLl0nlcuTBYypUSMo6Uh8y9iIKodJ2Kez0FP3nPJ9EybzKJ0mVDSN8ED9LC5x5+wTpV9EEHTej8wypZIgcFURB/6YntWMDceS1Y0201HY1rC27naCLmokqa54+X3Wass+66mvYFhdAGZWZOHIbkToKtIE8msrtoE/Ah0tpY1nIJCzNlnsRcVenkOPb5O81yli/RumosehVyLt7gCX6qjciGgG/iMuzlIWu+VG8yqpxqlVnaRgijU+GenI42R0LOvI7csVWwAbuxpWKCOOwuG7BK8l3C7c1OW9RUv2Z80R9SZE8SuTcsO6iox1yklXylGRldjxOPTkQsaGj+6r4XCdA3Nl6IbmcTXAmDhDnUT5HCPeSaWtvPjlOi+5esifZUya4HnZQ07JKZ6Fthy7TTq//E/+nbSur1FP99l4WmdGGdoqeO01JfbDKsH/aKqjVKNTQ3iOvCrrDXZ1kGRBq65dcdgqiZktW5Omf6A+xJeryEe92BzTXl0WaTnUMPQsGAP+ZozhKIYuxDt63gANob43DH6QjCZiLMZZxCx9pJSU1EwaXc94g+s0i9NFjw4s6HWiQVY0NNtiqRgE8SZdIIwf0iqxqfDSNrGpJRQhXm9R+kzUfitZJMikHE21vSr5US8M3kXjxKMLzruWsBee/6H6ET4Dtr5l6ceLLOMWqCJ6bS6BOgvNLEdZPRHQddA5OztPoeJxMP+ErT37sOk7PkK6nKscTW1KpiZxHamJOHTVxZItCm5KHEmK95dgC34ASIroFKJFYUqajFxIlEmOSdLIFW1w/0Z7r8fhELQznRAoYTgO8u4M3WfP5A6jFrxO9kdw5oaXJi5OoFl+z/ABdFza/SgGCL19fY8NuZ/gK5TWYWhDg3AzNYheCwH3wIgLlT8hyF+GsEx3j3RJDb/dehreq4zKGsPgsUyXITI5ao3XTA+OwiL6IIoQiL03EMNlEasRmWtSvRWJwGAM1RPXdTo5AAxqehsN8pqJanDTmTiT8dgoZLWoyrIVSfnvaN34y3/hipqKvUb4Hz84QwvKFKvWQc6N7nnCaM11FM9jNpEpP88IuARhDaUewmAjVQw8hM5lDNEsK4pgvj4agMhObvBOJTVsbiF2fwh3E7gUQux9bYZcjdm8pYveaELvvJHbPQeyeRuyeldg9N7H7AcR+EFthlyN2fyli95sQ+4GT2H0HsfsasftWYveNZszdpAiMyqX1wcGMHezvxlK2xupDljOHdO/MxgphZkV6gv5PHGAh/Gszn0KSZ4BEfx2wt92NZ4f7O28GW8Z8qdN3eLkmRi58L8OsDC0FZ/5mml3CsxZ1W0SMa5uMfFfCKf+XRwvF2/Z+6fvjbZ8jMilF5BeLuG0WaOyzcVL2CpJx693ms8NNsMTbDHFf0KstLPXAMpkHYvJ14wsr4mD/r39NSUmsOu8ffXmYTyBUDUkgGnNJisuSWntIjIZnUVJG3+9uHPzfrYPB9u7W953o+52tl1t7z3vw69uNnTdb+Lc3e9uDnult//sorYbdbrQFvuBldp5CPnCIpKP84H1PstMzkiiCp5FAcoI+NvieSrRIZSfZMJlCPZsShqicmG44r2O1mpSO1dfJ5li5EzlWphyOlSt9Y+XN3CjtHx6ioaZR3Tb2oVrRWqJgXaKinTrVhp639FMALNxgjhaq5LjMxwg2wjWJx0kFn0+VRydZUdIY5zoW/LcIjT99zNsRpGV0kU/vVoBtVCQX02g+rbIx9Iq+dBCpYTWH4hIIlyIw4pRsd9xCE/muW4Q13nnLqoVQMNqoO3TrWdG2cF3l0kcOtnY2Bttvt+zp/AjiALGceW9EOK4Ga3PNZ/Q/4tjRNScCJMg9iQBJI2MiQArvSgRYK2gqH4x84sz4LYgHSL0IVR1l57awG6u3RSXcMv29HTsRNSq5MlOKh9HvlIQl43yO6AWvxY7zG3Wjf0IwG1z55VWVT2Q3OfdV15XpruvKddl15b3t+joJC6mQ3+YqrElxm6UwkEI1tBBi2r1NWWiLXJ5IxGPJJ+hTFsFsJeUXDGb+xu3lVAhffEFPtnehnmwyPgiQzpLxP8Fn+2n0o+TWQ9+R1L6R3eeHaFVo66y9eZ7tDwb7u6r952AJ+w+k4DtB5zTBc5t0u6+86B5uHuzv7HyLfm3gwUX/96dwaKNKP3Np04yMLSbnNMpXget54fpGuL4X7oER7oEX7qER7qEX7pER7pEX7kcj3I9euJ+McD954X6OdZ9m4QN3L5jbpGEELWMPmjCjOFpSxuk50m6TKkpmUD6Y5P5EG09RzWdoH+kiDfcCCqMxpRiiQu7NcqSFoz2mTNG6NVI2GWEg5pVUaCAuqCKcYV2V10HzpiOth2HEtCWCV1GFEJSuw5RSwrGdJMWATTkthmiHTk5TkZ6YnJjKXbSEQDQO3fmT6NHa3+kR+ALizWbzSsBdo8U6QDaC7C8K2m6E1q0yGibYwsBq853Cca4EW2AB5GTZOsb56amgRhjZSuboZCxpYmAthbUzt97IvgmfxneqT2OVz6L79KD3VX0apb16eVvbQUNb1kaBDbYjsljUNqnSasFKL5HgZ2AhJUsLhvkt0ixQB34L1IHNAnXgs0AdmCxQWs5kUVPxp3KG1hFrHocgDKHv73CBgcg2yqOLM6T449gAWEewvf44n+O3RZoMz0TjuRBsqeVZFkdhT7gstlIzL0sYLCmYFf3vazoevrt1PPxvdDxkNYlv3Q4VUtw6HdoIc+ty+F/mcrgYZRo5LNLd5+u5LDLLgC/gg1oHHPCLUYvD+93DyChK1yDCCpDjQxG1hVpcvRhKW2QJeSuHl1AIY4xJbX9xsqEXxIZ+7IBfig29VbAh1LHxEBsFwvjQc/KhZ+BDz8GHno8P/SA+PIgd8Evxob8KPoT6PKINpghkQ9/Jhr6BDX0HG/o+NjwIYsPD2AG/FBserIIND0JXpXxeVGdhfHjg5MMDAx8eOPjwwMeHh0F8eBQ74Jfiw8NV8OFh8O4QyoWHTi48NHDhoYMLD31ceBTEhR9jB/xSXHi0Ci48Ct0csstQNjxysuGRgQ2PHGx45GPDj0Fs+Cl2wC/Fhh9XwYYfg/fo83QayogfnYz40cCIHx2M+NHHiJ+CGPFz7IBfihE/rYIRP4X6e6bYahfEh5+cfPjJwIefHHz4yXhJjcuVvciLyesin8E5OS21eoO00pnQQs/FklWQ/LcT5RdC3mqStZo8Eq/PcKcfSbUgdpe5eZYUFS7i06IXpwOIls6tgD0r4PN8dJoWz8bz1ArctwIfpomeBkQEfWAFfZmPRyaws/ziAOnIxSgd4foXhktq0tIYo0AzkyRXtvbWi2rayJsbeY3/07bCmzIkY/CHa/wfA3iRQjT8wRynrgARygv4QpJx96B+032x/W7ruQ57KQSWqN4ULUNfVxuXXKDUREKQ8KVOMmWA69ngeqZbewGwbwPs2wHJaZ7UbxVv/tWCnqZZjniWbSEBuJ532wTLUwMSSFM6bhkukYuN1uT1FC11I+ktgATWGJC8d5MxzLdec+oL9u0S/jxE6vcw3ShL7Etfr6BjuIJD0reTlWBs2j/+Ix1WXbTY7l9M6cKGt5+yBZ3RfhlA9yQvtpLhWas1RU3a0dNf68T82UmEH3bxPVf5O1I6WzEefEnXi7jN0/iTcYBIQy/vAfBD92Va4QIfuOdONJ2Px7R/1sGdVtnlc/tY4h/1rXF+Eu0hmKPDdFrmRbtdg2q7H6sMgP6lPdAG9XokbW3SMu0x7ZPKbwbDkoLEv9PiJZLMtPSie12kW5ezZIqWVi9mow5gx7cUnsUUEpXg4UYwfFtIADtw+5rgrG1FNMmLVL4DkPowKxhSE1HLkGENqoa6P5v1PqlVkFz1Yx+SVcpVbxX8a2g9W4yBPT8DezYG9lbDwH4QAx/EPiSrZGB/FQxsZnZbjH99P//6Nv71ffzrB/HvQRD/HsY+JKvk34NV8K+hvW4xBj7wM/CBjYEPfAx84GOgcrBwcxLiRAWnL/g1Dkbs5y6GbIAwn10N8kFSnOrOZU5tRJ9zmPv3J3zzy3xnxnlCPOlLrDSVRne4aOMEqlWOcOw0eLgAi6KTNEE40050lc/Rufsqukim1D+HeFIQMuNs2hdgg4Qn2Ffn3nCMTmoE/yU6s6fTuVGylCk6RUxpa5A1FZskdKBdOs+qd6gIch3Wc7QVYswE9NgGAGYGQIg1XEEnllt0VaRDHA46arUVFdYsICsqfGBAtuQ30Dy0aDOZnicl9fAyOnRomF2yYokz0nFYl6WQmCOjZWLZIh0WpCvhSFOXEoUr9ajtnPG4lRib2jjkdDOxWYWcnFpZER4V37LcaVbT51loJR8Zu5Mlhqo+CrSdCb4KP7Jxbfk6Pyq+1VC/vzT1+w7q9wOo37dSv++lvk8D5rZJv9sVTuppXZpETEtSXhpUqHf2ST3C6CS7TEfgBznKQfW4isj+STyLL7LpKL+A8GXSzeg3A3f4CFz84a10DgkYrDySDMMuLl36I/mJ+1XsRuDny7v7kL409SFa5mxy2SCVAClPoZ1GDBy7tOcQEBrofLq05Q6Q7e8u7hCbu6fKDcZj3TIYimXoynAsz+R6QuHWN5L0NujYSLC7WEVa6LyikFZm1ZcfXm71QrjVjz0oluZWb2Xcamhra8qunpddPQu7eh529ULY1Q9h14PYg2JpdvVXxq5mlrWm3Op7udW3cKvv4ZZPnRAu9UIcliPcMg5BtgzzJERL6ibyDEN4SK44aUVrsKEk0UgIiYcEK+OxaHyDVGJeRgvjcHFbaKazXMRh5bt8T+tivnAr6ynjLpRJj0OQLcN8CdGSzJdnGBymM7qaJpNsSKNacXKdEimj2TgVCspD9YD8HOQDwsq4oS5IGoSBuaRBaKZLg4jDKg3yzbtLGup79sAqirEfz5LcEzAtI1DixIJEYALfN+QOIV4f1P4KNj5iUYWDST5O2RJQ4RwnOEchfp9H/55nw0/jK1bVMI2SSY7e4JRmIdJRj9glG3UjXTI4vFUuRK8Kl1RovhRu6eDeEXbd2YDSLygccdkA7zJiY5p5kLFtXlb5JPuME3Bhq/kMr8U9A6O1PswM15rpLNcxGVhvcoxpwvxeMPP7cTjKG2F+b7XM7y3J/H4A83thzO/5md8LYX5Pc6787v79KD/+4/7JfDy+T698duHG548SO15u8keHKfiBkuUjIEPQ4AByA+fDOcTXd4dFili+NU7hr1Y8OJAylQwO3sc59nUCtSP+QD2PpBZd3CcIIXorDKt7uPV642BjsH/wkaSIFaGefxwmLKuRdSzP5bHUMN2yuhqnXZ49jl0piL1niADPXtbXFTYkNC/VDpSfehrFD2aXcUDzA+yFK7UHz6yzwjGdVwe26Qzz8SESTQTbNzdIZjOkRm4ipWfUOisULDDRRlQEgCAS0u6fnWpUPJCGJCJu+5tRtLXjXZUfVoUhz0BcC7YSMTqc42zUznvfGU78CtPIys1xXnL8DM8on1ivRwcHkpezQJTtKp08S8rU+q3BtWwnAlJ0IjZTORUA3OK+ytAxBvDBF1XI2U2RQluMyG0oXHVKiYMIBPxYv7Ev+q/3bZrbo0NElR5CVk5oPc0v0PodL/htwU01bszup8XbbvbNZdNpWrwa7O5AWcVhPl31Z7kRwLgNiW81hDQ2+kz+ksnIaLV2RC+cTIgeQXmrKjneJgUjpeRyNXw+r3B6cUzwaSoVIEAb/qf0apRfwPhbsp8s4m6BY1Cek6T2/DYfw1K4FvOVvlbw4lMiPhpqmHEb/L6ADC0eFPPKjWFemRFsLD2EjaVHQNxHzMDJsMrOcUEF8+zxootrBbZ0YPxye+qEpeO2AMOoDdCwgYxGW8B38KOGOJJWXBMy7hgY3A4Dn1c69LzyAmMS1pCUpF4oKp1ij/SR+VsMmfOGecp+JMLMN8wTN+sdMvr2jWgDLiJSCRSJSB+FgSosZ8+k/Hps5zUr/+ytqPPXEAYlX9jHpYOdTd9RqY+XZLV6h1X7wdBKTVj+VdeaD4ZXDwRd+lRVNZBqn5fp4fwY/qDvayTbPHtZ7afl1wOsioC0Y1p7X0zf2AA6pAZ9I3jPVTDURMALl0TMFWlCS2gDMLginaClYQPnAq2K/MrAqoMu0ZH38lFqVlvEFl2CUfx2D5QPj7RYaO2zQTda6x0Y/Ms9XzgDB+JdgMOGs7HIaEK2ISNg8CJqh/atozgNGhm8YVE0K5ya3YshMK1xBhQMlKuBgrQjpRUkHK088UZR5BfPQRwNqw1bLPeg/IsQxWXC8WbmwvAaqaoZ4qoDyxbWndsuFUyFKNG001h1pOULJVeJuVcufsuPwnB4VT91CZHcVN4Wrq3UgAOaMLCw7lUHXuNMggenevVK2vQS6/PKd46Q7VXU5L/BvSXUeOKvYV8fC0fEkg3Cwc+F/qr2Gjyr//JbFOO6ZRIut0kI8wJethIunSDKibItCqzbGI+ZAKbjMnV+mDZjkhYubzI2BRiZ4JfxGPgph8+b7FFSLnUKhc/95NcgK6VBvxQ/fdnKJRGQU1qIpxYg2YBMOkn91k1U9E3Br2iVLa58BA4jbkm+Ui9tpQBcOwnl9PMEN3pMfzO8VJdRzWz3kTQwWwh1o6OaQgCNMoG1vJHND0MstxaJKMSiYTEOeYntjf3WPtJa1DPif/ztlx8fPVyP/cdSDBx6smb6mMmyAlfVdImvd9JQvFU+H57hyHAdOdmIcYu07I7T6Wl1BltyT9nYNctO2yRdn5nVTpUl9uaHqGfVsvDHoNngTJoC5paqw6gjVMeGN3rsKSmqIs5TjoxAUirkVyMGuC7MREdrXfDMLOalNulDY+JY/q3jnU5EYpxGKI/IXZRggoU/r+Q/s4rhGdB7uVFecwVheopadHOcXh2b3//zHwYdIVTi60E+k95izPVbUn+Pco267bSyysgLoICwZrRgQtpUSXGBe1HvUQcGEj2yGiUILxXbZPOVK+TkL3QlWDKXXiXdSotDyp0asIkiIoUR156nSJlKRzB1dAhraeuOaGtSlhvrcudSbMXuh5CTYiyPQByqTGWTAuC8njtGLw+zz2knytGiv0m1iQ6OgHiRTLLxlTwyOktT0p36e+ytof/0rXuxeomn7eRqA8cFoDho9Fr8U2gGuKuEDNu6m28829mSNvQaiu2wvKxAzDL1x472tMgUat2bXUaofTaK/vbzGvw3FpS8qxmkHOH0RnoeAkFfRHqSTdORfChW+xDAngo4HKOCRsBwuH3oR/8TMQGI7kcP2mj/fAHxLq1eG60lsaxCmOcHF4YkXX285m59eXiWjLBGFUcPEUXY/4E6xelx0lrr4P921x61XZiUdZ/82eVWZK0qty43BinmNb5EabSV+hLbyBW/JGhj4S9F2jVjz5exuvMDm9hcUg34GUT4fo2nEHG9kg6CuCfTCqYdkAinNGvIcJwmBRThyOeV2FLRjXQ+X3P6yF0nQ80HwbfG1uhhf6djkXeBRAK67kSP1tbaZrFyiZSoAI0UHQ6cMltYV8GqC/rxRP0+hqCyg3WaKcCo1Q8/cGISTac+LRkh32cfZI8IrsikE4sqKBrDFMQem7qpoW5ar1vJyg3Vgb8V+oDLQ22Iw6MVbHqZwUTHRMBsstOuxWB0Bc4nGNPl8WtPmYwG/v2BTJD5W/xQD/FaFHXUkjEwK98d7U+JXos0V3E9uGNSp1SfJtL0MvpVG7egpf/jH0h3f+Jq8YP53e9Yq0bgV9YOQM/HDZ44GljQk6yVnAlaXrHrb0qixdRoDsOSJO7sY2DauMrvsLRqVnc26XKCJHATP5MTHDot6ajfDDGRdicPmIyODFiiATaiYkDyGonbKhcY7XpGp+OMvpJ21m+bkvC2HrZ2txPVUwqjlXFZ/07FhU/4RBGUE6ng07lxwzeuOJJuxu9BNAWNfnXl1uUwnVWt2sLKuiUqsVnRIO9E7ZG2NuiOtaatVjpfRCUPuQBR8S54D2JD47wOoapvoF74TWhjRmOIuIPYDjuKMCn3bUV6gnbqM0nxwHYM4n9MjsCrX1pTchT3kENcBSiE6HHvdrkXFwoGrIqIMlNNVsh/XPSQlm5LN6DEte3YZFUAr9ajUX2s9Fx0ATEngjkFsivL2zbNjWrDY/zSxVsBhr1L7z3l9KcT5WB8Koyn3ERbWeX5+HVpURZGcfUb5Xt5BdKffmsngRXoTbDy6RMUlgCjTV/cv+Q9vyT9ZuU+YiYsF/IGat1iaLN1Loy0gUketbtBk73eZKN3C61IM7MAs45XLL/YBrExHm/STHa19FL7vU+2ol+jtYaitbboIRz+v4G4w0JF5EVciIxSCCwAeKlXozGTr34tXuVIFxn1gQ+bqxVTtbZow4G3FEJf1PbCLQE0/dvJCP5raCi7b5C2Pfivoa1wzYEbDh+mvZOTWDKuU4F0XagbvRW4zZ1v4H77O7liD7DXWw3vvDd2xUVN4cf56Eq/9dWtLnZGLmgs1JYjxUPMYOQ3ohRbkFE5lNUxiZ8R9VO/sRtqFz+NrpwwXNHi2zc22tA7ebsZ4p7W6bDIx2OviYL3QaoqRw5bhKUPr5mCc4PM41ea9Yp4EuBhOK8oKLlbl2gEFMU9A4q2jbTQM52d3DW1orj6JlxrXUHXFMc9Ew5L56bbtCW+9hV/4fXna3DAIGOCb0z3lABxqZLTKYlQjeN12YMC55BlnxnYHPBkEsjgejCfwle6P0V7T5FnI+Gus8bHMKAfp6CSS06YtBUc57b3Xr8ZxJJCbo1pEu5SxeUHjMan6btORH45apuT8jvoNDoeW3xVYLh84qhdugkNn4GMlG9mwjDaCw0yYHAuLxr8jgc2tRdc0BmaMOvrutJIsOlps2yr4xXU0+uA7QSE9DPUSPmdfK2o3YB9ZUjr+WfGrBhkQJ+Rir9mGq2oaz6NPt9uC9/YtrCbVGfdSXIJ5WS+3g4hjmLRzWI1Ggu51XjyNHpU3y48amvxgYL3l54doUhLclwrWXIE/kTyAykh5cIwOnz78ixNRmjJKfG2U+JrerQId6Iqq8apfv9090l5fhpFl5PxtHwan1XV7PH9+xcXF92LB928OL3fX1tbu4+axMQA+jS+i+gEyNGPu3F0humoPoUM38/yy6fxWrQW9fo/R/BP/OtdzVUCDwrvIbqThHgjFT/BLX+NQZAxDDy7Tx9ytPV8TUjuPkFdlL8+OcnGkLw8Gz2N0XkhgmHG0RX8i96lL5N5WWbJ9Nl4jtpMn8YkLz/OgJENY0RpdFY7z7B152ncj6P7vz65T1CiX3APd9kZSuz7FDJbTcuTvJg8jfGvY/C2W+sg0rRRz9L7cpiM01avc6/Xjjk69eKNM/1Fnld6iidEodNfyf8RB3+NFTi0TW2jfXEA3WJFfnilYoBh5+AVUgF9uo/oYHQkh8VwE512dfhZAhUEnsaT6Oeo/zDaQT8erqEf6Hf289GP6Cf6g/3Ez9Ef7CcGQ3+wnz8TMPoD/S+K/hlHiAXjp/HfHq6dnDxcAzYV+af0aXw8Rl8l+/MeleGf6wcQsY3Okk9j7LgW39fmN0rRt5IGTrH3KMJjhF92ot4vUf8X/OfDB/Dno+gRPEbP8MzQQ/w3+ge/hxn+Qv7G4A8fYmToWe9nYYIwvcUnqM0PzwxLOJ6cuGygn+kkq2rxqDqM2x2BLKw1eMN2yEUURmVdcYQ1zbxcMUj1szZ/05bv6sfOvR/h24F1qR4fWTVOpRVDnqKpD2HAxk9G/9o5FRp1pI6N9hY2plo8OTxnkgeFQcj1Scl8YyuOZ23CyyYgXkCylA9N6H8FQit9tn2ytvTWHvBfems/wW99/Mtn9vmNYbs7LZIr/ABR4Gk8L8atv52ghRp2AgFpjZX/7PUexEAapK2gvQchfAxXEev0W31cI1+XPufHD2eX6+L3/EeeTR/j73ld/srpQ8PY0MK28JzRknNykv6C54czXFz2nsYP0Uyu0M//n713727bRh5A/++nYLVnt9JWViT5HTfpcWwn8d28ju2km1+3J4eSaJuNLOqSlB3v3Xz3i8GDxGMAgpScOLtp0kgigcFgMBgMBoOZ4QZZQYf8N/kkNUvZ9JdoHf7o0mlok05fuIVtrYXtlbcwGLIWNgesBUJk1gQ8WGkL27taC/BgpS1QqihNLE0nhR23gffWN4ItvijuwOd2nz0f9PvB7rrgSHqAV7b89Cl4Kfu3rE0lvNd9jTnupNf1ZQRd7peVD0QadHQlEnyaie57Ed1vaf0SWITqTwP6Sf7dHAb7wWYf/rI/A/bwRUC/0cK75Sctvt6Hv6Qo+QMQycP/aylUL4Ux/FwTWnC/t4HL119oGL5PXE49aq2t9wW7chXNot8XrSaz/CHZ5U8nhBfAy5yUXoPIv+d7DRB6PBiukw0SwUmV/F+MfnzVKBiXcXFL4n8fVIj2uwOKPqjI28PeJmGwsvG+tfE0mqgN1213JSS4i4l7l2ymMI0uIE7CGzgfvPe6HNkvsgVju/zC9ZqtWrrcTw0AYxNA02q2+bLCF1P6239VUfWXLRUW/d0Q1oDD2iiWO44YPGgIa6uvwdrqN4YFfVNgwQM/WEuMIZ3BzSawvtTvBrsD2uJG+QX+p3YC+KKzz2gIfwr58Zetc/hTEwGD73YHOt/J48va8OU7AavkO19YhnQ5SGbn8cUive/axw7XSwf9YbBDl5DBOoznPlmhBlRL3dikC0iwsxVswzivE1aj7zdJWXg7gLfk0TqwHSlCCiLVCUwA/QJagcaW1E5+upe9uEij2zvXbA/jizgPpzyi9Ddgi9igQ8PIzL7s7LK9AflsunpVg3Upb01kn1BUhrtMUdkcNlZUNvp2RSUwBnx/drGYhuk93syM43Q8jYJgTMizRWTm+JZ9kjHc6NcZ4ApAThvxhtO+A1DYrp8rBPQB+dzdqIALEt7HrkD5gnzu8AbWd0zDxUoa2NAa2NhZUQO7O2oPYD1caQ9EAxtaA8v2wGYz3+hubRhnUSmEc4/aa9v0Ri+8LsUKiPkX5H+QKGtD8WttU5cnTH44hMnQIUwePBbnWMZUP5rE+TewI9nYoYvtTvmFbmrJG/LZwLa8s83MRdubbEu6tR2swyq9NQy24PnuOuxkyao7hFMktmcd7i6x86nqwKrXjlV0VcaJxsN2YjR0Y4SsMtPpfee8rT4dqhfBBtHi2NnrNtg01vk4Dndg9X8B5dbhc3cIvzkx6fiCWbYPT0h18rcpB90JIirPRdFGf73cLO0Odob9QT2uM4b4LA2ze394tb7OaEdmye6G2GDSmbEJL7yli2VNIFJ/AEEcLIvCAFkU1jb6dCFYW2cLA/+gTxsIu7Vdtrzssn4WH5vlGugCRuZusXzUpZzKYjvwZymx9kI/29oZ8t04V02Gg6LROu3IR39yM0KJE80IHW7Fzexsqc3s9FfZzBdjzFWPticLr8ZezPyQLGrSaXgd3Xc5NgRPsWAfvGWEDX4L/nLTHDUvlO+g9ID7D5Vf6Bqzuy19oa+oqY18U6GTMgCWqTOkDf31Bl2DGq5497c3Cpevb+6sT8qjkr8Mh1vn453GfE7RZ9hvbQIGm8FmeZCz3WeydbuvvgKD0dYmP+Ql9c25uA1/SizHW/Cn3g5CEvtb1PhBUOmXX3b6Cr3A7MW90cin/IbU3qHSQkUx2oQ/S6AIhEyjMbWYbG1TiwlsI/l+brAhXC0DIlZ3WuymqWskayOACo1XUTSJJvdddOywmbUlJs9gSKfbvwObzbTK4WbQtxOKTf6HjrlvQ0fj6qf7R9uliqr/9sBE3yl5NVu5xlQxqWU5Xtva6JL/OwEz5fV7ZML0yM+yxHCr3x0ONtUl+duQkwqdltQF7khGatzUwMZyxxJySQSXlY9LNs+3D63DZPYTxKShF6vyJMiIkOy1dNGZzcJ5dpl8C6apdbrPJl+2d8gobpE/nBeHwc4G27Gzzx3YGxGW7G1vBuu94aZwwdjcoDz5AgDAl332lpYTZXboxgr28xwazDPyRWkR5iqBQXf71A6gvCQVhsBvBK/hlvqKdgL4raFx67+IBArLb/fhT7nAbGzBn5qC64CdMNADhk12wLC5SQ8YhlstfZLt7G5Gu1sVLW7VtMLQcAkNZ5LmhH73m5hBjwzFTo9Kxu3egKzGvXU2ZDu7Pbrn3OkBt2z1hmyt3gHxSt6tFw/Jrra3I4rv9AmsrY3iMam+KyoMhwIIaWozYMDp40Hj6XCfOmAYlc/PS9bq9zfCnWFNA598s0DisJfJdXSW0ADe95rPxPpHPXLJPBwW6x9Z/oqrWMMNXxubgDfs6/B2loK3uUXhgeuOWJ+3JIC7W/WNgCDfqD8e+aR6x+ZW8bkLnzs7jMs2t5gJmXxuDuvt3v3Ju3LOrDEUd9f2bvWwrb7xVQzxFxYUcGf325ATqxYUg/6KJcXgDiTF7hZjo13OPtvD4nOX71goG5HflI22h80lxdcUFR6DcYeNf2VZ0XiQv5isOPo0D2eTb0RvLa7hks9tLlvFJ3NS3R6WX7aHfP9SfNnktBefww3p6i7I6a3mGumdY2ax9rgG9/XHez2wY2nTpnqFbdJNW20HMwsk7j/W74+G/fOW7u/Mjvg3wIWDHu1vDZl7xi4zv+2yrQM787c4bLjG4GkYT6PJ93HYkvz4Bv1BpI7Dxnqwu8s2Wdt047XJfoOdgt2w2xXbsz67h06eDnf4tmyX3VMfcicNflGd14AnO3Ajp/7YHSaz/B+z5Ob76EmjNxiFZEmXPGfXN/UrPpS0dTxnd7d0z9lfC79Zy9jEs/Pk+7gU43KYTC6i9Ml0EclDs9m/g6GJq4bmIJmG82/HGKat3Pq6vCqNAIFbcznfn0xehunHKJUoS6NS1aQVDRxs+Wi1XA7blOf6ukGV0uU2mk6Tmz1riI9HrQnBPY0mitf9BlPQ1zaaXw/cMq4HQjSNWIsHziPxAN+2rHS9b4cgbDAKP2vqsDSgNJX9lyBokUlkz0gr6oZlq1+usvTLDj3N1FiVt8GYtdhrbfB9XrnXAgTFVmt9iJxyv6c844M8YnA/SsMsgrue0+Ti4r6OHer0tb4pnL5sp9SbW93hhnoEDQfBPALGDpz1UJV0g548w0nLkF7x7cPD3T4vtUtdUekJsvBbHbBj7A34y+4Eb9GIRfqWkyUN00Z4Z4eOMGzZhQO/NMLDoXG5uRxZFgoBAbbb9wI2goUNgfYF6WP4JxiXG8ybK5YQDg4fOMKEUf4ujm7eJGl+z+XRQNx63eQelezBkNmmK6mDRiARkIb1AMl8QM/26UZAfDLn7CE/Qh1yFxTyOdzhwq74wpw6Btx2S3cbO9jGofngq2y73SM7n+0e7D3BbaS/3aM7fjjfGgw26PPtnR5cZxzyUyv6qr9Oz7ugCFzUJeXoLwC0M+ixO8NwJLa1xc6x+uRjawAQNnbhK43wtRlsbzEwQwJzBw63/i9w9pWxPekApiDAjE7ZNW9FlmyNxzvbI2T2BrIzx3YPzrF7cLY9pNee2ZnxxhZ0vr/T43s95CLHTjTZ2t0xkQxcWA62EPWrAsct8NrZDzZ3wVywtsHPwneDnX6riXCwBncLlNgr67D33afHCYNgbcAO03fhRskqW0UvjxzSuf9dN/rmdCMWEPkeb8CqtxkbQ32bwSKk2PcXnOXFskLZgu5VbvkdA3aHAeDe8lsGS8On/KXAh1sGq4F/K/AXdyTYpcohb2gl8Cn+CnyK/3Lw7ea0nP2994xZnB8xJXVdOj/aKeftYAddQ2QXg43l6u/2G9W3DcCL5OJpPL2Xdyw0cb6hRjVbF1d1NhSfSZeb5M78kxZbZF0DurmlAPWEGeAX0IvgfBsrACoWMwF0Z2cFQDmiG32VpBv9FZBUABUk5UAbknSgAt3trwDorobpYLAKqBzo5pZKU2bgXZKmAqigKQe6HE0F0J1VAOWIbg/V3m8PV9B7AXRTBdoM0c0tFSjzSVgWqri1uKN2f2dnBd0XQMXgc6DLDb4Auj1cAdDtHRXooN8c1Z8sceWnZL1K0isRVJ7/xCLKQ2IHJcW3qPqBhdOH9Hdqmu8pS5EdXmU8NRX5n2V+eANPy1QgrFBvnmQxBFM/u51HNMmb+pr2iDzfCf5uJhIIHpBdQ/D4sVFLXAYgW8u/I4H/rfV4KoNBrcZY4oFhvZZYGPtHQYvrDkXuFoPAlIg8eUab1e4Yhcc8oRkprgFg2PCEZ4fxtbUqT6NQJqcB7MZE+0jjKG35VINcN5Ckh/T471KumQtIghJO4e1BEp1bky7YgSfXUXo+pcRohYs8KSpg+QELIDClLEkBy6aI0gQXmdtqrd/jPzpYAmOdtmx6mDHxKcgs1xLwBo/KvC7jNArz6IillGy33pwctXiLpCDv9hXZbcazM8peZMeCv34i8oIoJeigQ5oVSIPJM3yY1JXzypBaHAGeC88sTrPacZRp8sfgcTCI1qW5b1SRE8Cbb88h+QV9qeeTYZSch5NTsuXOCSm7ARtILWFflovMfL9oBQAIowrEgM+RHObsoRzsn4zImeDNiaaWTwgf50+JqHsfhWlbZ+I1aEV0sEC7TSu9JN29pMUGcrVuMHRUpTUP4dACqxPY6zwnMzZDKz20V3oZzxZ5VKcaq3cakbGcZLRzHNB0GmfF0weUPwjQp/GnaNJeJ0C39OlCQMtThTdEPl+9PjstmEYZG5CIjDYlNQgIEzAFYQLnomG+yC7bvJ62usmyw8rlrFA2n8ZjyOSBS55gjdaW+Q9bR7XUMrp4KnpHlnK1GcLjv/+h541hwVrlNV56hK3zl7GU2oKmApJA6Gs9kpwJKY5lK/7s0CxcLa5KuxhYtIvdZtrFTsM1/yS8AWETFusY2nfXwq9UkBZ/bBwsCoBSFAZlkVEl1L5IHR6/a3UqqvO1SdCdrtijLJkS8dLyq8p1sFJ/EOM7mZC5b1ce3FBFiq4Vgy1YQWHf07P9s7enL45fHT0/On72/KyhOuRuukgItuIuzVn1szKdFrXatzfvpBe8tRds0FubdSuecPrXqCm0yX8a6uSKWtT0q7YFrGUqRbMsSTNIHthsKpb1689Fo+5qJqMBNsVmDSsGpZj4dbAbaW1Hea+g1WmMF9vKtYb+NQQzva9gJqMiLjkIAi+pWr+SyWaygu9ss9X0mG5G1VGSTqIU4aJjWJie0Le+oMLxxwsqjkQ+ZxymWqzBJC1bxmdZQvNPN5+lUv3as9SsK9SYptPJl6HMllezrJpw+UTs+9f4AvMJGTTP+WStWT2fzKrFfGoNwEMTMrcE0kFQgzVJaqM0LUHO0dSB0svjVw7W50mB3fV7OVPLW/FsvshbFYXHl9H4YzSR9xOO0oxWExb2m7UBi27LEyPa2Cj51PJqpvA2pBnuqV8t7EmtHKcxXMevFWbwESyzatWsbA1JYHwZzi4iyGCsJDBWIaTReRqRHXVpOauWfXZuJIgovEi4eyZ+w3cH752+2X9Vsh4UVuxhrePZeLqYRMFVPIuvFlfBdThdRFnLF1kAWEAfpQ5Enpy0vEkwSl1F9989W2qykfr+kw0Kl5OtTHVsLdxgrskI+cy1spm7nGtlK19irkFr92KuEUQ6K55bIdGLw4voW5hbL/f/udxCtv/PGgsZKVxjISOlmyxkEkZeC1nRzJ0uZEUrX2QhI63dj4Vs/5+rnlxX4aelF66qwq55t1og1KbrOhsrSTIXbEoIsj+NL+huaUxKySeUNNUwHcEn+YybUUeLPE9m7RZ/0ZwB5sqhWdlOj6Or9Oro0zxJcxOLiD6vQIIVqsahaMRAoWp05nhJsExLJuX6m1sZQO3dLVJ5JUYoBO5qNq8IYLZ7rb8RJc1sLm/WQhAqbMXtDTt8SPJ8x0ZsjDM8t9D2qtV7aKSupxF4mVadW24ZsH0WnYXsAM02B8/2n7w4alXUbzQF5ZpW9wtnLT5r7TYcvYKwYoEb2V/9qlSZifTyo9JZwreK5NhisP9T/q4G96vYgCHnIJnSa93M3YZ+rVP9FHK/kclbt0+lj095x9djDiirH9qGctSNnUeWTjOOVVe5usefS940U2Z4hZNvmx8Qt+G+DGdkH5JK5lDcJQiOoH9sWyv9Hv8RxHT4x1FyHrwCR5BT+rajuBUBfOZX4ICE+hZpBuhpNOaz1dXJqbU/wmbyKplEuh0F9En5Gd217EmEiIPHj+y2eOoHBHCFj4NMAdGmt5obsOb9t2C8gmXPJd5aNlniddWuSm/E2EapgFa2b1LBrnyjJMDX2BlVqMayYlqOviInaJNaIb6l8WURFK6AI5Wz8qxeD4BVwffavXwOIsJe+ATwmEFEGpgTocBGKtf/AyUgVnTwhypf+JyWp0XHRjEudpgMm2riioGIYVLxV+Dz9eEyTCc3YRodT9rK5hVQVDawcqXzNCaEnt6+Cq+itrJmcNc+f/ETPJblYCmMrBBkr0RroWlo+iaqME/YXOCuNVkbJ6W+nH1hp8a3s/jTWXwVkTav5mdJxuQCUTql1XTC96fUpw7+6b09O2gPdrf73YD8HQhun5BlLCevhNsf2R+Cm1MXPNyIQILffy1L+ztOyoRr4DyJVvdwoLTXq3CitFesdKR0dHUVzpQ6S2YwMeShPnvu2k48P9o/FGKXln7iKv3k9eF7ufTzk4Gr+IladuhdlsacKTwdrfqeXRfiALhiJqTQeJHCUEh+mpViqFSkMSHUt4iespZV8JRFqsWOVFherc6eIzq1rewTibwZYVpVTWJPw0/I0/3rC/Mp4fVLuj3s7+HunMYhriTQWOvyKRMD9/PPus+s+6hKAsmQbAhSstDLWFJqVIE8e66QmUwITmfjxVAagHE0nTpnpZgMBJ4CBiryVzVgDG0was4q7yZZUfVOQpUqwOuQDfEps5lT5fcq/NQedDnp1ZI2B6HWX8778KeFlaY76Be4eRHxTjKqnlgsiD51mYOlR03HqDMmhikkb8FqDAwyNC0CraW9b0YuB8HoFP3Pf9i8+jVotYKH9SFWj7VSXjk0oLZfqZxjWqhqNGC+QmITaB7EpkKyKZlUwn97BCcYr5K7w08+BC/4c1WEv+/E/lwuR8l0TG93PVKkP1HwmdwtFy5Cy2JrUa7+dZUzujelChoY2R4/kvUo9lpp55dA1+B+L6v/0QOVHwp3FBOGhqkXBMnCYaFUmtwISvWl5XyRgh/eCbvDQTY+yrU6BROiMwZ/+1sJ5xdFeSOayMn+b4f7Z/snr387VU17aXFDZD9Nw9u2GDTl/HFGeAIZoNpDxKDB2M8Qe5p7/Pgk9iE4XPeRyaOC4V2Su2FfArkWntz8PoOglQXv/iEP/lU8M3ChR+rS5m1PAzkTCp/OG/YVwgsXjC6rwEUTnn50CT+tGhfBO7ICrezNSCNra/KbzxoHOVmsDpM9VqeFSR191tQUFjryn38wv9HDBkoTtXmUw238jY9iq6Wiog2MTlaMWVcDGOG8JQF/RrSDYrHiopRvRR+rHKKI5Gqjg7wxc5opDnVdY6goG7Iwx+1wirgj0+tFAmcH5iRjsJdRw4fI5qNcvwjLETXHAYzoP62WBaKXplKMgLVWu0Dnb8GgI3ASkbUfVkDV1ZuhRL1iufuTLXd/wkJL6ojF7k91sQtqDjw69ITV//zDLOOhrDlG+8/gr4Wxpe6QYWCFctr+kxpYVwZdPWC+SmZJNg/HkVreb+zK6X/2RC1Y1JfPfzgLlSJE1Nc0QEXI61YhSVz8qN9AxlQnqSuGXdBQpdDCsLzIA/PEdrkTmd+fNeylIbSdhRh3SZEp/PQphCquvBupbK5eJfReM73cPYMQZXAGEoQ5kaZhRvYLMXkIOyvSBOxDuU8a0QGC/DIivDdfYz5Z4rS1cG7kp2zUZCcLrXvWwWQWcb8D0SfqqBCOEsgTq3SlKd46Q1juuimU8ttWeJLg7DIi6IdpxPoH3aYHG7wx7XyHkYu8zHot65Hp3bYbBG8zVom5VAbnRJYvAE4S0Dy+5M3NZUI2Z2xoo1xCFQtLQiodXGdQmKmcXWom6FKjQTeQFR/MOL76E42+EV2CqouonbrQ+exvAX/0LfOszcofhOMWV7PnUcjvo4FAzUCgthp1ih4wgBFYVrrNLYfewUDF42eCyB49H6WgCC+0yUav9LDQKVBdPSSF1eoSiTxaJ4Vb6lEtjLxaLWj9K/2XsLvWtMLEM3lle7W4GkVp783r0+Oz43dHH45fPT1+dXz2fhXGGdP2gngAUYuNjNPjRhYbtVcrsNgIA4wM+BcruVS25JExWi2XecVN+Tu1ungNTF1TjEQodLutzEHh/0boVM6B5pYWc5Y6G6hvPjHnsbsHtW0iPiYP9xa6/vjWGeFf7rEdBGevYmiCvaC190MVs7iLG0NvKV5ldOj8oADw2vQrE+tnWrHQQsna8PMjjoyyKBgi0bqFKQMJa94h4kqJpJ1EbEvr2OuGsisG1ZAIjeDzIexiH4yz673xZZgStenRIj9f2+nCvIlmY7KteXtyrJywS4oT7ivVrbj73a24rtqtuHInXJN4r8GdaT8ngzJa5FG7dZlG560u7aOzHNG6Z9MknJCyLdIelO8RMrT0SrqLKc0kwD2pBLFHyeRW2dZGyiUeAWs8jccfhYRRK8s+JXJlGitMIYccLwy/m/IIovCrL/UwEo+CoV5E3VBgQIy7JABFw053eVYimjHXceFMzWOasetUSjgzujtKF+M8SdvjcM54KuS8lXH/2NfXUQrjJ+ZBfhlnvQ/RDNxk1BvP7E0ZyEx/w5uQNAP9Of8mvwxFL9mXcnI9e3s8hltAj+yuvaWaDo7JybnRp+BHsnK3yG4wOiejPWkJ8VTC1mvIqBEO+egQBfuCxcvSyh5N6bxRks0HsnhkbAM+T2Lp4p5R0PDNHk2T8UdJQ+YXcUzHaN5Xqxs0VL4SDC/VXfeoK6GZh6NjWAHLrZ3RhxLFeXHHivkeev62wC2w519ELZ+fFpDFZRRuHWGZqmyDU2nzNWooJkH0Jg1766hexJfdqjdQNRnPP16RVNV0qL9KFlkEV6cMn3o6fWWZU+oQPoRmBnG+4He8MVnkq0ZEHXEvVOg6Vh8PJilpmU6N1j5Gt3NIpwANRu4W4eyoHfVIDdj6tI4og4AHSPksaHV88QKdC0xLQnJqsWRLpAsFDQxFXJ60ldyTuMChRUTlcyKuszZSgb+QMeJrGY4RfykjJcrTvY7aRLks0peVYlytxZ1qSqVIYMgHBMeQv5QxFOVNDNkb/kJUmUcp3NPZZyMnByD9EWVBOcopPugUEbKHIfuYNB8v8jaDUA2a/VT39lBarW+uts/PXr6A+ffL4jGIdWXV7WWLEd9mUM99lp/TXbDwe1btsv6LvLCPcoLDbkPpPn0Ac8iTwqUqRmu6Vl4G+tegT3hpbSCpR0pLWJ/cq0ITCYiBFyVZDpkqOtsbivrwx9FQ0Q+i+YWLae6B01/2+/CnJQ8i2TOAaq2G1bWq2E6NmimPr6jtW+Jw+k4E2u/LmhO7zas+w9MD0FfivvCGUqGIA7euPI6zl8kknCKosKkbspC7moIP7+AuRRgXK3+GlyqM4Nq7IuYvuGoxksp6x3iasITOZs1LCvHJRcEDcj12kfkfUTQ/mEZhqlFG3NY9ZKzw1OMKs7t2TcUNekUEy0E4ncLxlOIGRwugR1cWJZKXRYLeITqqGtCA7DKNd5ISV7QaqDPBKI3huQ9/Wi7wKrKFAMbRMAAxhsKa7ve3h+OwZamBqokmXIycJuAPRMs+8NqSGi08j8xbq0N3YggLJIl9qeZfF5MGDMwsC/L5XJ0ttyrZUaJQSuA7cQ8KOCtKY4aX+ywpW7wsrmzxl0LHIbN6FinGwzh3RmGHIkR5BjK+Hv0ZjXNQpTNZW8ZORKCM/TAK3oJB/EdYU9kotUqtPM5/5wX+4JpK8Vs2kGLNyuNuaT4v3tNjV7lGeUtWMcHG+Z68qvJg7tbllAd5V7TsSXxtys8PdFnhN2P0d3ShO4yvTy/jaDpBCmQ3cT6+PI0n0SEKnPepWPiQIkUMfh7anvMGK8K72WNGuxdFSARp4LkSWSvKEAy/aE6oFh2Z88lyk4zpjc8948A+IL0BBfZlNFs8ibL8/+gOquBmjCOQbljZ0iwLByVc6WhL+0bOGEJVVbhlEG2SRQISCdmbluauFtcfn8OCxHJFTXnAK3JKa2XljZcOBtki4kDUHWOprRfsYDhdqe+NoEZKY3pMIxcmVuuRLCMTMh2qCT1hmRWgUjHs0hZImsxYFg1ZK9XB6htpUAWpq6vcMd6ma6t/B2iglgLR3jXZlhX6McHiIddraaoReePcppq8F5rIPA/sKBY6cwlTE44/IuC1MlagTP4T5snPkqdpMititUm6AtujaAqCMXjqJucR3BdXOb/sm9j00M8q7i0JhdL2R3s+l7Kgyl86YsZa4xUtzkFmOUrVOdxzb3lUwkJNOYojUaMcpUWUON/yeIwpVwVTx08vRmF7uLnZFf/3ezubnfJY2n58iLWjaCayVuExWI65JR1nMo1CYxmZq6Vbw2EWBf2HmiG1bMAZpswszodeaRieuULg6DAYPyggyKM6EMSsVGA4pygGpTBdKGDYUxecERm9j3syfQerpm9rUwrJZqNgVSE5RhL9MQXZtEZqdQP4t/MNUXjoR2FVhNkJ58Q6xUINmsVKwbN5B8wqkeDzD3jz3KSAaGPmoZlUzxB/GADMy9lYpEpTXucHG40+Fba+VrAx/1T8D3YQKnb7Xfqn19/sKO6YfDN0ZgoLReN0oMY285IorISpWA1+DuCAuqpl7nTMzY5+yzEU9hEPckFM8HqGT5XB5BXk9IOSYtO6ARxcPphj4QfNNSNkMxxa12dWoDZCDJpy+G4FpJvCVBjjKjycrXPzlbNtdyhNhUvtQWPlYtQECgEymQU+uUnDuVbQ94jaoe7LEfBM64xfhDutHnLgJucQ1LpgqH8FHMVnXoFTHDzo/sb0xaGvekjFGK/hp2BopVHt2iiFaOxGGbGsSfbmaom66YyVqLWwvHQwQMqhdWFjbC/pYHmprOmThICyn3kaRZcXQxJI+fAa3DKSRTqOst6BYMW2P127zFJh+WgdwByG+z20bYozT9SJMq6/EAh0G4YZAtMB1e6PUhz9ax4oqotyZdumQBDYoKFVfI0QNsOxp4BAKtfZjGAV72Cy2xtLzZMsn8ZqtLAKyWKH7hAyjqFxyRt7NVRS24u7RJG91iqkEgbdIqBeEgKeJUCJO5JS4MAdRJM4J30hk4Gq1hkMVMUkqi23yur+EgRp2BAm5TZLqQmwjLuJqj1eOXBTwzZYD6Nq2Bj12l67HFfNYpPtFgbVKRucrfhJnCUbcQQhsB6Q4uNmXFyztGuylQoOzsz0JCYVLIY25McEZcbI4aa+seZH35WktRxw/az6lVvBm/YU/7wpaPnGu3IUWvNtNQouFxEPC6tHrep3ed6HE9+2BLpKI3lBzBNOY2MMp0oVx522XbTF2ct1NlSBkrAUeCKFGxasXmTO9QBzuKs8BrZbWZBoGTgMH4XCnloYdei0oSl5XHF7Y8D/dlo1kWy1KgWIRffTpanGDJ2qW2pF/eIgl21L/I+a6xwvrfb4FgUsmUVkz0W0Abys5hAujLAOtwhhpEWdIUobksUbAjcWSbDEKbBqs5Lct2BVEY4od+IAI1y+y10sNBnrEmBG2upj3IEgQEYxHkftWbeI1u3hbbRM53DPnn8XFzFUWsOw/xu5xdF4QhQNtQd98t+AOwgx4Mbdc+uxffUEkRoq3JDQVmg3pX0E1kNFG8GWEeSA0dCtkAMwrUSN3Rtdlun2TfdHrdL7Gm7iGM7yLg5dJUxCVFPBJFWTbewXooOxmS3uGZgzi/vbgqskwfA8TtWbB9ybL8w+tq9It8IL0u5tlHWDWdINFlmU0pvbkoArvBTtPqqo8SsYKC8VY9NVrJBuo+/2ae7KG4GMbFijGYf396Df2+2oaFwqTtNaU4Ot+k1xgNDWttZWeSOivHhgHFaq9yUcSpqZFOB9lD0RF7Tl5JfkuWGg4KNdpAhTbZwgWsg464txAIPfLsZdvRcIGLxKUAReJQ3anyVm87PE1rq2S6brUUEPRxmBsQjqr6LF+8HnjfAWVs+ouTut3iHNV1RK3VAnw2Beka2Ppgw58c7rcXboFWLx7NBsslW8sgi7Q9LXf8yI0q6Jup2+b+asLp0XNnFXIHeiJtY4LJCu1zdtrzksDahFkXo3qJVqTRMYFkAUW9GfiyyPz2+1MeAKKJfMburkZkaSk5LnzUyDuZRYUGdtJZ0g81nViig++LOE4B6fF0EYjOWFwovHEDCC9+XeLSnyOrLSBURZNb7scpF8RIX1638YwjqcRmk+RGW1S/6KBngRFUoN0ao1/78hWWE+fBd4X0fgaQyHyDu1hCLu2KtCzhGUSRuZJgV16afJPZFabjEH2zkUkBbap2E8jSZ3t8yWUljpVzw7T+6wV68/ftEeKbGOroighJBIH9IbEelIPLLeHFPsS2Wsn8HeyhYuDbJHhCKBdO/k6Olvx4fPxR5TAHmsrmPyhlaKViRvmR4EOky8tSJhOd4eX96cDfKFVG2RwbUv5IxTKvrtWrBNAGhXOqtdftnOv/ZCKFdzLIMVnqjzYgk0/fvOdGcCuQyLZsSKbOhjrZzt4K6I9CZtRSUlAPHzaDpNusFNNB0nVzR68PuETL61d3G2CKfxv0MWZezmMsyDm2QxnQS3ySKYxh9p2UnyK4KPssyMI8kDAl8WpBP1pXQM17miK796bssiXn2vWgYL31+EhDy57iSvIKmoCLIi29cnhPVczwSHZFNeCh7jQPm4dxloTxD/gsFmE4CYGim/LySPrYCeX16LsuaFEGXS1C8tqKkjkZoys08GAy8dk1RTwZCKKpxhUzhDFc56UzjrMpx02Jg+Kj5DX/oMNXyGKn2Gw6ZwNHzWm8JZ91WOoaFrsqIxWVa5yPCi1VJQLYh4KasFsEt/agm2XD2pLKfLgQqAhbvB0FJMDpy34zttBQh5/Ssl/GhBRuEdK4I1WQQYukijWxQpq+sROt68rpyyVkQCHLq6tKfHImIGACoP4MQCrEQXkAjgYpqMwilTmCKyBIOBWnZQFgXpngDadqj4Hd1cQdtPSG8YmDYWwE5Hbwjo0WdBSPUx5i9wES4uIhW3U3jxDJ43Qu79b9HoDdmK9EgjFMpv8eQiyr2QXNeRvEjD+aWK3jN4tDxmAMUfsyGM7jPCJifhDY3mq+J0wqLOLjeYHIgXOsZoTuKLOCcMx50SVPQO2ctD9m5p2qngahDRGN5wdrGYks0owoX77NVq+FAGhuFreJsoGxEkvABarjSj0Ng2cucLD7VuUMQQZgbhcTidghuOgDg2vENNJx858tvY5YJpqP9ySSX+qbeCqUMxFpd1a1FnPFijcFUkL72Cze+7LOcOqHq+mKkBHL1wwiKnVrdIA6c2axCPkAorWOgTcT0UTlyLXCSgkJyXQsNCS4M9jlIa7FEJ0Bg6XMULnhZFzTtEWHUaWzSeYUepTYbB2gQWt9ajDZTwYe0Ysfb7OIJsuiwdo97OYSFpZE2glCLkJ4u2rkglZaERZks5NrtU+vPeD4bh6VGwCUEQEXvSo2B9q6/ZHY+oz4ZkdYQH0QRaO6Vy3h4Gkr4mK0KS5KqwvcyvpjTLmRxLjfusCJjsi/wK4NAcekm+5wbGgjwlKYt/n7XZaxhdDzzQVG4FANwdTAfHzpakWoRkV+240zHiCJ0CmhOOJxpCqIQqh/EBKuDlBX2gZBqdEy6+RNyxKDFRP0Z40ysqKuZ1wvUw7ixsm3XcSSmeLkEmNp0xAEEaO543Aj6UdhLawGFMZessTG/9LNzT0llIhFw6nsFDQMkV06uo7YwwV4SqFRlPAKoewqs8BlWCeBV2VRqZmegaXxIluYCgtYafiORGqTbLojQ3h3HFaOoXQ2QMJaYwnSHV/E0lBnTOgUqqsKnUD5WZmWB7EmbRITu7KBhMnTVixs3DWTTVp5xMNxqm+hMpNkHiVHO2gHL7PP4S2MXTZJoV7XDE3qREwqd5HGUgns1TOhVx24ygJ1hqLKzLBNJ1CHu+FruP+ebRW7eTA76KmcV4mkpkDdDhjS/JziCyQ/pAyEXdkh1Fcm5jLynCXQgVf/XLaDo/8ympY82dC4FlDIkjR6tsfEg2RA+FWMiAiKdO0SDI4ZENlwozgi5fZM3dKOv9cXbAqohyfOqr/hBGHD6NA3vPCYWVcCN6DgQl1ojmx14OZb1zpfLugbjhV320VDLEG5itdYJZFZV871jpFaZ46mWvK1E6rJEt0WsjaMJOuRJgxQGBnUnqAay4T2UpfqaHSMJLi4su7+kwLvKkguz1cnwY9SvzstpvC+EQm+RHwWA09XzBIaLx6/GilgCJUjkleQEwEVtpe3ydI0pcAFGKCW7dYA4JdaPgJozzHvmvZUqUnh6XE7mgVLSNSxqMdbIxWamnLZ/y/+SXqibRzFl+GWbhfTX3rURvIaPZQg2UrNIJLTFpo5lJnHlAeKOudCC1gnzSLLtkWcBbEwtGcW0KSiK3pnLjhpOCLb4KieaBEyy7Lq5UyCjQ0ggKkgJioIHzOd4GGc4zohbAMsh4VzSji9qclIoncgJe2MxPw5HvklcURxa7NJqGeXwtFju9qJGAa41m4NqzFDeDcBptF2H54bQqkP63VEBuvOhFqiyuennZa6RlbxmxKN2C+8dNS4lFzQbPvKFXvFJkUtFIp+LaqGk/MqqWCRzpPuQgT10Msf/q4Pnr4iC5rKI6uPz+8x8GOZTUhEW9jsqPHIBPqCtRXG35TbKIWDpvfAIYh3o4ggK4fFK4GHE8auiJWqXqqYNXqJhAeCXzPpwFm6rJhFdDphRe0DJR8MLIdJlCQxdpeGupqIw/eSlSXWbLzDCtkfrzzAJAdRhVigiRbtmGGeY4dPeNmuewkuWaKm0rpesJNzQ0dLlt+o37TW4Ejx/LCeiv4lmRznN7U/VsXcSHb46fhmBjKIfiJvilqCTQhMbEM7nkYwSFtWDQl+vhJRSv5hvRVU2dMUiK7xNdt2yr6vaS83OiB/Cd8C+GVHoZz9i78ySF9MVkwKk+WwT2tirH2GVYhyYtHfdo6o41AxDn9npdfPzIu48/u4wGlQT4sSYBfDtvx0m7oO0+ENYtNh0l35ShVRtH0e/ZgTXpRzKHXQ09MdyrOqW2Gh01UeUy9rMUc1w/d/K81bJXcSvdUk8/QSjQexICxyHzVbJO4rENEGtgcl5mUJIA9M4Ka5M8wtzKVJbrBsxsCmh3QcUvDJKw6+oGF8YT6OYpGcU5E75PpFN/xMZa/nBaRvWGK6ykF/biXgZT+aoIfaCNjGYx5Wb0VVBKsMKKwaoJm3E7NlKvXPdA0rwnbJtF0/OXGdWeziA4JPmbX0bBnFHzltOyFxzQEQzC2W3pHUbdum/IWtkDA3/ABjkLiEISEFViGkeTIIbs6+E0yOOrqCcpNJWTlGd+m1Kt6w1qAynmEWbk7hUHYSW5Ox0z7Slal55WSfWKwxzLzDcOdjjiGpF9znYqhRMuKKwiCU42hQxuq+HAbHXkY2RdRaSnsq+SSZQVsG7IoygwSp7HaZZTKGY8tLKUnLNdfzcNBQCMUCztls5RDVhhyo+W5zzBI1jn3x5zzRaOnOipR6Yb0rq0L106GF2yDyIQWuTzhH/Sw+YZIVRLuiMdlInCihbaRdtSITpu3BjIWM9n5Dho/bEicOJcZQKcYOw4VK7nZH8JcZC0L7hVRrpZQ9+xbXOoZ5Cn74j4HkdZ9iq6gYMkeaQMAFpqemxTYyeQ/6SXo8iXbB+4JUHP8G9wRRIswbrjB+JbtLJ2mXRNCxPopakox8oVgiRM6at29brV2fMEyuy3ZAFRlmG7BOV6InMdUjyC6MGlfmhmGMdJ3SewQYdTRbJGzfITWJTVe6StX1Q1+vG/Zr/QE2ywenx69BNNTI+lV/kpuBVvzcwpPz0AONRlmwpOURJLOfFTcOl8TUE9MLAsElHB78EHeheRLsuEtQnjlEkXllGCq+r2rJ42dRgBekE5iukV7SwdywP9Oo0v4lk4BRK8IvqItEeC1+DIBUrMzHwFj/lptZkWS9NUUXuEWoYiVrhZOLaEysUh3dZgZAD13YU+Cgbbm2ZxZi5km2HFua1YeDLJwQ1Z7+y5GT8QiTNOY+pVSUV9N5h/YGYokEbwC1ZB8Z16tZKBgpGA31NRRQJDy2UnUThJZtNboKyav1xeOPT7mmo9/dQtW1xdMW8qzdOC9eeEOdhp74Cw/5fMIrGQmV2WEzMXPacly59SGUEPWkL8kPsg0YiWkR/I2aILhKYaFhKCOsKyIOacu8ii7A1F9IStBAhd52l0VK63lVTXB3BP9+95Q5hfuazudGxzTG/63jK/OebaBC/wOFgQ5fZqPyeSdLQgU+ToU55S+56d29UspOF1GE8NDYaNALPVCGQXs4+z5EY5DwUPqIskNU6Gec1DZQhbrwhnChN9eSuUjwzNn/cOpGOGeCzVGOU35SgflOg5SmGJw9kc4yLoFhsuxhuvLZOUdPU0vI4mx7N/0rNCvQFRF8MMhJXA/LSY7LJgb0HVfTFwyawFu9J51ivZQE2qKA2xUup3A5CUErl1WA5/RQMqo2hNyGBk8KKLRdmKRiRe01owISndKJnQtymUffVuYWDldsFD8EawdEWDBv9rjamwFCraZoY3WR1TS6dzdVsyashE9EUKn8MaOk74FkQaIOBs2NIgMoV9W8ZFj46BswEZlWNlCfNFwhBuWvs2qHLLigj0bViXm1q7FphyswLx4m1Q0aQkirXWEFDeo1zVqkXK1xlnjk2hChQqb01n47nd21joIq8SKr4Vt94wJfvOp2SdVvWDM/pcL35U6LuH0ZyeTfYVv2X7Uszfsft7EAZVr6sYlnTnY1WJVJZoxbtCqyd74iCv+Nm2rn8b/gg6NmmpNCNZ10udG39pg1pHOfrgVluoXQbc2YV7OzYi8oAcz+L8MJlhuxggFN1ZOMqUJDMvETHbi4cD+rsKB3Qw4M1M7fYDl7QVNRHTn8yXli3cB/deQ+yKevqmx5xW855l50QNt8qeTt3l2afBvIfvpZycNLdrClaqzKV9rp04c3ljppBf3tDOpf2tk6HnPXPbpg25WFwZWPasFOyFHO2NiMQUrtKP5Pw1eJFgMNwzCpQUOL2Mqf8PWvnnAKnLHFafhGnh0NE3swKou/UeuluXJc9c2rszlud+nsFD6Z16fi1A4ofYapOFV6jCyRb/UKWMeQeHXjjXakp304/KQiXRJtZkGb5hrlnbLeUMf5xMwznPZWdH6EAqtUqMeOst6RweTpmepskVW/p8rjlhi5RCcgrpOfdn1Wu3WnJZMsVg2eUHPtYrjILLxHmPcJBNFKwla2W58Bqngs7ERYXvGT1CID9txw9KGH2jlpTYoERFTtSHHXMiq7Tpr657eXpVsrusOe+FFioKZutFvTTLRYn7YcChD5OLbUeiBX0Nd9yrlUrB/UD0uEa92Ep5h/egdD4Sb+TzROsNWK0g5iMBLefh6CR6Dc7GtswO0qomMJHUR6x9yRFXunRPwQuXb4N6hMRH4fiyrV9W55VpcDUVUfV+Op9+9FXRtzS+uIjSd6YyhXjvYCoXSlykoJYjha5cZ8nL8GP0TruPgEx2L38+RQuucGiSnL4pJsezPHkXR3JYEKbpfniWEME8XmTaaRLzv87TkB9JSPfxnkse/zyUQFGQ+cBxrOT6LerjVDyx6nHIDQNZedNAyB15kWRoT6oaKQV7oYYdn7+KognqkClpG8bcLN8V59qaFDBvzRpZjMup1lHPjGOyjTiSth6a7we8fim2HMgxMF5d3AophQR2N0TZYha3Q+Rb/Np6ZiyE7H15OVvBdbl5YeyzrJPCugmXj5n53STmAjM3l2HqvG0fJa0NIesCCt/UTj//sPTChHBOyZKm8UDR41lyFeE4paIuaw1jcNYaPNRzbnpcLXlCmEVKfKr31XEVj/03SqPw456KyLAJIunFqL3dHWwMusPNzY4/SnJEFztK601RGgz73cHulokU1spG01aGg/XucH3br5XNxq1ACxvQl3VnK3w/0LgZ2sSgojOfra5Efs2EbZG7rltkr/vstu54xEfQ0xMqtiabmPtR2KTLLYd6elKuO7YFBrOj6XXnYkPkFMUWWtbKXVvj5p6lRsX9I0st8x6fDaGqG0iWelpKwvL2rKW8cjMa3TDLN6MdQPjVaJ89N5bs1eN2oqUkFY8QSJeH8LpJw7m7huX2lf/kVG4rmlZpn6t6riWX3dizYYVubKWLeZX8as7l4Fd+GSZ4qF8KQZW6qj2BtG5PotECtj8r2LB/rrUlxKVFgwudZpNWZcYgPXN6fRKRfWXU1hDoBvjoff7BX+VudAETr+stCBtdx3TWlfMqG3wJkhLY0pADDW9uOmvbpU5lr83LZLWufnrUQaIRL2nDcp05yaqEyYW6KoFMPNeOCTvAsm6a9BvV8ta8NFLjFWyR9tFi5uKMl7PF18RLV8RoxCtpI75egZEW/KXvV/zEDLztLM+ZdlBRWuHwvldhLCC3E5XaFTz6ao/iiUQBOUsuLqbcWING/HUC/hjdLubuoJhFVMzgP/8JpIdBS9vvL4eJLdIo80zSLXRS2t+aTWCRRpU2SuOZuxHj1FsWVMwYdMOcmnVbEHbqV1ylY06bwqe0DU6lQ9kSKUzAa0rWH2rCEYfmpg2HQsHcTuc989wNMoJLFmeoqTmk4rVK87RZqUdfvT5vtz6o6gyr8ouqvLAXRsM/ylr9/snZ8dPjg+P9F6dHB2fHr1+92n95JJ/PAFFEImm2fTVBdso9M26UKsxc+mrCmIEMMagZ1yEEJCmOkmelx0u5+eZmtLK/8shITr0I7ci6mbEdC+1Eae0XDv98WJxVWcM/Fwm1TfJoROHMCuXKGKzSFRkRGpfejjnQQmYzZ1P5eK/an0OCWeHWITVYdX4CgVpV0UYe9Dw6oodTKu8Zyl00D1/vwm+lVs/U65BlByIumGX0PY6cIoelPlLuHisysjx0k06q+h2Lp5fmj1Op47Y8tTLpqL48I6GPbHSoVqprqoKVkUQVWsgHEUUN5BhCop0UokrfHxqHLpG6OGOXCwV5TOW8PEY17zKpa795vYVi+qPyQCJOYcY3DIO6l45xBiFcEoI2HKqdROfTaJzD0UBbdxzq4o4/9EiBWoJU06bh65BFM6Jsgzah3MlLI9lfjRXKXoaz8AIiwxV1yumVKdOLVGeBbjP8BJe8Fwhot0ghBO5pTjq3SJXctSDyIxr3FBD7/z5b3ahkAFI+n4SNoq5PlBEIHgXPQJ+Kx+W1LCA44YfygYqd3W2gBNsb3dKjcdxxgKJAveGNCr/Hf8gKxRy27r+lMUsfJCkVNB5/nqf8IrH1tgzcilEXf6hV3pyQYXKKRyLNsHyZWald3FjQIqPYisUzeRz18oHUpFTsdwXGH3tKHW2yI/j73xEvTo/FPXFVQHSr1LRuoGCq/YS5KHDqcilImecqSSOIkKBcOtcoQjuhXe+i0JErAk4Q1vvcaOmKiYUMNebcjzKH2ZbkIq6D/2zlE/VevgywY8URoVnHwE0IDC7GGGDb8ChX6FGqWtmZaojj0k9VOzEjyuZpsYpb0JCp81mbxNH0TRP+L/hUnwJzdljNeVu6FqU+OZTvidIXqher0gOOYwV7YzVc7ryMzG6P3pJOeeHUX0bhRDeDaoU3cK3pkxLrSdmqFlDRnWK5DXus2blZyjylBQmWsnOaa9yg9gSrNJf2SybXFKvN0WxxpeNE5arOTFCwzYekq4gJ4BcNPTFjNMZW0cGEuvBkILjlRFEw5Qk92m4RXEZR2npoTOhi+utX0cxDFbW/hph5RZvw7rGr3zOkrGVJK8g/1PGhypsVG90qpP4nknCbhME68blG17Ih1jfjieY5IA/lKEmmUThDxhLoMDJkGitea1xw1EdISTuek2RBltNX4YxKRhzZiY7soai0AnQntdB9RZj9/SnV4FGEaSGmRrqKWWRBc15UfLilTQnCRN6UyWpR5j09QHD0dqz3llZYwQiOa+H5af9TnL3hB4kOdOeGpHgZph+jlFRdAc7zYS2kW2zxWaVgNiUh94BYhWTGxdd30Yy4drH/sE4IPa1y19FMDVRovxix7Ci2vQEHj5IJ2xp00EHRtgVao/gYaIUqNwuOgWvUnsPC8jvX5/9oyhD43kN8M+YLVy6ZZZ/GTqabPm13aL3KJnH+Z1cgPquBTbYJajc0ipG1Wowj5AzQEpbVvJHpuADk6QbX2rP6BFTcz0A9lGT/nl8JdHACUTzatIYMq6uHlV23pZdi6rM9F6qgnXSldHniuXq2KhLyNiQnL//TiDKmrsxZRwUCH+hNOd4gdv/BMEgbxnfJvq2e9cDjtnCFLY/wVjP8Rqg4kwfgHKGQifhBQvFaPkko6yBHCbKQxc4Smg89haY74NumkXpOElqzlqjXiNWzElrLelrCV1Wtjz+y8tVOQg5nPvsJmdN37vMPDahYDpeFiNq+OZlE1iM/lmEPSpSnY1fzRR7hfgt9dYK082TeDcBXacA+ht2AhvPDq33e+8Hh1luVDsnqzuvKgiRXQw3RIPDW4otZkkZrLbm0cpe7L78B89QsD7nmNNiS35kXvJWqxh3uPl75HRxwjMPpaxq7neWdU6J68PMXI7hHGfbDCOzBdOqDMuc1HKSo0T7mHSVoG+ED5CQ6mrJUoUZcipS6WcGHEm1AbpSbxg/kQOeYFEJ0ATlOQMdn6jm9c63QZMXFcbeaU8xy+u91j5TRFxOo9M3XvSmK3ctmPTZcOgy1jpWTdRnvPjPJR+Nmx9M4v1VuJI4vo/HHp0kqjONtC0kfaVcRBcf6XCvVAkhoxzEsljJByjxl1uYWBs104kbJoRCELALAtxOaJdmoz3uGA2AvMQioQrnUGCkqIxt/NfNB0/VCEXrMZGGXeUIoNhJ9eBnDl8cMxmhck6289cQIVCm3FG7W9A0hnG0+9sev3rw9a+lKCBUrPHIk/dVCCohuevI4kKmneNIZvOJIvImUtvjsWkti/rdI4Ua3i3QAS94sksFhCc0u0ui2qsZJOIkXmer8jBTOPeiXmj7dSCmR5La12f+r90UgCqDgCLAuHcOTp3E0nXDXGKkg3UzBmt8N2IFR71X4Sv2uW/+YvzERAR/gHxEEms4Ufe+k9Mnf7djD8bheG5jfsY/nsdGKuRB6xgJRJYpzITRdEu21YFkUUgOvLXcH2uCl3SAzsfUxssJZ1irFeT2Dx7pYQ9dYgXpmRotHCU293XTOs4QftyCoLig6LmKwhQTOPCVwV4aLXBnziOjhFdMDDylu+A1oMKXLtUjAlyJfKTSM7/uVWAtZURbZ7QvC6rk71fFW4HkqKKjtrNgmSo3IWbdsq4Jb22HS76trO/3vyk4tZQcSNu1P4wt2bRGGv/VdMfJTjMRocb+U76qTl+q0UYSI+647fZu6U+atN2VeCFRpRWQlzqKn0yTM24aC5NaQDE3syytLLuS/K05fTnHSWOF+6lDcz+2rKVE5Ghu6ILM1J8kX06+o+JlTCvmFCoHCPtqLVM4SjwErii6Y0vvUvDrtXFChKrLK3I0uSQUgNbR+HW3SoPMXVCUFcSgNRolLu0rDWXaepBRaNg6nEb23Zc0VpU38ThWqJ2YyKncuqho2Ox/NcLXKKeX9ChXRqT1ZrvcbF/zlu/wcJJVSS6uIbJWzKW/12hDytEZUI1rFb4LIRRttinQAzTdF+LBT+Gr3FnMiWSIWovl/VGOXSaAoMzkaP1KV1b9CaAt6PkYdKQ75YVlrb+ntgBP3Jeys/jbWKlBwK+B6z18F11e5EZu9r8/bVTz5Wc53eBdmU45U5dT4vjG4k41ByRP6e30QVnYWXFwK+W4gvZ8GUsNU8N1W+t1Weg9spd+Pmf+bTaX/a0fF9GZIi6ixJRND5p47sZHC9CoucMoKUOe/STOy97K+otT7b7GjwrX1r6VoEZYoMqEiSeG+oEOe5kiq3fEQftFW48TRi6MDSQujIScIXVdzBC1TqYDay+LRaEoGu7gMZk3cU9S35UqCSsnc1cHXb8CpXg7ZQMr3cmnvXTQCWX+MtHOihiLrlCqCd/dQT1eyHrZJ/W6gLs/mIBUtlITSIculffVPpbhbAUWKOjRQpXQjFdSAsKQOqsDLfTppVwKVYo20QAahg0FtZI/0UfOs8Fep57kb+fqKXh3P+rtzKMR9BXHZXaH/yfIBd6dvogEqTGXR/mz4IeqfjIm8mMTqUeMywr5ACxW/RVa8DxqhAoaDUVOXxTS6K3Jvob5OGuffoO5ZeTUIv9chD77tchB2l+fOjYDa1Lgjv0reyvLKLIjRVSmz3SCE/Bsi2kRtIyLnEEdsWDqUHL4ZJ9WqHNNB4AGF1azOqNaMIKJ07B4o2HJXUZzb2OJZUyFfjTIuEx8Mdcl5oEhrfGSlgnRbz0179B4be6cJ1v4f9IKaZgKEbpzDubfqYMJfxGm2umWiyZ6Ayn6WrERaNwReBJrn9sE0LyO7B5XGv5KuPbSvTj67CYZ/0Y4sgB6ZG3qlh3xI5Cgm8nr4IytABvtHE/UVbsTwGxU69RR2tRCGjpnXPstk/u9bq+9bq+9bq6+wtaq3lDZdGkoZVWaG5uobNfiIajzZvPYSEm8/9JZuNVeJ5dYItno9fuToU8d7OfksZ1dFyeokHmqALGjoIPpaMPiDRy5Q/biFg0lD7afS60S6Z48ubsUulocNvcZOkbUpwgeTKEJx7t6yxzka9L5o9PpOGrsnBoICjqSblrqjrl9QetBTpONZ3sZ8YIpN/GNNk1tqD28EQSuQkYMGN1dYLZYNh0GjyqQhh3IrzRqt1upI8tXNG/oKaDdwyCHmvhs6vrqhQyR5+yrHdjRn9Gl4NachtzSrBn1ZJFHHXr5Jo+s4ukHeLtJU6pvtaoXvmWAZcAzSteiMQwaV6ILpmEiUwyRnf2k5H+2+uJeHfrRolLogT4hGEs0ClmJ7fJkkGchjGT0phc1XwW88JTjZELSafJC4a5rtCklhGgz2VnSpJedt2rTIs/0nL44klzgo7rUdlQpiuzPpNb4vkwrgOzKpAHPFIqxOGYDer+DfFWsPzWhi7eiJ3ktlk5cq5q98MnCBOpRApSqcyUDb+CjT35oKNr5uWet5Xh+yVMMc30bTsLqilu/ScH+z1bAZJMzyxbgPtqoLF2uDV+ncG4mR3SiiC2DIlVPW5x51EkTNRkZ4wTQkSMU1jhv6ctxkaNCvL08cnSOHX+Dml7YaLWc2lunOfhRZzKRmHE66RlkfJ9w7cpW1DNIX9k/92g67hGcrnFbZJFj3ngTreJ5dJUu0PhPWlfoGQmXo0Y6PXZCmwPL3ud2ujk/AtrxdYQ2j8LwccdGK//OOuVqex0JdUrRu3InNkfNbcNoQXy9KbZ5whPQETfzdtU+mrinFCNHGONXIy4i0QjhhjIZM/p6K0kxFKVONjBWlsNK+vsPiZXpkHzCL2h3LTq1qwWq0XDW8ryXDNG7ceZhPvIwnNTxDnGaTr+VKP/a+STjG3aZMXRG3QqFcMq4IhqrZAGGlH6Onlh4O/C4XfjUrQjNXfn3hWmUMODFSPOEORBrmNLDdTBxjNPQYCHz2j/dMpzBZ3v+IJcVWy2BN1Z/YY23MFZK7h9rOODUMqt4m1Zo+Y7WNqt9AlDxg2kv7HYQ9D0voZTOTZ5G16atdCx2HRH4UTj3LmicziDM/liyUp++etWEM7IZAlseQWgGzZgY/omeMo+CKkjJIZmQ/Fs4vW54mU3Moeir2Vs3P1+i5gha+Wy3/u6yW37QNSRMZqwgepDo4SPC/okGozmXv78Yj77g+3heW2dXn1YbvsTREVxSspf96c9j/tqVpBR7UeoIuyYOZea6Owzlk41MW5vq7CXnbtGrTgGnY+RpbfGxp8dvuewYC8l9jVr+3pilbwT1J65qMxVl6+waK2K7A0/yKJYxethhD6kd9gy6DVGKQ8mcENyLNlw0wJLXyPczQf8WW1DgUKXak+saTn5OAhsivEx1dzfPbbnAVz8g/4aduMOZDqVKrLIvEEv1AaheelHDOorwLP1nfjV13kZj6Sz+VOKflXZc9G4LlDxNL8q+JHvnXgpf4qkdaOyRzTTFQf6inPtE6dODYDGpLQBT16bNXIxbdyd2KrDt91u0AMCDFtJYdRUUSrqM0JRx1lV2onML3IHFOd5fkdbFOTaMwZZVcNcokXNDyMxpWk1oIn0bRhCJDYbzMLroU1Uhe5dgDRa2QWmU9BbdP5SCq6IsA3MEs14pqT9C4KDHbU9uHizXUMtq6uYzJzrijXcWywgmKKlLGSA3kPJ59rAeR1lCkBwWppDpj3CzJr3iWv1ODjsFTFqxEeyF7Wst5xFRNQVKhqJE9T99pnvGaPZqRU5SS/VxlgW/jkdYZeRucg0wkU3j2Ux6MoiACidDqGhKDj3d2E+fjS9EZEDDlAk2TpffL9NpKzmX6clC+lIhXODaLrki2W5WaUiAdpCxQg8vQOCNStC3a6AT/+U/Z4I+PZKiy5deLaATRCJYPtvoR1ZjoF9Gkpe+yOGcq+BQitgO8WiD0Syl7l8Tmgm7N0oAwdfT/LsIpWA8hmm8BX1syG6EfflLRf1yuEkuiDxdcVeQbY2/y3vC/gPfeUKPidQQAKd2qBlDisf7yrbFR+uo8b8Hrm2N+Sz/udBas/xfMAuj9OJ/eBnNBwFoyueTBRw0mhdn499nxXzM7Nh6umO1r95q2ATFd5gkBsrySIXdjGa5C8fqSPCV3ZBm2Qjtyp0y1uSKmkkVm89l03oDBVCbqf9nGv3P3veburfvA3eaivDSbr0Y3+M7wX4PhV9kRk+O3Hyq9ND0BC3bXz4O8e8Xowvz04FjiwSQ6j2fMn8QP188/eDfWkkypUE02hXo5VErWMem0Jr3FAtiVZmOrR99YNajabhOQwaCWqPIacwHC1tXoU+8qyrLwIjLOxKXzk897P/zw4EGQjP58cE4QfCC5Tn5Ib3p/ZvQ84aB8ehaOrIcJES3RDegJBmlVeD4pxl0ybFMGxDg1mMTXiOE/D0cvACD2auJ1Vs99p8QlAfalNCpSdPnNee0AjmFkvUF4/E7P+EMqOH3mS8xV3wHu8bKhu2CUBSV/jnM/9w2jkdJZZmgvy7xUhC9D6dtSyhRGv148C8cg958IlyvtepgOUr7VuCqYnGwrhFjSyAHUF6RyLUHHyImLYbXHO4UdO9hJBYNauh+tV/EAqUHHzKuKywcGLVmwg1m0FBFywDJDGtim5f6rg+evT4xcXLyikpWJTn1LOeRMDZxUbc4tYmxI/VMaRCGaON1bXA35Jk47muUQpO8//wnc2dSa48b5eJFm/OwINA895weMLZIwjMPooJFv7nLyyReRWr9APrPHf5uNsvneLw/oj5bqQZBF+RmP9KGGCtFoUSccCHgaMERVVwOqKipcbvefQUSykAbXPF6UmzAimFSlLLRN/y/ZHJUHX7JBxmx6i630YhS2+92A/+209Fb82hhX98TZBwf2xtrgopZW+GGNhcSu0RTEoonrCvVGuONwxkf9cRBw8hH/BXNEF7IcBZFP5NIEoLM0ea/4xki67GmaTKdWbZZU7AbhbHwJKi13kKCjKpwgyM/C1+kJ/w25yAhnhenkyYXw9EO9jPqKe4kMFhCSfysFlQahpPJgz8OdSei08bUawVynSy8bw4fsokRveCld7FiU35JHQQQv0mn7J/BFexhfkf3Ig+z64udPV9O9RX6+0wX5Lkd44And0hG0cAzl21k3yKiG+1NHiRvMBgfce+gXL28h7hvBFOl18w3Zl79gkerQ12jqK6U+9Slq9VsoaKp7b24iLw0lvz0YqqljF/Hhm+OnIfCmNW+sCdHq+W54WQRKHDLDkdIErV7NHvQ1LEpuwDzq9TLyFZI0moYgQSxFC6c4J8u6SSSxakWsFrFPn12H2ZMLh9p5sP/q3f6puueEZkzNSADrYC1wtKacrDpVtWLGhRq0lH0AtIJSwBdrSQFsuLmFvvcbHrPqgVAyV0VgBrBja6n67pK1ThU9lcKVNFVKu8ddKeoce6WkZIuQ4xdJJDS2IFfJIosmyc3M3IbQai/h/SF53y6gdAPcRdHRAIQBdTXwEsKEVjbAxD/Sxs1lFE0t8Gn7v0EBWmmJVsjOy0Gof0S3fmSqmUW7dCYmLbydtxt6hzYAygkhbYc29vy2UmZNZSOlLLR3H3tR3pNdy2d916ov43XwmAi7Tfkt+YnqWk2WVsBKJjlyn0WLhorfJ2AnD9fKoZJ+leNaP9a8Nl03r/k5hdxlXsrWbU3F1Dz1MdVVvbFylizGl6d5mOZtPkGkoQF6kddlXGKyYRgoiieBPJlGVGBQIAfsmg6HJar/3v+jN57GZB78E336XkWHAzlZzJbFqQSxHCpHs4mCCrwvxbA4QNDwHNG7wjRIxcBqarARsIApY6ujWFX5Uze4lZn6lD4/YfkxWCG4qPUEdgtkUhxQ8PC6LbldR/8khV+G+WWP7iran4I1CRBdNaXSMZccUgWirRB1moB5IK1K7BbGb+yuxuPH8ixgIKSZImAaZZSZIkpZZkohtnAhQV/jmnftOVWunyviDGDjugwh1/nOB1+FD3Q9x+AGGbOfH5HxnETTPHxP+tMPfg3WBsFDEWNAuxRGqWIJKdNXjL56RUYqS9WCZJrFOIJYFdCFQ3aJGbnhV3c7W5uYQpmzTKlxMmFXE/bTNLmhFs0W2k2hzQQW0mAX6xTSWBuF7Tje5tqarU3FzQkfxy9IY/2y6pRF5JBOwRTzmJ6Nb5x/kq5k8j0pkStwDzL6RLaRw4nYQpKi7DoQlTLM4Ittdrv4FteRpwL2xmr8d2hrFF3EszdEFpUBEOAxbILOknYc/Bz0e5tgc5bfQtRZ+a1zV63UzPI0+UjW5Ft6jYoSTQoeX5bAJpKyiRTbXVRgWreeamBxqZpsADBHi9fGRwzITIVvb7M4FmKc+AAmB5HsNvTLETdGAYDeMqBlKT4osGiRljYljuED8ok8XoclDXmzpr85j6dTMRAt2bpkjpNy4YtxaJJFMr4CoPxbHclbnKZ8RNbUnhr00Lu/9m11n1r6nbMEJOmW1bgqHRNwk7T1iGAs7lYfglrOYucfoNdl5ZJ0MpY/5QmkgqB6kfxgzwLRLySJvd5KrfWDPhGj5B/MYu9snBu+W2PCe6l/tTeSAW8cSafTHnVPonkU5sxHZy2lP1rGwUwZAe8sDWcZu5JulDr0dRVS65gWOv51zbTUaXUqTeZaeYfVUi3osliqJZHbpfz8lP5xDD5itOWgjcgY2qSwBDMsMKvrt6GCl6IMWr0jHE2t3HNjCezcvhue3g8FtFreD+zGuCkbuDrF9Sc5PEI4Pf+N8yfjU7ING+wp7wvhzfmzLMFx+OkXIqsCIqtm2aPWZZ7PHz54cHNz07tZ7yXpxYNhv98HadYCi1Yc3YyST49afbLL+YlIKtYo+MeCiOMt/Bz81GJvHrXkQj/NPxEgrBB7U1aAV49/SWFbC+BbwS39F4PSsoBoBXToHrVgmXvIFsQHbpgl/Uy4JekM2GwtlmAjsG5xMCtsHAbl8U+yhZZyHRakQ3GrQKICVwsoqVjvMr+aHpDtkxb8TwpIoBiSx3oo4sKpQI1CXaEslJ6x4FdARHg45aGm2cZGCaCidp+mvTwrZ6LiRXAVXSUpgXoWX0Vqeho5ICp3/chAZvXmC7LRkjZQ8v5KDfnyCEMOle6yeqP58frHF5SqVK5eZvy/03k4prnC9YN4JWihzWPRWpR7m3qURJwbbbjKsQqziCgXoXb+mKcDr2CFovSwTulwdPLsiZxno/DypmzRDVrkfUvy5dZqPz994axN3jtqv0mjSXTuBMCKEF6aOOCc5ouRE4qtLjAqIUxWw41cVIFVmPDZTBx/Ge893amd7mQoMJcjdX1oTp/LWuBwUVvpYEb4G/ceJZzXK33BOl51CL/VrsNYrHY1YDp7pSGq4TKCITIOaSEdeJYb4vxppWnpMVejIhC2UUVOXaMuaHUEm1qrgijvWBK0IsZ6MGiZ8k9CTumDgCVhTMhQC2NR3oGxVqQaY3UoFIwFLAnjOaX/WaPF1xg7pTEJMq8oPXF02Cxl7bNZlHbvRXibUPc+okh+IisDqofg7DhVFwCyW/1wUl4Nog/3J0xInVKTUcEFsBYam0hZPzyJJqzKkzL6ICSYScemj8XJxehA1aeoIRzKFjV5bOyBgfAzb4SfORF+lkbR7C5QHhooP/FG+YkT5SdE7b8LjNcNjM+8MT5zc8WzJ8xstFK04WIMhrXgZekosdxg9MhssvESXuECOMQ2lniVkeZuLNMSrxFO55ehtSPo+ZGCubXEk8oSZ84Sl9n0w3M3GwiBC6qukw2e1+Db59m0mXAAhE+9ET51Inwaku8h2BfvAu+hgfcLb7xfOPF+sbiKZ2AZvb0LvNcNvM+88XbLCVKwppzwQRuTEzJb4zPyUp3CMlvhFbKCWWzDitebFoNlI6unyFD6ZJ3Mp5UlXlSWsIkMeo+CHopktZQtuU61YR8pjalYGFDV3FFe5bSXPTHTMdgLi6u4fVfZMvGnE6RDyZPJfEhe/v6HouqCXZc+L41fZY3CgLze11/5GlmK0vpRidyC7eoB5img+wmwGPSeIeip8xH4fmwqYQEmkm1iuCc/T5Mb/ny9fC6TLZ+UMQcU75tynA651XBipIkviaPGvFf8C5ThlssVtTvm4AxrDc5wVYOzuczg2OlV4rkMnYYIndZr0Wn9G6HT+lJ0Wu9Ubw9lIEpx/kISNFj/yy4wd2CEHGQPPfQNJQFlq5cCpRyetEQqUIxxW5GFa8FGxx5GQqpflQmbFi1CNjMLIKEgWSjLjCgFmX6P/1DID5WVLBxZ4XhhJICGsraknKzab2EmbrkX56Zj5Lg0Ey4MIkWcfEpCfzxnHZC8phSuYAzLwShMyVcjarem2GelE8G8sGizN3uql1tmLmpy8VfhFWXH16M/weH1Y3SbtdWWHG5pGCycZRkqrIMq+N8xIIRCfygE4PWzJM3b7fGgG4yHyoDRq6QDpscRxMZD9rU8/+aq8WAPq/DYXmFNr1GqmKyd8ndlY1LVxxVVjWZLjZg1W/6ubFaq+riiqtHsJXXnJJUu5VijloYuqb+ppXAJWk4xUM4fyrA0X+PZCRKaB5gmmhzG11Wyk3OKVXCOxczMpGnIFJ+/BoMt0H76svYj4eST4Eu1McpCSQAy1Jxaq5uAgi9h9dcGnbpsiioC9E6XD8mVftCvf0G5+ZoypjlLyuRJSy8gw5oryNBnCdEXAe8AUl43od1XqpEb0u11MkTygm8dGDRwFTIqUE5b5vn+oTTZs92EPkAdTTzQrL34+HSZhxdSoaC0bA6QE2bTYduHHDdpTEgNZ8ByUT2phbDWnCV8rQfF4v9zCytMRcDlF5WzPRqWr+3SLjq69DWWUrRNMk7xOGpXIUWUvEFpKawEx/zgx5gaYfUjKRsCOj1m9Fpb0/QJpCZogtyQciDhoif54aNV+OcUxVQ3HWvfzOgk0pm2DqX1l+0t+KMEJUFiy5j1Rn34g8RCwcuXntB6K3j5wpdX64p6tm5UKz2qjc5U1PzL+Q78KerK8aNYylcl1wp9AguyfLiq+2nyI1eGABriy2X+9zkA8DkC8DkEwCNWaehLQQw/uyjx/PQFQgk4ynVQwmXV9LFr+lg2fWybNkoo6BuU0I+Ri5IIeVgRwWfKYYnkJQq6JFnwSgUUovdsSr/L6yaIDflBeX8KyqZ0HwXLz36ahrdwM7DWjZ6UbntgGSRttcFlpr2+BSpRTFva0pda6jufaQ//Sp9O9aedFhLZlDQoCIQdzmjJxhguVov/gzJ+hyAkoaxS44WTfF+X1JcYcdusB4z+m53VkBo7T1qK1BlC6tNvjdQ4H1cMQBWpkSOwL0zp+tNgpfQO7QSfogS3DINlAKrorziwSJS/KPjP9BgoKTFSSj2xlMqVUl+Kl0lblLQxRtoL7OGoJu00XxqJeqnS45NvmHopRqh4FdRT3XpqE8+PQe8h8S58KFo5bU0PozuioB+TrpR2YU3ijVDFoKFA5NtOnjX9ANt5UiMPe89fSfZO9QUz1Ukh9PdhiaXXJUWw0U6jepuDhhUH/WHTmpvrDWsO+xtNa5IBbFCTVCP4Drdr190YLlF5Z3OJyrtbS1QmdZapvb0MyQa7y9BsOGhYm9YZDoFqA+j8oGAxPqdVIGJ6TyK4N17O5RXZuqjVz27vEvte5dDC1hi3ycWl/U7N31CEy0CFEyZv1RNMq9nSx9rZMe/SMrBg1fM5VVUv8Ok9w2y57OqrZHRid/LirLwnhJhZdAOEYWnRA6NLtSpMIDpoyQqiIqiYwnyMYR52Fjf+0KLVm6fSmuVnp3K1DyYvy8jaT1nk8XW4NY+9/ZnHNRyZx/4ezGMPP0S1rI9T5biuN+W4rhulBW/9eGWs39K6jz7ZX8fRk8fIjJk++JJduqWj1ZYv5ktZgJDrtFpCIGtBCSSLE2lvVs9UpN0H1lqkcY/gTbLIsfId181iiBnAqyLp5R0XkdWVDjl8kwj4mSzk0XrRdcetCPkMIqVZ0U2e7XgfMaBgnlnBPKsD5okVzJM6YM6sYFzeyVowE6o9we7UJuW6VgHctQrcrlW8duqIm680vRwe9TYek+VRx/vwBgVzagVzWgfMCyuYF3XAnFnB1OUx0NBtK1LXum52retk17ogfgs8Voa3QHSdymX4W9Uvvl0l7uvpGPdF57LvwwRPa3eepEgnPBXgMnlT+EVxQomT5MbLq6+sQbAaeDnqlcXV7FEsbxQ9gKFZx34uHiFNDb2aKqvsi/wlfpnMynb0W+oFLKMJ76hkEnDn5fqiKQSHMniXQpb1mmQ55rlbbHWOX715e2bgvY4gJGfRLFgIKQfj7lds6FdsvXC2wm4bFJVVI5UWvuRU3DNmlO0q1O/KtGo4vzyD9usxh6TYxSLKsWJMMMFZCoNRwbswt7NYyxdLtWLSkGxaCkBFstpgYpWeNan0pEmls6pKRmxlxU5j67mytvnioyx3dSq9aFLJt+eig3Yrp+QmjRo6TXdqMEraIt3JVqzmtlWlu5K91NpZS5S9z3s/WE2rmtkVPb/SqktGZ36ApeUFnp3HF0+T9EpKC8weNs4L3A2evT0eJ9H5V08Q/OWzAFP3lH+r/vQQvlhQpCq1r+Quzq7fglXm30X8QttXnyTEEkYbNTC6k0TFcuD+erjkRpC8WpmOS35fVZ7jJSCiWY6XgGcL+SWBrJvhGMGmXn5jrDtLZDeWGGe9CRNbMiAvC/Z/OUuyNML3LEfyUpjdjwzJtabu/05+ZBdZgodeMtQ3N/JdNYXmRb6rxmrkRK7muIqMyAYAB/ZNsiGbCBq5kH0XncaZkO82lXGJvqJ6S5elKu8sldc3fyPzM7k5BtGgjaR2AavJTSgDJZ8LUUibHveizN67LznhFDC5wEaFetDdgC8Xo1PyLWIHCNgdK4ljPzxfjHgsSvUkQpaUdJ+RXr9K8vg8Hof8XimD20sh/yaFIBg4aGdReh2lHSzYx0DcgTRR6I1hWePMe0C6l2M3Ia0VXyUTugn+vfX++dsnLeoipfZdW6Yt9eVfwz8UHYZ3+SAhz8ZAhsMoG6fxnFLkZ51GpXtLdhPn40txpUuqTwdKRo8gGJLle/hQelIX6f4fyuKcRhlrN+u9/khUzVm7PejxtNACahHXWFJCRdwvHrRM/QDlZ0/BcUSW2o97ekfW76YjT8N4Gk2+YGe49eNuenNIEP7HjEiNL9Wfz7hDFZMfJ+z05u1x+xJ1AfyyM/iy+eQdqJP30kgttrQ8aPV6vdaei5gEJNx+t1x4lRvPeJHnLAp5YYP6wrSvlpoqov6jWYvm1swwfxmeh5vn562mI9j/Q9MklVxRjZhspfCGFfAMH8xliLkcqiYp5axcqyDlcvCGFfA+K/ERSshgaX5C85r2ohk0MdH4XJ4BP6opMspCE1Ioj5rBYZq6hEd2mdycXiZpPl7k7QoQatp0GYvaUCRBNotuyNtCMyXfwWTf449VM40M+oZqrLRpNRG4Gj+DADlLYMlZjOQjezHInpF4yuKmGRlZUG0WtxJMuRKBWm1ppGJiGeVtZh6poGl4ll6iZqw56BOmJUtontRsRfr7dj4n2y2imbU7inwHXa112HpopI5SGIjUJcvR1T7VXduKjqFpGAzgEQJQ4mpfcJ+VmFEGPZNFDmusdjziJBhuXpRYRF+3S2haNntnM+eEY7N4tpKGlOlw6HUiJQafsK59z6HvN8o2vvQuQhlzffdQjdZd7glM1AYCNWNnUI3p3en7n3/QMFDdcNoeLeGSUEAi23oiscPp/jS+MJMlGsW97c1WC6MB0nr6Ic9EOZtFAUCfsX6TSB9OsZtYjIz9xJfofs0BKIN4NR76OyNnzQ7p1LdZYai4c1mlvsBoVdAM1WPRGie6rgTL52mprrVtdj1ll2Y37Qk9DsACOAsIxwLmpeExLWKFeMNqePQpT8OXRKyGF5Fds0ZY4V+zf83OiDISEG0hIB9EiiZEO4nob+AScIWA3++TcZ6svYuzRTjlvt2EI87zmzCNesHxeXCbLAIKn8DJu/TnTTL7KQ9GUUCbzJMgC8nbKZkNKYEvzAUUWThUyD62W4cJBxROp7fBTTjLoR6HOy7YXGdDpZfqLA5+hbIygfQRrEF3lfJWY0DvMM44sm0iVS4jsralSpvl8ad2SdbHmlHclTWuyjYxK1n6oJliMZBsWHh0z8o2OzajG5xezsg2IHsZzsjwgOf96LcwY9AntqHpVIyBcU+qYlerXNX02L3q5fmxBMCm70sngs8s/GIX3UxexpPIKgGYPHFNfkT6XMdZzPIlFChK7THZ5NceJuO4iwbjVRGpFFT8cApr6EHCoo4h0E+Onv52fPhcXXsFuMcBWbeiaMb0sw5m5ihblosGDwKzDTsGz4+Onz0/q8CBp9P1QoJrFToWrB2EnYpt+N8fYXAfVJOVBrEO0/BKRAUh/7PDsDfwtG1CLaYKq1ZERD27nUfUkqq+Fiqy5JyDDiPLeYU3gcW3tYyECwxw64Hw+WY6RqbPPV60CKL6bJqMwiknLr+X09qzrtaciO8ZCdsMGipcpOSWyLSjOtkBK1JkoVcB1Mp0h7etRlTWYXesrSKxcMMR0egWktHTVmnK9xd9yWXKVjYV/lU+hfEoybbSaBZ1e3Fr5loHdZT9FPUfVZjT7pZWAZE5HK4QoHBjWwXIyrS5WlXPzC56rWGjWoOlN29Gx19F+U2SfuTzXvO5luZUN2jxoq0u1mI3cEharc2DcE7W7MinzVO6rgRjVmP5pk8ibmvxafyksMws3/DbY58W35JNRkBNv+fheAXdPfo0T9Lcq+X5hPBgFvwt+OfLF8s3LOVMdjbboKXy0k44i6YHdXIs2ypLGY22Kkoul3fZC2yDDMxecJvkYq4CXDsrsynSUM9VLmvMDMie9bmIaVy/kBONIbw9blyVzdrG1fHU0cYKZEmoLI+ytSp22GvY6/Jk7lhuXTmpfcurWRnmDhnwphQBc5EGLvqUF7j+ucjy+LxMJjRf6pywrK+mr+sjJa7C9CKeGZdj1v1VmbnqekJd0qmVagrXrZLz4F2c5otwCmaAB8x0JX3VrVjUFhocvwkI5nA0QdYEwINsLC4isg7PhN0pyJOWISPEtLXldEbHt/Q0bLIXKMwrNXV6rZ50lUpNE+Kow7cC8jWifjMNVAOcmtvFFUHWch+GC2kUXdV09txZDToj5CrWxqpA64o8WeThq39lebtUp9FmFygauDWszLFBa/25q/XnSOvPsZyQ0ltFQO0zwdJCyq3qMooBErHibPRrMFrVAc5zhCb1iaiQCY7jFw4qFfaCDWn//yVo6XmzsRpgJS3rHocVwdwXI37V2LSlw4s9x91uXsR2pVtCSfVO4vE30XxeNa744pmajJWsLFYmve2rebAq1hJkh+VMq+VI1bW+BDxFC6O4IoXcR8Eqn5AtJzud4NvPEf3Rbr2KbtzXBoXpkp1BoL6FwtetGGPnRhXwtxkoCyx7Li29PJrROgO76aV7Y5wY+3Wr3tmRiwhSbRcV5CMnjQ6H9JWbEsgRc/2O+hx7ubqq1Nc766s+l2nO/OtgIrTcCvnumJQ7nb/Fk4sozwJuhaebglEkbHSTIMyDcHabx1cRwTJZgLiA3cgv8ePTGVHALpP5Lw/ix0HC/DLC6zCeUvU/ngVUAKxRJzwG/hNsXAKC0aL1RfdvhiGhckczZRfyphFvznMrU1RZgf6WekawqplkEou9UI+YE1WzOb4iizEctxUlUi3UkZTC8ouiWXu5iSFC0ptXz3wDSpmVT98tUZm03GPhlybKGTSfi+xI81Hw/jDMwxNC3SglStBB+bJHALhgW3I2uijRy9k5aoviNUo+taobyCHBxDm7adrKCOWjdmGY5FLZklvBBZVZVk5MfaXZMREK/YVhAlgSOOKSTK9rutc4Pt7wPczZ/c42Ah2LNyBCBzjL04ueZHtXZCZlWz0b156+2X8lpWAnhRUB4GRHsl4XTnsmkgDrbqYSqbzcVCIAXLDrTiWo4z2VygZWOZVKqHcxlXToK51KAPzuphKBXmsqyeXvaupAj/2njmvBLTQSuUBaxBMMaugZX0/HgAMcsmMmlHh4v7QMnTdKRJvLrhKGhNzT8Cqe3mKuaU+Lt7UAlr01wTXts8NuWsRdqIAghORscTVyKGlGmw7LQ2VdVR4q4ZMq6xZ2u62+X7UynrC2Jh2+OUauLlciYF+DYGtNY34+jaPphBvN2naA3WCruGvyipK/9yp8pX5vZ1RadUUqGRY1tUr8kq5ZZG/Zei0RjFRbThK3CIqt/3UpC6Ufemyg5KPgeymFoTQzEbk44ujF0YFLhSyANBVrBoRlBTkKsLkgp/uA+N/k1WuqZWQ2lYSpT1nvH1E072XxCO4yXmQuu7sC1mZ9hzrcbmQfptdvzo5fv5Jv6bEqVOLDmYDcElwNR9Smoo4QvkYlQSPUtKrTnqiibQawK1/FLk8JHHWt4h/KvCE8Nb41kHGj0lwrLuHYNOOiQD0F2ay2lOykfLqMWwHv72+wVnsfxvJWPS+8BazskoKMwVCEMkX6YauyVwr1KBwVsy/YC50fDiREm6vFMpSmEhmBsaxMtoBcnXqtNOCpHiNI1VCQkdo1VGSktp+SrFS0yklOh0pFGUFjWVVZBtkN1u9IWabgLQJZxgARyWzyWqQyWtdV6Hh2nnhr1FWAVKE2jz9F06xVG2+A1FlSFJp+B1ZAjqae05Nz78XkHiwkDGPXSiL6dP+XkufCb2G5tYSBWXIxUYCsaDUxYK58OeEt1FtPFLTqLyhK9forilK91pLCa1rXFEEM30VFwWRFqwqDeXfLCoPvXldYmYYLi1bZWWoVS0sJaem1pQTVWVY6+qwuApK5lSqAOq88VngxFBsq05uhvAPlv4/6FixXPEYDmYcziKmwyHhQB9UbHnxQ4tkiWWREPIPVgpQmAGA2TYJ5lMbJBBzsqa9LO+5FvSCLrkHKBjdR9DHrdIOAVIpZW2EaBeliNgOX4jgPwPeFNHBFmIosIjcxEU7T+Irel0/F7RMWOeIqLIM/0CLUn4YM4FQE3aU5UW+pmFpcMcOF3HPEObcgqNONpmoTXnLHN23GfBl+IgAglgQZTO4yGkzCPCQjMSaLfHbPzpBgdl6Fn04ppifROPPXa5RqvnoMVqmu3mKD0VxPUSFa9BKsWYceghV36B324lgSDqw0rpWoJU0thLxnVlfKnW+ilJVG9BGszbr6hwKjGwxXrW8o8Lm+oTxz2hLxkkse7rT75N/FjAvkzrIHPf+NcvIiDeeXcF8sjriwpFEr762sBDwbyEpRrZas1Co1kpUIjCVlZQHRJSu1ZqtkpVa8Slaixa2yUivtkJVFSVRWvqGMScTkM+BZWtomKrUmG4lKAeOuRKWAL4tK8axaVBolv4vKOxCV/5pht2vhvuVVSM/GiSyYJuGEic5pckG4Jyhi6tCtxnQq7tqSLcEkuo6BJoGILge7CYghe0E4kd4AKAsF5xHk4IZ3wSieMu96KqGZdyCEDWo/O33ZsewuSONkFzMLCPOzWHWXYc5hRt/3FTXXS2llfMAXSxh3MlrnaXIljf49XThBz3yRXNReOaV6NZZOs1aDtRMHstTiKYO0r55mw+7l0yzvXj9t5S0LqFncuoLKRd1L6GHBsI511Gy5wUIqAekGg2IlXRssu4JKgMslVHpYtYZiRVe6iHb/NVujcaWYAP6+qIqb4+dgKgsDvk7FM2gceIKsYz+R5fISIqrSCKmEcVPTTEZeQXYtUjoNkumEyWaIYXNvVjVbuCqn5baEW/9m37JhTpTxeU/UCbgNGE5hnBZKMKtgFJHhiUGxGYPVgobSTdhYXIbpBELnwh3CkGgscU6WyZ55Ge/tsd89PHFfYlDjvE9UaXosh9Rf4ghOg+a4NlKUtF8W0YAtdUVEg7WSiyEFTOz+zYQw+AFcCH0ClbO38wN2L/RlNFuYEJp5t7naEOdfoglXzlY7f5rV6y8YS57vmw7MyQK0e3rb9kEeziGbAXQ/WMzF5Vt68/ZfszozUVmX5Mk4rD8Zh97sP6xm/+EK2X94B+w/lNj/PTVUFH7Uh2l48X9JcnXELp6bNZuxvQ5eY/Xhcqw+vEesTsmZBf8mnRTX1SdpDHvc0W0gyEAehRdLMPvXWnNNM0NOt5lkdQ1BRQneHoP7Mos5z+JppuWlI9CRRkRfgiNJIE1+mcKdfaJlHb45JspRRhiS0o0s4nmS9oK3MzJ58sWMdI8sjrMkp5YKYXoAEPM0mUcpeZlGNPwkaSJOzaZ7wdllmP+UBTeXt9QSAXWvwtmCGkcSMixpPBHWB9Z4c5WAdKaA6C2HZPG1Xl98rXuLr/Vq8bW+QvG1fgfiax1dvS8WMaH8Uzp6x9lrPgIzs3IzCSaNqia81rvykC8nydbvkSQTJJTnJEzsxlJLopKvncasUldbxiE015dleGLTTCD96M2IMgCLfcfE2WHcMQs7LDu2wphZxyyL23TkcqZBR6aGoMU7KIWYc8wW69pyJAjdYHPVRyJ3KwMwAF9noaeJabIoz6n/EPlKxo5weTxje+hRmtxk9Awh+Qi75+A0gSUdCs6jMeSeBjFBQ3mytbpbVAlnEx73swc7+JtYMaWAtVoKAQpHE7mMCkANP0ZBdH4ejfNmK/QXo6hX6CDV5gT2etLNMGN0volGJa1D0GfC8WVwc3PTuwVNbL4YQ17Rqy5VrMjLyYObNM4jmp8J9K3kHI272ga6EtgdZkBRzokoP1PCw/wiw5RR7YkfBJ3HMz4+/IiGjGdyS7pPJloUTQMyh+hIitOcOO8hqwWPOVzLvLJRXyXa8FaJNqpVoo0VqkQbFbEohg1Uog1UJboi/HYAzwnTsqjrZr1m2pAJWROIGy4Z6OYAE8TX14X2LbNkwWLZKydZocv8sF8iGg7VNig9yS7npiWVQBMODuVluihky+kqFylSWPfJf0dHZgmQV4fg6xWKgJALWCGVeRMOvdOZBsH736LRGyLNe4JdXkU375hcaUOqJsyhG8gvc0Q4rMtDX2e3XF/ku+UzXXczIkYzNasOrMQhZE8gEpk0GND1Gr4Ki8MCttJEELPOkrI8CRWsKHRpFc7B7vbBoThXYMYza1K6sloM8mc6jVIFhXkarYleUEi0UC/Yn2ZJl+sPV0mWw/xKruYEKCwh1FkZmpyFEONVLEmWte1hsbkHL2t6bkP4M2Se05Bcj6jO8axIUtT7dDXlJPx/wHrBogFySwVh+Y+k39PkBroRUXZ7MEluZlRLoQs0mXEpDUsoD06v+Yr3NRlV3VRQOeYpxrSY8CwPCEqaUoJUi6xKiVVHYNWQV7Ktng/2AevLAX3TRgTWXJVWncYMoJ3JqXkwnNkrStBLADPvbiwBDDtQXAKcotsvAccYCgwWpLYQ2bB1UmPl+faRhkmgeczaSjJkZ6pSKUegfX9JBCTbmpZ56cVWex6mWfSU8GnepmXYHpy3z54odgoOUSiMe2VCQu1N8Le/8UYeB30lJyFXLwWuz6QtfpvliJZx+BxEZBPuW5/u2CXqySkbaXrK/cmEjMplmSgTcNeCb7PoyQdUZrGyaE5FNax2xyupZCAn/q1IMmri/yzJjyhMuQNyfj7GSApCTnQuq5OeCmyq8DYz5lafVbIpLrMlWeava56q+pWFyCi0NZNzaZs/+jbaqR5miQiWkytrx33O09xlPDrqBlCvg9atnMfY2jaYrhK1xtGsXrNzmAuW2TFFlh4TBYdjqIhSgiAr96Onw1rwn/8ERY0D0pPk6j2/PfMy/PSCFuT3ajDx6oL8iAEWIskNXC/tTpprENDwAr8z+pU+8wrpoPPMA/ClVJihVUU4CaRGBRfUpSmmXTFaNcWwG1lubpNqWEiGwqziM6nSMjQzQvF5yJ6yji5zyjceBEarEQpCex2frlSrgWZH5TAq/l2ltSydFfGLaneXVbzrDisX/P17zKpZulzE2ajdZ17zrjtthDDz73gZcM3S+bJAVVw88P3nhgBXuW7gSz2p6TujIFICEZ6r6XdVQDxDGj/yiESI7je0SEDG+cQswaN060EeXBX5bssf26fxp2jCAi81wfnr4MvjeXxRIrfkLX1NfL8caRUsaZhAcLYfbvY2gr+XkrI6vFkneGAvrocM7hhT3CPO1hsaCyUI6AladtPLE0qq9oDaK6+uxMkZ7cSlfyfkgDor7IUtpIvajUtLN+RtNW5WlORbxCxTDvtrKOyvNOcX3C0gmMDnQ9jlPvh0Nd0Df7qtjS5gNcqTsF0cxFxE+Yd/Xk2BZ9sdDoa32MuifD8nQnO0yKN265KI4VaXwneWEz0iZVulZb2l13HMxKKfo2RyqxjuIsVKJ2BR660wsqmV0+gquY7Myub6rATeV9dmalOiT2B+Y/kqvHI7/Gjb6dphQwB/rxQsKGyXTgGx+y3aBEs54WzwV3cujeChT74KVJ+gjftrEtI4ymZadfwM+zhLEVjYHoDyepm9H9B0TK6avIxWs7R8u+oWpbTab4+d1d4ea+W5QdtVhxVhxPu894OZiIxUGyjPT46e/nZ8CHklN4d9/c3zo+Nnz8/Iu/W++s7Hs27vhx8ePAiS0Z8PzhfT6YPnixEYRD+kN70/sx+uwzTgTwDGNMwyOqB8vOFGlZHrsZCcaUTGYia1/Bs1tR+DsNZyQ35WYcazSqitv4z68KeFVGeV8Wqjacgz/FraxKsVTpBoU1q6cz8KmCnSbVSoB90NmOcxvLmMZodE3AtYfJB7H/g54eVixPPtQekhWUduMlhN+P/sUKFVPOGCX0ChhykISK2YOHvJ45zGaoZEjQG3iJenk0VpmD7HGXxnmXmlDHwlRN4v8lp81QgA8gv6RNDpBn5kIP+upn90Hvl3sNyr1egfxU07jdEQAllEQ5EXSnBRIPmIJlt8jZ3MikrJR2rZJzIfOYotqRTOxtEUhX5AXzlaUDNZflZTv9PtKIdI/meTgG5SyyqsUJFXlS+vA+01lil4kyc4VYUnCM4DOWEkh4ClSB3u1AIRZy+TSTjVzrj4y/E0IarzmFJQSUDJ3xec1uuVbg/8HaM2IcIiu2wbA97xKi0PojnEgrvoULxnA9Fm8BB+EAEvHhnzharz/NT4ML5WRrueRwb30zqjOcyVLLlzxenvTE9yvu4csmpXDnB3eI4ww2DYGLDq1QHOGdQtBkTUuBApbPiiHHyoz8DBZja9hYs1ZMsAUQKLt+DcQ69Is4Tc3YDeFppG1PUX6pF/0uAcXLmzILqa57cilKGIFwIOPZPoPFxMuf0nq+d4ZTCCzQdHzYNqGfsnJ63OMlVElrsl7vG/SZM8GSfThy3E81H16h+qnGh1lCtoNOewa+cpsUDwve7hrl736kc1tOXSk1zm+fx13RQhZSWRJKQFj1rIe2HmVAvYeiWPagmkoyOcNcI4Q1DO/n/2vrSrjSRZ9Lt/RVn3XI90EVgSq9n8sMFtXmPwATzdHi6XJ6QC1NbCSMKYvs389pcRuUXkUlUS2NOL5/RgVVVk5BYZGRlblkIQrNGjiVs9CjT7dvI237oNvrVNufWaejtZO2/DjZymlX4zaTsDDZ20pW5Tr91L7UM4Hux4ncF+Ar7Vck9YnYhDqY0EA3aKxwYEi0/MnAKFp2ZNEVzTM6Yw5l7zyx7ecwRi6GJOK2TdeWCaKMGtCD5kB2YFcVSTWm6IFrvDKEK9FOfj0i6Vq2tTilKBrXswHE9G7qC/mZbWTdnJd2Gn5PQbcADRI5C4izbDoTlQhq6JxSzcsqGLBQncFMR0+VJz8RDiNvi+sYj6UPG0SW+G+prrq9D6aY6vpl4/uuzk68cpOf36CSB6jPVj0UpkC4t5xKhL/LGI8cMoHfbFSfT3Q5A3qkXTEiUrPzFhhkpPTZwxZI9AoA5qVzCJECkr9Xj8bDS6FQP8e+JpskXT8zVS3oTA6relHPjJeaFf+gH8MIzsUXgiQ12Q5FipaeO5/rTaw90eCDGgyOsPxukqxAS2xSB0hOSPyYVHzc82tpBHOmJU422ndQUaxLQ5AlpptlpC2ofwQAh9TIfpxWAohKzOBSonBRyGwc/CmRZtwxhd2MPunQOyUaoViodps30AKkvaIsA4l/x0lfZNJGNbXqHyUYfdJ2jNyY6CxNwGPLq+OZJRwyRWnw3FGEdC3vEietNPsaPN4d3c19B13j/JUiPQ453+5BiHChwHA+I0Q6zM0kGZhAE2tedrZG+gwPDFw0pXNQVO+63h3bWgEs3gwRWhVEpemsJvmp9S83HVeFi5VoRgRJe0JBUwjem8nmhjDVdArVI5HdNt5DVqW95TXqcH4PWCWNzihktDJdTCEiKqtSgGoBta2ieweFmMOt2IElxGwSaeAGMEGC+ISUc3MgkyMAsuAqQ2axllsKHJfboRJMxKwIxJ6/LJHPHM7cj3mXVWEbI7EFvP67trwR5NpfxuaSfQr2gzfMfKsIU66EPJYuriJnI/BpEgMEGFGeWfxOzDD1ti92tPgmxGjMp/4f9KFiDmkBAy1kPl9ssUfjmwL70fDnrX1DXntd2s5LfvTjp/CicdQKy5l4tJOpHpr4GCmmGEC+qvIa+RsZBmAbbrO8bAqvKoLe5PEgCdxLPEL57pYxKobRpvEx/NH9rvpL68+O39To4GvdQ7TgzTf950xLtMj5QMkqlMWC7opZJBvVn+KiH01nMlivSr+bDUJziGLn6tY+ji4xxDj5qfYePkB0zxH2bw0rwIUGgKGiWRo9qE57GMSf3jeaH8GdSwgQmZUiGbh6monqwgnkk1ZhOgnV53ll9JthYtr/yfToUb6PCUytw8THG1bm7J6Qn3MVS9E6B9VMLNUf/mlvATTX1K765BiwESYOqIgCDmpnMCAkRa6WRZqpivKsgjUxbNXUkhzbQ8zcaFCavKKrC4LwSljjKg813IPSVZvuQfUJfFu0PF6twJ5Cq0TCVYxtCEZbWohiijVWFMgTbHMLnKiqwpctQWGaDlYt2rFmy8VYdkU5DUa/gwxTQc2RMGM549EQDBtCTvm58Gz2/Gne7oeWvQ6w36WlOC787ku5CS5KLbHAv+8Prqpv9pVG7hPzQCtJtCsZqcNTAZlOFtB95VEzg0ySJzXXRgWRNf1pOu+Gdmxh6KAceMhjzpnGpgnphsNIZ7EsCrWp5LPnT645Wt4bB5J6rUW5bbAnHAnLApYwmWkPaYu6yweggplQOB6C2DE1XpXgR6oJQNEochotgkjXAfGOlZgi9n6l1ols46/c7YLPfx8M50SG4omGPg9VVTHLzaKTDi7l0ZKLTqjmS9YvSQrea4dZWUz87s6NBmzB0dH55tvX+/9/Hsw+7W2cGP/AR8z6fjn0gk4p/1pLG4JH7QQWdoz27GFyti+E7+eSrK/DPZhHDqRvIyWUpW1ePCinhctI818bhgHhsL4nFeP9ZfQNmGeKzThoWrbCwuQKWZHxUarTvyYz1lwcb5zUVZ/KRrRbyywa8t8rNhf/fOBB3Zxw6JLB8Pz+RqE78YgSncZ/5aRGxy6OXPdY1GvaDT0FKoW4pOtsayvKFwYMrlVvIsWVpYrDeEhCA2ucXFxoslSMAn8c8kdVsHVfW3GhHsUMTUoOtoOJUszTdqFJts7NLi4vySKC/aNKsasr6e1GsVfNeAl1hwjZRTvbav7p/wf/VAwlIWXak3gNjqgn7gqVFD2muoR9kASW0LlLwEEp9LKcyUUykuRaYJmJIC/D5FkSnC4Gw5N7RGMWwngpnDIm0Z+dMm7dDzFykCjOI30ebNzc1kaS0IIUgBIES/5yP4sbuRCoAx6QrqjcwasA2snqINCdcsOKSpeSW35nojv+ppWuhvhoohEuYp3jTOwZkBj0HiqZoQKgVGZ2QAbY3jW77a1mH1sI1dFROrOrAjlrHpp5Wc/Zq1kjax1/xCm0iY9uCGJoVS0pIAhxxooihj4xJEbDf1Jcs/jIAjDvcNyjoGePoWzMPttiPMiK96Ytay14+u+USgdpYRNm7c6Vv99z2tQ+084X2zxetF2M1kIbtmWEiEtDrIjrHorLUSxFslKE/DA3MCEWAeebh5NQ9cHWSIZRPFcgUePKaBdeCYalAZl0xwYxBrPfnNkjxfCYhjdnYtxLc0+on6H+tnlO9kzKXHKQRrVox6LaO8ZN5y7QsGLnpcrzXmM0sAZ1dsgMIGGAGjHM4DNN4qrCXX3wNoTCp+vIUIiyy61GDc4NMm+WKHTxZ1y9hERXKzBihDjIp44IsQOmtAO8hUxAsgDrG5yG2SLTnxUROJdSmQUlqNci4cIlFdCBSQ5gKrt3IrD69S3dhTMSbQs5cIvaox4WElT/yXwnAQvy8NiWNAxQGGQ4w6PnMk8nQTOi21UzigpuycpN6dDXSUmz0uIYsd3mD+ZkgRqWLOaC6Wbvo5hcPir93O+Zk9ov/jbHvnzdaHveOz1wfv3h/uHB3tHuyTBCe9dHw1aEfK7W0d72wTYDwjKi1AfWl+ZYF8k6qgVx00o2l9nqqit6cat0Jeiw6J3l7eZbVZTJZowg8fSbFh85af2PDt5a+d68Drq7QplatSrWHetzsYXN0c3vnfOpf9wVDMwojjC0zR3BYcSGXKTjkjI0xmXk3IHDkrP1DkaNyWP1k5oq0DFfPggnxEnybIwn/R6aftEt85R+P2j+kdtP7g/BfwCfsknmwl/PYfgTIA7DQ/Jq3o0lYzQSUXlYdJtkaskXb65eCirMuA2ML5BSaaSs9vIK/uGlPRwnXmpd3+5yboxmEeErVEUK/0N7AuErSggv5bVV0hE1pYuKxKvpiuhm/YUlZ9NeyHojSMzGU6JgNTpVWSYwCgGA8vx3EcZLrDKHDYVCuebhhslZwxQUMETJPqZnBcknL65Rp9duV301Q5aJeDsXyv64fXFTJWuiOjaEeqhQas4m+qyKoNM9yWcxblgrKTI56OCpb1mWhagBNYFRxf7QqP4vMBcjE1EeEY/bJocbs7ixfIosRGCj8JV2Q5/p1vG8ksf+OlboTPyOSCiANvhZi8FK1vBvg33WmxM+lwaPUwknWPLsmJRQKJhdwODLDUOooPJ6ecyffU2CKT/4c4xaTWocbAzDU/NzvdM3U4oMqj5vhmpLcIvWuqf3fF9tooGxxV7CXug/Kn3NuqTuf1N7kpySe9FxEtvqr56UZgezr40Y6sXIrQwZ3hUBAmAvfAq/wyxQFUmCoVVwyCiuUGZbGFunmUjt8imNtVVTiE125wfHOA9/RYo/gTL4LCWUlKMSXKoAHEFXKI2tCpOKBr0IbCOXDX9xqK1Z4McCOSB8hXNxcX6fA01AhHLMuu2yvNwd3jSSbVienYNiXplAA+ptAqSkKTE5Ftqsf4/BTg6FUFKSaryUVX/D7rDdopuRpjhDranmZp8Jse7KnQR3melQbd5Wqfz2yFdmVZNuLJ/54iHuAtDqSQf/3L70VCawLm5FTrkEEMGPHDAIpjhDdjb3b3d4/eiqOF92X/4OzN3oejt27D1eKS2UODSwpZX0d5JMSWFckOGl1KCFNoAbEqnUXk1xQsBWC0r/ixn34ZiwOPZd+ErXeU9l+hYMdTFCzXEqr/kWuHbwr8uKiwiy/BfhjKJFKVbSTbZJyWym8OZXO9RfnMIRiPHo4+7r+WFAFn+FzwNx/29iR4BfZxpzXrG8kSZxWwBPuYXJYMwtzo5ryJna9VeV8rlYye1vJ1NZnMsCxZH+ljiAOGR+n4cGfr3dnO/rZ/ZqBTtekeEh40AvdkLDL6tdNvW9ZOiqu64bPiyM43LR5Rn1vD3rKG4+DHELHlLYPIWFSKqeAoaSopMnPsvzntOUPQ6asRsLp7IU1+CqiMqH1TNRgXNTsvKLs67o/yqy1CZphmLM6cQCoU0iMH9VWY444JpB0VTx4Pi9RSSqc7LRHVrUAtnt202GrJdmTuDOcEJTd7CYP3kpjzkDqKOQchDSmHT+Ek943CcBkY0WZXYjbfoOGCTfoiDysdmGPzPWjrUL09bN5GOqzFGKlQsuuVqna3HW7nYHKDNcT5LFIZl7XliZPrcOxBTZ1H//d+jbVTqbge0NCg3waM+/Nmu5sO5xugjixB2C5IH3j/N5zHcWYURMiJQ30q47/VRBu/pJcJMS+N6qI0AoHZYXFxfjH5DQxBo4Z5j2a8Jf6ZiBRKWw162aecEwKQNFA0UjCRwN9VtCsRX51ZQdT6uT2gwgS0TPyZSZQ6GQwBvzERAW3MDdCM1OmXe92m2VmrKxMg/4mWiYYx+Yii/BWjZMQpQMDEvKTRZ82X5TvxGTMwZM4Exqj0KofZ+/x+6/B4d2vPwNQDMETg2UgaAQAr4kBS6xCAFK43wB3B+/hq7+D1jzJBkPdNCBE7R2B4CnxD5X6oT1b0iHRof2dn+2x79/VxpD87h4f7B6C1qWdgPzw8OASYEILtreMtCxEakXc7BEVwVD68sQCL4YklOv/IULzaOTo+O3ov+hsZCgTgeF6EOuRbGWLj82Z373jnMFrh2w9v3rzb2j872N/7GBn+w72dKB39jIgXMpqojQqxEdnd3zqMfTze+fk40u4P+z/uH/y0H2mytqZII0hsWQ9bmUwYv4dYcK/5KT2GqwnZLRfEVWsMH9WmvtsfzzeoMYvp9yW7Ff8oj7e+68fT90wCn2SRT6LIiviHGwGk3flZUgdb9ouVlcaLxvzKQvI/2mkDXZLwl6fagDaf9IkRmIt48Nm9dwIGqCz+ZmxDY2NwwtEWf481JnU5SB8EeGl0NDuIAEv+RxK0Zw4Bzzc0iIiSjhEEim3gX+jiiuj2+KSMuBLluyGGprG4eBrooASTNd5b1s1azftCyCBKY8TyGN84LjqXUc375WDQPpMneDRcn3Wbv96JbbrTStnr1lWzI0b/4qbfYlI3KS/qIE9UmFVopbkaf5KvpCqgR/vkYMAWKBT4m3yHZoHuR/yzRo0POAJKmjoaZ1kgWKe0npsbF8wRk+rUIZig0788U74yvAT5eKZiI0Jl2QGKfnHe3g6b186ry19BbezXLMRLMNG5BoBJzMNimMbySJnYlSLbEerM7dm5tH3wlz1I4uK8NHGdvM3yfXCg5BUtDny4553+6OzKKX/VFOfiAF58H2g2vg+0XOK56ly483XeHbQ+nYnRHLpfeuC/bMnb7dUZfg+WwUOy4go1bmCJVxT60h0MPjXVYHn1B1tmllj8MyziYOO150It7BzAiBe4RQgHMoHQh/adaNJ4mKZES1hfkrsf0jQenwBgNPd2Z+v92dHuP3aIz5pB0o4gKUMKJxfTtpCDtoVcCg6oLrLz7tkkqF7tZeDqnrXTUSvg3xB5f96Nf2gNbvrjAqP0butnISMdHxHvWr24rgPFQ32iXXIwcGdw+1r6NrGZTa8l/5++wq5iwowaO2N4G1j7yN66HXextANIxLk70BEppAQ+IOGmLk8RfCn1luZ5J1CdeCkdAcxrdwB+TYeDMl8QlSKQ7UKQiqRz4WAm86uFea34m3I74BGgr4AZDpUiOgXz2WtiGdK6ML2FMQ2ThWYaFfPavTOz2f9UvnCycJQv8NheSWbh52YCURwvhFBbM9oh7JqYND/8yHXVM7oEVGUwBQdIi+LtqZ1i54bft1tHb8/+sbf7qjyq4k1f6lo5p7W4MYoGs63pfxTos4TsZGs+/q+EWmqhlQSDE+lYJ7X1COCJoK6iSrTsY/WOUhPEFc48bGvD+eqa7rS7reei6Nm9tAo8HZeZ+GaV4kxsqyZcisMjRsVVm6898U1WMxv2NOLgoF+gzHgwbnbDn6wCfjaEj71FjbeVLPlwRITR+9DUSmEHri4BCgI+qvG4bED8c0bKADiXldBL9aXzclVImwBoBJ1ZDqDq1H3lspctRjiTPiU5pGnNQaSPYvrPzu/AFiZOnYbvUFo4MU/Sw/jcx3B0NRiO3x29mgCJOlLi+XGtCLyBZPcAN3EDU/wTT81qzGAL9HkWM8d4S44UMQvN2FELLC9KRq4JmZImLjBYctaobNcbMUdXuXHarjbRQ+bso7mLOjKBy7NjM5ca6g2mDp/Tum8LQTUPtBpiug/V1siqzZz5i9XkG+UjHML5oqZAPRMi6Q76YsscSwEbKLR1M5QPTN3E5X//UED8RFrNfmDpYSAhoGU8ngQLQiMM17eHEQvBzgH0WMCiWTq9Dl/5QLr6kDrLOcC73f2zvYODH7fE6WAbOQ/hMuVCpSogDtAGQNw81i8PsPTTrTpE6pMw/aYOtbLra9x9RyqtSONmkpDg/m7r+PVbPg9noijYP6BRJzgxM3agZ5P6qQ8egT5l2wY5K25Cy+zZjajHKMlsbqLqlHMKMqEwR+ZkSkw/fMoNBMVErD0a0pAw9VfAXkkI0i00Npm+g0tHCAzHioHWOaz8aAbu1HydmQl9h8PKKdOkxhw0ENiMneqiDUQknTfmKlWvbMeGrtY05Nmz5K8FgWO4rhZSZY1tYNF1hAxALr1ZxGAtgIq/6Y85S5FuoZqcmLOTo6vxaDehrJFYPQniDbJQuD8N8aFwPGSKcwcKns0dbC5TRYpl05tEXlF8Yl88k/xQLINNxbXFXM3OMrYhLcGW9ZjWrW+EGYYO4lRwIXss5yJUnu10uyrrSdlxnTgziki9KZAbo8kORbY68nMwZG6UwzWPbwkIsmfoXYcq62a9DVUzY7vPbZh2zgAXKLB5cULUCWzwuKMftOSl8FVJHeqXkLlosDQn6FnTKApht9ngZyrEhyDkBmv0uPbDNbVhOY4AYphlMTGcJ7Oz16c0EEW9vgZhukdH8qV4nDVPq9RvIOgfIBvntbhIw3B9+A3D14/RMKSyGa9x9y41eR5ZNIKb8pN74qDBiMwePJT7tCanKpdiCIFXsXmWyRLSnyFDJxtJviVGl7YZ4OaC2JEVO96lXJqaNTgoDWrLgW76iYA/DQGwnmtNivpcZcXlrm9xqFnStXPOPWUF0SFAhl4JkBaUe2Zk0lO7RlQVoXWiP8l9kAGMhzRNQmLG1oYe58zjerFpDOxudH+7D29ItM71rMMAyA3OYrCbke+KJpiVIN82zAyqFejZCY5KiqPJPQQdoFjQL/2+mQRMhbPJIosF5gjDBbykNwFPbDocGzwAnOtK2N7oxLNRm9KGijRWpsKQM6V2SuKzqbZnVuurI+mt8+7gcCckxARrLyQAGfmasKPACYMzIuLWKsUCmAiraqK71owzSZEtWw6XOCvwbdzg5fszbQnjXwY+uMduhL4HNGFck4fhGt5M5/ksTzOP9+GxmfW1gwVP5P/7++2l0t949h8TCxMJI0AXukgoWahfxFm3aKciXZJVnx0dbx0ajwDbq+xC2wf7O+6h31HMkBmeoHt82h7UP2/KAqkgMsuENoMusMnAVoAiq2UvqPdCoDW2W1BppAjnnmo1FOToebvkH4TRm5GnXNxFW1iEnFg2y9TdxUQ02mYtrFlEBWW2gMTmHSTtbsi9QLjDyhqHsmo5ct6zMI6rS2an6XzYTj/VsgRv1nri+ZxoYU1vHBbH+hSbRrjtupinLzeVeYuIoREtWcQULNQBJszrlQstigW8KRtZA+mOAj+IbyYLtRdLFfeQMc00xbZuRy2c01J3dFh52kzLEV0tOFeQROsjmjTtwRayTcJlZXdy/ZJRrONIWoqvOuSYUS9TipCWbngo6hSSfSKqX09tAKM+M0Nau75BBss9LH0jpvVojKso83LOfVb3wUeSqhIp6Qcc6x6yMmz76DEYdZdMGphSPi0uoU6y0QYPzsSm6Q4V0wgVWlK1MF05tPNow3SfMx9kOVK9xFeU/t1cBSHyyyWjYLPvPQE7OluPN1cZq8c74lAGlb2MuAl2tcia+ysdnLST4h/noITRXaY3gZPSsJsGD0ruqchaxbWtmllUIDgjzwZfTAUWteY9/CCVZW38I2nMwk7sk52mHGHViUX3XEj4Hqt8Jay1nQ+6/GwtwdI0LCqc7IMjKU/jhhGU2oyE8kjt/Ld/CNvXiwlR+eb2yHEq4jASqTeg2M0yF4RrLKgcKLbJok8jwz/lQSJ0Qvf12jGo2Fr2Uzc/QHQ4reRKXiF5h86FLxV+V+1+l1C+hYRydXNxkSuiFJAtvE5Mb1+reFqAiWWHaU+HDxAPHoeDBPlHiHt85xrfuca35xrdnkwMPbJu/jyQFSLYuA9ZMFpKKr5MVIMXY8kaxO7kPJOh9Sr08nSOx1g7YZbF0Xix3E5cZnFMXkx3MMJ0sg6SCPBQSGwkJDdo2/eXYkCa5GaSAmqKDH2JE6QcSHOUjtLxj2l6zcKngOafYmj6b78lT23YgecLyUbSRtNlpjbxow1MUMGGG4bEkwJCRNiZujcxlkaDHN0D0V+BePdIPJJc9hhmsc7Dl1Rs/Kz8xfVSJnBfgb3kIyQYFaQR2Tre0Qoos+4/HH2UX2jMlYrlGJFwD4GyZi93cmLnczJMhjZHxVHWPI7k55iLUE8g8G6YjiP58Rx6s2ONRfLSo3FjmWaHljyD95lEEnzZ7LiSZulZbzL6jxG6txk54TtPefjOpCgJOpObwR5CJ51KmRNZDoVKhazTINMUyDb9sUl97I7Z9D2CVatWV51GiGGY/0axKwpoFJlMD7DkzgNLdk2WNk96kSQ8z3ZGjm2WU7u+6GFsBDDOupm00VtP33iwnmAMiHnedMzLoNrYeXe2t/P3nT0JiOk2nm5kJNwAONb1FecNtB1edVUTavZhM3mBJmNtXFYfzfNmEs6o9PgbhjPeQBbkhhE2ZS/8CxVHNKc4zdZSpqGzI5W/ZUR2/Z7aTfQrNbV2CwhmSCHJSlz6IclN6jL6WYLarySiS/kYGK5P04kYIpnRd/vwNCR1EltNK6CpR2gJtxqdheRf/yqXac05dttK8jxX6UQztPBMvKbTNnGFTcPiJG4gjTegOo+LB3rL4XjWBhwqMp5LgfBY6xdLy/6Xvg/Py9Pj9stFZZqi80HUUYonyE1bFUAZEg42KlEwxffwX0LBOi+K/mmER52qR/5Yi55N/E0/vpXQncSJ949n5Ge7T5SPVX1e+BPkFXHeC3DLI6v5V8VEOqMa5Wto0stq8rnZXcsUGOBRCmcBDinTExqI0CVIiPLldFwzlHE8a+cNycumXzpltumezOnN005rP3btdMxz3ur22zO+EIONbeppEU1E9iYSOqOHErLbBIirk5xU/F1A7imDbtsI4FQeD0ro5ItWLIRHyR4VXLVfKPTbOTDUIr7YNOPAPL3iMgpVn39RBGzF0Wo91bthhq8FLc8vxPxDghnGK2bmhbozlfDdzQB5s4yVuGa06NVQN/wWrJt9ODjCpEWOsSyctdw9dgbNMxkVl/U8z43TL2N1cay87NR8uYJ8hHI85BdDHHOizLCpTrQLzje8o0l+WnE+QUbstD/WR+GlStEZ0m3tCNSY1GKagjZ5xpSlMVHx9MUbC5MV//eRpWn6YBRosuRmjBLQcE/fzPkem8VqpKUDdU+MIjLp97H+ANF7luPC+TmYlEgeXWZ0z5a4l4kxe+3v/CwkH2/xx2y0GGGgb8WLnzFnZGoLPCDMiiET8rRY2OvryQq/6gwpSuyKTbzffbYeMIpMRaB8zHktNY/HKROBKryUVbieWRhWV2bxRiZ/5bDzIecaNfa/bTBguJY1MHRSF/3UtyRZLIwUQHmyc4yJqzPqntmAS2Vn9eN/iiduZC+6w7hrj+YwYndTFetUFjqy5mSO+EzOFSmp0spHbgMhi7oe95uMyXlkFbqCHuVDzAkkvfTTl7GYX80J1l00liPKHvnWXp63K3BcdZiax/VUUIVCAnkpLt0yj8EKBR3iEQzQc85+H+fzgYRxvGx0aKcdnkAcMW/h/ZOJ96QTM8GngS3JfAzdKD/NfH2tufLbpLYvHNhcKWDi/W5/691O4e2uOJLiS92Wjax0EHkLLfRArMb3dfvI6/Zzs8u3/YmXMyfr9YTNc0SylbVyyNZVE7OKbo3LZHFXaAK/qGShMdbWJuU5olwlkPYD0LnhLr9XnoJd9+WFiTnH64N373b2jx/MPIJ4ivMPVjzCQtTR+DsX+fNzETXVxRiJBv7OSx6bl4SX+tvXh68fzC98JMWZhS0b4RSuhoLT90zSCCaLyY2diyyv+4x61jcmq4hJxvSUVlwpRk+FQcVOTJ0+oSp10hn3kfgzrofOOQkXnYtCl6SGr+TI9yuhWZF42lqe9gsWNc/qhSnSpZFtfSPwzVhZKo9qM4obhyprhdeaa9EKpXb6Cu2JGd6s46F5mTFe5ho3FTXFr54OdZHfDH5uvCVycg8wrd3LoBnYdYhfzUUKN3pFcPHwv9UJvD7hch9blDl9q866w+O5LsOg5wODk2+lAFugox+MYInXZDyQi7VINT94s26mj3oGy7ifmHnk9sr6SLstzfBrZzcSBvYXxzOy2e1c9lnABOFpGQsK25aPXiZ1s+nqa/hfOCY/y1mfXAIdMJJk+n5PEAgS836mX4N+0H6yPv/bfWbY3CRixoNptQiNhsMscqgia1sKVXPveSFHd5HwDZURNI7jwOSC1ZRCVcFinm20YDnPKJpdznicT1Vo4u7RkhP2kBZ1OulIldOZQaYygdw/Kb4sCe1tFnWkN+mUmawb8uU5+DHLiUeuAt+pS17SPW28Q2GHKhMMYD216fXb5GLwp3H3HylQhqGI8SgLzCqes6CYeikL0B4ts6DsUSYLKixXPmp0iZZPrVeuca4Li/Ok5cVd7+zFvEHHu5jb/VE63u60QAhtDu8U7rZ5QR0O4e2ejgqyIOweqMen4/hFSuraCbmG6RJGD20brwI+5uZqlOxDBiF6fpB5WNzFw29mscNdJfNgvTHuuVM4CSEis0ZyjHKVjGmfH8KbK77FZLIMaSwkh92TA924dw0kGffJNtUrSEzqTijSpHUnnZ81facjyLK7WwxwW71ETb/t2RA5GuJI6RSlvvBdQxIA7rXR39UdN/SzdGpV3/FhLXCf0AZpzpp/Zw6PWdMobe9Ct0UFIrQDSaWLZYlQaWuC+cz0Rc08uV0525E/cB/I108hPnkC8Zz04Sx5eDCLPVtLpCwP5SyUqy13du+fFMgQnXfjGMuD5ZUNxp9+3WhTvgzgV2AlZKwr/BmNsMkLadM3XYejpOz1817kAFhoFp2PLHxAXr7Ovu/t7P9w/FZdDyr2ORf53u7xzuHWHn5bXHI/mnLhMjNJXa+VUH1uUw22+Zrz6ZWtqe620N5aKyPHgy2cMVfW01GLDZolF/Ri82dDfWssrgRK2tS/G0mk6EwSqc9vJ/Fpg9Y0nM9E1thIFtyvVLDeSJbcoSMC9Uay7PaUC9KC7tymEQFaDGLNLU/kT/G57n5m2mbRuCWXupjWb8MbGKY+k66JObpMfzK5ChNG0AFQTuiBolo9e9EcATcgKtqNTdxfvFzWPCGKlw5luozVBTKkfOVs1ZOljCigpQvcnyL/BvJTT5ed+pukeX2EBK/5qV3t6SCYE/qR8j0/MNuzn3dzonRhUyQkZmmdp8oiViiHWDiFdTj19jQZ1ClmmgnM8XgJJ0L9htmMHymXcbFMxix7MRt7P31xIGFayIT9kCxw4XuQbFamtUfKiE+G/D6kNv2mqaPsinbTR/1OshKhhuqbpNedKAnVJCmoigzNBOmnMnM1Oamn7p/E0k5NNL0P6IEztXpKC6Sack9PAQu5IIgTgcwkUJAg5Zo2XtaqYUu8NHVWqoGyC9VE/LeCf6NiYqzkYjWpL2HpiYuKYvMN+f+Jyy7IauH/4e52B7fBsiuyUGbFeYXrjRX1Z+LiUCeWFAfSSYuTslB/rbEwDQYsjH/gvogsDE8E/3/y/HkyOP/l+cVNt/scWMlzgH8u+ckvoyelG8HGxSrptMaltSefm0OJ7wgV7McCajsdteDWU7EYR7hwkMEMb1qCHstSD4/cqZpgmAFGrZnfzRG876Y9yHoDcglzsxxfdaQeW6FAjZF5WrMwFrMAsQ8+hKjPQogHCgGtgI/wL3lvm6Xu4aK7L0IIAeNs5LdP7PhoDtGWGfXaBDvqbGH3ZFhzB7R911ejCSjFtI5abLQwl9qgTfRF+FoXAx2p+rmWW8jUoPqFv/022/2HtVqZYFCjfn5z4d9VD7fE07E0gpO6EZfwYQF6gnc9sxz1xNDzD1EL5qliW4Gr2HdfqlnpwlNlrXg5oJyzdmc0nriQou8JiqkiOD8TlYP2TVxKjUibjIja1WDvd61riL6MA8Gzj8ArCBRdXNLGvWDLTuDXaUCOISCAYybBStCqvlw5dZoB1vwRGNRhh7+1aRuJs+uJeZqZASK6pa7YOZCb1hHBqXgkAOUQiIpbIB6laYz+EBZ4kpSj0vSkBVl3TumDlaNJJeedM3FiSYejtAxVQeaWPl1Lw5RE3ZKjF7z/TaxHWNbPrM4cnzfhMnfzCiDX182Le2chmkOLyfU2ku4NfkNR5LKZM6WEJd5/bnY7UpVSX3KEcTJEbB6xHLANK+bLF/R0Q5EbxkDjhs3nTZbAKnPGTUXMW9+8haFbCTRg1rx2WNNl2kciGZUl39bMtpqcd8WPGxtHYq1nmhvD9i7NgqG866ggnjG2I6AGzsVRp2f2QXK/Nar31HZZX0OY2O0GUImEgAgGPYKmkSfwBYZN1Yz/zJiunagY9fopRFHXvQtNpSEv6euLj6C4eKRV2Q0DV0rfrBT3dnbvYCbGc9zp33j3JFs8p4ETKVlwtpew+czMyMUXnGX0NUTeybYh505xPhl089OTt0ZcEUZjajbVQxpIuFWIOLhqAEffUIucNv/wyewvcKREQDo7GbvcCcCeyivvibrCmXeZDsxFIyW0LoyXROMQRcDbk+yTJ/K3XM92VLm+tgACSbgUBW5DOYNYXyo4TIDMDJKd7omGqD3JEPGNN3t41Ia7odPdKYtAhFCUdWzajkP/lh/WezFXy5OMgJQr8seBssraNKySscJT95Yl4smgtl3khfWF+fgYUrGV8MOEbEx9q1M09a+ccgUZrQ/8Haeo70VWfS+y6lt+MU19y1n1LWfVt7L81cfTRWs3/qwKqz7TtVZhIiOshTbN+DrsZy1CKuXzDi+uFS6St3dWk4Aja2AQ9AnTqDK4amHCwSMbR2Bkiek/Ou7V6NqOHKT00EzZkXZWR9qyI7VqbKanbe157ri7QkatEmvkeTfaylfZg7pnW0pkKZCgdMhGQJDKWwN7wTUgdSBdTr+1DIG04NqSeNsPwPsq1mAxRxloaYdclDv72yrxpSpp3IoG1+MzKU3blZT2WUZ9pVS3FwPbEyY/7oGl5uY6et7bpEeuSQ57kSMc92svcILjo+UeH/3DI+lda3B9Z6OGMJBZDJNJnBQ55NMxsUYGXiZnKOwBIwfwX/wo4gwJeotqW5r1FcWOwCjMYEUkOrvipu6fQbnd1Xj0mt1uOlQnWTEe4EidXluNrbq9r98AxgLExy7168Hrnn1tVEuChEUZcUZUv3vi92+/kQ9wtrOfnj2TtZ70T2Fzl797nl7on6LvfTH611rnUk0+8YZ+1ibf65NPp/bo9Yt4/YkcWJUk8Yu0nwP4GdHCyFn+BbMG6G8m9JZyXjZ4qtpfcOe1j/hTDikVZH8JX6qVXcXnXLQBZ5bEDogdnF/MYRvyWP+iH35heqMnbuHP3qLqXQ/T0cguLLWJt6nmjJ998ZzcIr+/cPUGPzPjfrQWuJjGjQ9mPgrqUOfyFJkqegaqRC66jsncc8CYZkI0qhVA3DUlKOQX97ph2axIJjZXtajVkN2WGtVKZi48dWjNPgO3TteKVqvUPtkCl9uuRM5XoB3+8d+J1ZQFn4ZCKMWQz27k6yXWMsM4mboWxlTmh4vl5ICpoi4w0QGmKvOJBlcvkuKj155q9JDoYuNnz+0TjB4Uyh6/e9dfvCtTsBjzfuYxgo5UVA6ixEeFmJtOt42w2FJiTJP7gzaZiQ9z3G6mQnYogDGRzXlGSglN7YROCfOJwmuLpANLDJQoFYtd2D4RU56OuEUgwybJHkVEIXwnygaoyXgwh6Vv2RouugKNUcn1qZ/6AneJmRnbmtNkgza+Tz2TzGafdb+lf5ithfQ5JuLDDANLaNqX1ec1UGbpnZkxL1ZtbbIh8JIL36QnSvVFDBlKLrdMRHlNSqrw0xcouX12Q9KgqY/tP0yfB6RDBtho2/msknFBG0+Cplj4d3Y2Q4QNiFpcOlXjSmiXbMG24pM6dy+FF/ajbdzs7OnaBG2x4TW9jKrAZU8vhFNKg5HvveiMU+KfkU8o9p7GKKFMiBxD2LRMix5f5tMq+VKR7vgx4reV6jd9ouGkg9tHle00w3kfWE2bG/wuEX/YnOEPqc3E3iFwGZ68lqNfcw1reHS2ajN6gGk1+4bf82IRkw34i0pmSflp62aoTkeqgNjfiJGq5ixFKalK403NZdby9TJ53emb1wtWmjV1cG5KkdTnjcaSIpmnKxEbWDacAExElEowAn1tIgudHAwVi2SGJXEHRaBilVFONzMj27pOuiOOUBrzhsGdad+zegODTY8C56Bas6Lwy3W6IacohE2CeduY802RipsGI1BZOGusBXVJ/XDn/dn82ZJT1u8vBLqEexrA+A+Bsl4L4yyMol4/E0TnIjHOBozkE7KY6ALKJO8ogQdJPDRtEeqhaJeKIQ0XXg4XXoj4/RLfkb82I/qzshcn/iH7aIctqNpVVgmGEsj6eATBI/GnqZunljc99t4/KYQ1wt3C1WSeLeW4zCbzVSN0FGGLk7ZOcsqHtW++EmUmkzdHct0HNKherybLle/8ujC/lpoCNdrcLAW4z7uY5DVicqNCJzHb4L0xZ+xgVimMoa0xtAth4JoOpBsiWiMrJv0IqAFMkDO6AVHYTRh4+oaeFJURJyJCiPeDYTsdnpDSp1YafVo4+NIatuD+DIGB9Qb3hZlkUf1/gVkfnOlz9+hmV7ZdaQLhvCFOJerfc/mC+WM2+5/WnhTQKUJBMZiNxWVrKc9WpOki9YIFzk0lEE9BpxoaKTde/LWuQeVzpusAraDAxAI+O6OWDWYo84IrxXSlntXz4BJp86IsPdA4bY3PzI3XfF2fd5utT/ruzoXai/mlxsLCwvJajj0a7m9BCaZKMUiXW74uyOdnOmuPZ6R+mhVuxjIi7u5vHX6MZ7S1mF8QzDIHkP2mDgSRj/PBNsVadLzz83FQ4JtvRCz3ylwQUCc+ZGRsO/i45I8koRVyjTfNZxZxr0AXhvagn8ZXkusxmuN5YzCivHuTcqOb781h/DjYMsp0wiGXpOZga2dia3Ns55mNUxykmuOoUlkrbMb3h5A5lATm1c0SKhOXy5co/4IlopBnv2eRPTo+ONzRzhhgUcZb9gCfucfPMkW3cMALgbbKhGM63dE5VYs02G/v1vHu67Pjwx2x1UN7460ranmZIuqGxBIE+kciO3NnC/i0Eg3O11jSQKlBP18LyXFeCgd1P3fNZUoYPmr2j3CQ7Yf9H/cPftp3dfi8oG8p9PcmV1zPk/HYyskHb3PwbHHQlYd1KT3WqOc1MpkQyWaSZQwbMTI6mQPXGykIrxM56jJio9WV0aGlDXBnORKcHi6CT5qoQHL0U4OTrwu0PbCVA5OCHWq2Ht8CivOegGNUdspuvBhe3h5PerQRGrNJGZrDILIYWoiluT4gk/l3BgLUQhlaC3dn++P+1H3xzwfeeU46PniHNPnaPaIUHzPnEGm25Ezh2tsFVegM4ZZFXNrufYZsEjhIW3+3FQvC074yxDFHWcxMfN9KVmheuLw2XSCOjNJdrzRGp7R4Gf1Nq7NjrjhUIu22mAbcoUjjRmk15NxhhKIq5/nk5LjZVBxdPPVPzfJG4R3gCYKtSyheyNMFOrq5UCl66jwvHEGvuZBNXMU+SjFbbrX+VxDaSV4t9k3tqCStVkziCiJnLCxYheUKwSpCGdgc12Y/CVssrIqktQtNKc1sFwgS2MgkhhCt+CnufB9nmuUupAMiie5CniI01104sCE8aG7GO1q1urEGPi9FSu9pBMs+gPWIjgyoNrGF8Vtzmfi+HPmubGECIjDnxKXNT/p6QrN70P/q5L8G+W+e/LdA/lsk/9UgljjDNyynGbRSWpFEvoT/LeN/K/jfC/wP1OT4/7r6f0P9fx7+H2/R+aQjE/tPtnY5VJNWSgVqwaQfoiv1FUSygv16gX2E3izKzizIvszL7kCvFuQ4LYaq2949OkaKPxNrDmJr6gFWQqWdQGRnOb6GGsiyK1GU7QjK2JIPI7MRc0VQ0R6HkJGtrGAYq85mFGfBUnLK8PcsUBNlijFkyku44HCG5kULoioh4+dm90bG82PKE5WY0Yt6iHLC2YRnSzG6kd82JG4QaQmqZ9S3Y5J4DKJ0kXg3M1tlq/Q0NDM6GDgwoxoDihNUgJqoX6HKogKKdTVSUyI9QNVMZLuAyq/EoY4J+BaimIvoZA6iyj1Uuf+67qEs/Y2KHZd5b8KQKg2O7ZBZNg48T36DGUT1D+2ESoPc4fcX+nChfww+p8OL7uBWq1keGGNr3b14jC1IsSj3cvdBdENz3USxCVfWARJ8YUFOSa4CemrrEptc2WYQL0adOVD1CRvhuuiZH8aND20CUGIzkAvJIHNTECVmOLn07rsE2uwDaL9V1VCXE9fp4T44vrqeL2bKKNINpDaL8QtNyyQaNIvfT5lhgLtMrvkmvQsw6SGiGYmQxlf5XrJcm6SKj9wR4ajuSWo5S6D0zCfPQ5qyjJuHNy82jbdxj3QJlB8l4aU+DYaHXH913qt+bOiAKvLZNscUNr2aVQWMh4n5orO90BVJCE72FQ0va6rVnPp5q524dsdgQ1xxZ2evmL9OL0ib8YwexuG8x43HOL1M70poqqxykzgFQawKeOwmAY9au6BsU/p0IoO7TsCgg3kJfUgA2ZYQ3iHYJLyKpnCTV5CmQz+LW6RAp38BGfkysr4piFCeL/HJ5PRTV6xglkqqiDcXQWAkV5PGeEH2RZInJb0kQV39tn24tXdS4ONV8zN9tNnwUc2v0k3bN1eDbjuajsXJv8Ifu2CnJV/541U6JLCDa5bkZS0S13YxHPT409locDNsEUwkjT8ivhmzZ3MrpHNtjEz071/AEbt6oysnFYrNuHdezhpnA5khk6A1cybbpb/RVsrbnrHkLOrvZQZklnVToRfzrEFnvAvm0FFCX9qhFAHysidCEUgN9oOljVtzJQl+IHcmKAqx3wjBALGYD5ZyFFuUrwkJKTlQvhfTTrLGsE9ABIS2lINBGdOcmMKSc5mNpB2AAjwO2HhwvRqKcDSSxbo4q3L/P+zkjLow4kRMOMRQizoobzO9niEpMR5Y2PoKwtpBPSwoOBHjMzkqpzSntBiTVYLRS1Bv7T8CF6LcxMvceKQaokdfDL1GWRNn/fccn75Xzr/acXAdu9FRLocTIGMZn47Y2KklcPelwPeMpUsz8Y14WonjwCY/k1o0/l6i9TEy+ggDFJ/qTHoJ3R6v+yRg1eRLIoeGzPqXumfNYdY8+tVmLIppupzR4UdC5HZALZw2XThtZ+Ho5QPMYtWrKrqKiqylIrORNR9FVxdbY+E1weK4s5ZG9gIpvBimWRA5NDJR3dPVXqD++yfF3+JwF161RWglj1oUvSiBwAiJoUGU9sTMQURcMt45Wp+hu00pXGRNiXZQSOdGzX4mpLqTqTcC2ajU6Ut9FTSl2W+lYhcfiBPBUJyTW59Ka5lYoLYeCTXXIvyrre2sguhHC9JCHOj+yWTvQXwNXUhMvyvxFiQhJpmHx1IJbeFN1alYkOGtUj9mdUpN5nrihUGEdqQMOgxGegRIzN36db9PoNXiVRZ2Ev8hyDgLUo29Whc0k2D+TFBhfSI6sKKKnKg8jsXnaUbJ5NnzJeZKTAKR1/96k1rLgqGjn9t7xfFyRrPwOBUYqQeO1SSjNekimHQZxBdC7hIpsCQKLIXvrOvxWFfkvc4+glmvG1mD7A0OaVj++Pw7SyvimF+bcGxUkuWvNyg6i/MmjZJ4/Gomo4mcFVyceDOXm9cj9WJyUvjqBXPJx11Ea49IT0UbOT0pFa3h/sHHJyI+yWPt0kIlW9Zlp/0yPeSi12roFFaJdEGbUZReYO3JhJSfeXqB9kVOLVOcVzJPKqGBZSGCMdBJRp+pJ6cddzLiJIw2rPSbD2w98ZE7/vh+x60tMmiROQ3NZrczTofN7nNl0AzO6USzGWvSk8y58zKDgUFiXZornj2TjHcdDAc2y70yyyU2dACNGBvWEKN1DJj7aV1DyXnUGnZHr+7cuWzsKcwUonaC8KXLpOEvMQhVupnPwodKsipezcrezVKHf/d2MtJjgaaxuAyI4GEWvwAieAmo5J5kh8ZaMZINYgazVgxmz6Smbm3CJLNL/UMpIYLvYyPLvoh3UMXti7sS4kiZtcJXIPH7jvxri5Qxi75St1zX2KVNn1O4Lt55Leq/HLmXJ8nEaPRV6yptfXLejQfjZtetRV47CddA0eZwxwn5Thm12Dtlz2LvlCmLvdM2LKceNdsUNFCzezUEvhxcXIxStx7tceSU1u58vHJt5vK/KPOWO8rKnOW87gcupuqz7HXyFb+ZwUyxCyYHz2/QKODaN9/Q2TbkKA+GnwJQjZWVCsfVvuuHhyP4AZSF7iQ1PeK6bZIkzPfcJN91V4u+emt027yeb5T/6dzOVP6n0udLbTtuY/80wRdLi42VGr4TL80jJD+1L7GUeNVY8HN3Y3MOU0E9P6bpNdpxWcQsvIDApKfWaJ0fSnx0fLiz9e5s5/Dw4JD6yWQZwfEZFyUxh8tnbcgGbuQsW7oblkgMoLQOCz5CvIyQO7e76FFsAex1S/dPovukvhx+m7JhzrkUx/b4lLL+SqY031heWmHwLsdhjL8W4PrsnV3O5llRrSD73f54vkHcXnU/dvYPPvzwFpx+j9huQ1iAfVEYHXgTc3xqqdRZJ+Ra0TmRYgR08GMGoX5lItWOoDEyNV4M7mQ4/J94L9iXtDF6AMOLMGMAGspjR24kr4jXFHrVCKJe+zcsYNRumhYJsYdI53xHT0jLgRjsUzAgSxWmyAXzW2AZFb3KF1aoWE4+MVOim3eBwj1zMK7AKNI2gB16+qEkbErKA+ABRy+gTJXgAe/9mU6YBwxjIZSPqbGzNEExU7zFyDOLNHf7nQzKNLT4OMRnchNQGbRM5XBLpu7a9UdMLvkhSlDRvgf6Zgkfyj4NRfYe/OjsQKYHznyZ+/rG8eFlnC9jruhUsO/bO2/Ofgpd4nHR+ZK28ULjUZnxCJO3XqP43BledvpOCKr+KPYfgcnfMBbrDR4vqwvAFhMsMW8L4LzfMeuK9tQVb9eT+sIC8xrVO+HoRHyXmqIV1++TIWgsLuUheJGNYKWWh2A5B8HKxF3Q46idT6VDJ84hnzHY6KsEpwy8WlmphuZOXusuF4qQoKvJ/wKrWE1e3Nu7HTPmgmtDQv1YnLofKGF4HTG3RjskFevI4n2YEiVdW+9el5NaUSswao5Mprjri4h0FWquC6pQuJeY3ly3BYRkQdpvdwgJ7/vtKl6DEr6XIVum8baiDbUVeZuNjum0bo231IUlKPJExCOfHfMgP1Jjxd03oaOYeJnABPdFebHKsGXvVJHqF1IQx65SJakaC/XC82Z1hBZ9SwUZt1nfoZV5v9DpIyjgtXfpR4E+QjnsnPqt7s+rVGkzKvamWQExyy821EPtL+mCNbNhdQeW9it3dEOpbgm2mQ3HnkNI2vilBKklY8KpvpPgwyau52JDMK9d9/HEVrXwvq9WOWbRoYubrF/jel71XM65hz37BA2EeMaLcTGHexYOwAMA7FQWdJRXWvoaf3PGK8RX1DkfX3xudnlUglMKXzGXfnjBS1EnfyVwmaA+GTnpMKOFCg0XCFzRix++YrRy1nHOPirHfvMsAwjwPEH12wUTwsXk8PxtRGpPNpydDlTOLpsO6VkAbvuA1ng9eSQD0LV+b1Ty8pOJLigab2GYEhnEaWIOpGLLxjkoxZZdguQE4mtDoH0XZ91UFF99kuEQPLrtjFtXdCo4f2pBdKmn2Fp9EnaOlAfIsK2t2BRmGvu4RUmJktrNO+A6LCMIP6dx46s0XZmhyvXKFjD8LiDfXxeIJMNhN+Kme581os+SBqxLST+iK/OLSyGvdlnCMV+QZkKmnNppYrx6A97YCFM3MF7SnlhlkgqHrfnGHP4tk89VxIpcqlYJjl2gsVx/WYSK3uxt/XA0MRFJfI5lyJ8G0LzGBhy+zfFgv+yZfcrntl4BHlwul+20EJ28mgfxVEn+M5mvV3JsvK3BcJi2xuo2wwRnoFR8FGPm3bw+6cYDXQZVG9s7YoKOd7az23/T/9Qf3PbNdXKdQT/ppeOrQfsr98G6ry+EY4ec1yqvAOn1jLukySKW1JzFF7WOLcuDQPq9EPhKIXu/OjOB7PmVB5FZL2LHvqh9RfOS+tqTaBPVeC/W4Yom57z/+nh3O1n1t5ZAlJi30sPsxuuwvxsi11n9q+xLnFtaEYZxAgqkuNkfkSPY5au7srg8z5WH8dYq7itLioPvN2tr7kY1lvKs2VasRbPwMNQDTky/Q+Hifup1nyGq7r7byWYIAJHFD0IeYH8COTWf7jq9NMgzfgfkhpANBhkLV0TQeQaqfS0eTsQL34aID46ySfjgr7OhTUDAX+i2lzXjCD0YUSb7ncEWpc2dn/d29rPJE0FWc8awXmsEtup8Si5Cy7nUHPJeDlP0hDQ9QQC5MS9J/z+f7+YTPyNoleNSJigIILuPIs8k62KEPQlpP5pq4v5Bqgqaz7sYg9EemNbWnyWEhxfP8eFW3uIRINMtHjT6bDDCClGUNLclsYhqheWqwCYQsigVp119Rg/S8GxmN4j+nJetRIMm/FkMGSh5KypF4x7cwmhKQ4ZhjWnAOapSWz0jjYOYfrJShDcVXquTrS1lZZIGPmY/zGOUoHDhFj/9P23AC39lTC+CI86o3KR8U0ovodXq+mHnr+X9rbyTBkDkreRGjbu2fSVxTS3qmp+bJIBbLku73yl6DQZl8WUOSnAobXze1LCuY8zOUhbF4uLpN3toZT0aDzv9yzkwNr6+ag5fQ6L0YmuFxcDBLZPQ8XXJ7Nam3QEfd02FROnYWshaTRlRfJMth4k3Qpymovvg5Cvr9cG7dzv7x9mLSwHlra+F2oul7+tLT1xr0Oul/fH3Jfa7X2J6ph4ibb59ffg6exEBxOo0h92/0DkNuwG4QUdOCdFEoobp2eqctaVv2Ep6nRFeR1KKiUYFFc6RUNsHnoim1bxcQdc2mPFBHP9e+JrrkEXW3qcXo++oIaq4VtizMhWwHEmD1V9GVZwxzmxYdGAbtKCy9hU0TDDu+TPjs62nPGYrYgciAcOB/CVezK/15gnh6eib0TPwOF5C3lJwg4JdAC882P4v5uq1v7OzfeYO4wTzXZ92XQWsLQLCnyp0fwzfnSbvifnttyQDBm8H8uc3c2Hd5zZz+yC2FfJbunyPBJyiZ/Rua+6aEPueIQK/3Xn94wMdrub/dHZtFaKpfTpi2WXrYQcRl6qVY53CFhgtJJPa6gQ7tbz+quBmjejrPnqG0Y/kmURy2NvZPwufKSZfXXyMG1npRsMfJxf14sPWmGRWjrde7e1MMinzq5nynPbbwev8Ergf9GHiXMzRqRGm48bEkowky9Unk3CvbN71JzeZa6agMs2g5E8tz/8TlfxDdCIvFFXkIk/so2/i6MWMS+GsvI8jsr0+eP/xbO3Jw5nMA7ZwbMPqBA1ey0XHseWaV+LmkK9jdhHYQDzNwBaSXqPYHmuhSr/9oiaQ6xtffTOtugajBCLlIBYgUqyIUaLginu0wyfuWZleHgt/OvGuz3125/FG4MbickzOWwzvWIshrqVT1HDk9UdBreJAua9x9O6DYu7L9vDRV9n8Vpb0jdK6N5vJfC17B4Jk1r1m/05f/DYY2lRxo7ve+aD7bTYiN1a0gNwKYc7ZS0QBBRcJqXadTlOeJnP+r+BwMjrB2LYTO0iiAuLfsbwWPenOx4648wXOpWxS6i9iKsWsFtYKCT2BJDprYUgl6Cy7147gWxVizoDvOSRPMpEb8463U3ox7/UXVd52L9gdGlTJ7gKAzPkUorJZFBNUcdyUgPoNnKKn4w0whvnMQUMV5g54Cwplr/6QZV7YoWJg2TyesPyU/vVCAXufCZzNu/xDhdMWu8FDh9rmXtCBrM40Yd2/xC3n+BxzXvmz2IH0OMZsXpZTOhHQIZ6ZAUJTbVAeqCbQBkB7Nsb/jc8pEsDGRvQSF3210Zm63TCoxuH7ZTSHcJFJLzTxMZerOAFMQQSZhBBrQaG5LjTbzNiWO2hBVVRnrGW8YXqdNseTJAGOGxkz1nl4TKhHn0O9EYZnzqrzJKHvfGXtUbWPxP7OV8JysZUw/30lfKuVwLKL5hLKcg6hzGe1Yz5KKEVoYvk7Tfx+aKJeJ0RRb+SRxXJWU5Yn88iVmWESpZArLk0+jJVPzMgLi2uKhKE/9oLhwtKJFx4d9CAr5HYSTjsiuhdRGxdzZsFWNxaXTuPh3pGD0ewsuO+MOv1LSIY0O7iYRY3+t9Lk8yxkX/2oGkwzZ6n7d3Ji5anyv92hleR0W1qLfA8l382fPI35YbMXSK7nzx0ypqrT4uIzScbgMaZSKya/3SQWs5h/c0MWNGG1eHNzlaS+VwtuWWIbXJL+xBdjeGgsrvwFXKbYrQmBa9PJldjcdhRMWOUavUKpqxzzVDiJlWPfCqWzIlMYSWzlGNCCKa48y6+b7MozArtpr4pv1TxDmDdJPHd4XFoouJp53v4COrtH0dgV1NdNoK0rqKsrrKkr5Cj8h/bW0IMLOb7NbzEJtei1QibRYJJx8lCpBzWIfwuSTkWYoZSbXGVskM5YNxRJjbbRM7pt8sIjcLY2Hyu/T6Uybfx3BXN4yZjjqZMH0z+iRgEIK5yJgsX8zSIrIeeIzqvMBLL+SMHlQtfyxDkK93aPp8rKYxlG/Oqv6FY1idPHxO1ZWqh83evCHig+60Bq2+L64gQG/p2fj3NFVwET88mOhHtb9TMCrD2ZWD/3Z0wv4V4Uz4YwcGO85QkZY6n5QgYI5w1RwBB1yTuX4s52WfEjR7nxI0cOXRUVE/UpOSQn6vPwd0Hx9+vW+0eVDg3dfRcPv4uHfz7xcDrBJ/vW268h8piLGcMr+uFyEexMuYKRAvouGT1EMlJT+QeUjEJ0827r+PXbbKpBEJ9mpFIyPKGFldjGDqtuvvVVwJY81cD7F6QwRAx2NpqcgVldb2OxFbZyuMSwuCnWMBjwo75oDhOYr29qjr3P7TPmv4hFgBgavA1p3BO8zcO71iaYkynmF8ExoPJ6tnBWJ9aTeHKnAnnNXOzkmhLbOkyzXehWbl48rM1XPb9GgqfkujZpWrb7J5GBCUf3RGN77p941oZgNEt+vEsgbY0chBPxf2noJ0N0Ar+97DUmTczsLK70tbhBHpVCEyt8uOkr9zrzgIJh9/ir8UN3uOKzDxW6298EvS7QTwwmz7oRJDcqovF7EQd+e3xxQG5ZGWZLe2vxDL1k3p0teZVxBATGSl4SH0kVE07EQDOqvMzJiiQpTlowq4ot6XvpsSRWIcqqfwuWLjR84dHzks2/lJO4mpFQRAbbkqblJdexF2q0m+Nm5DqN3192ncwV/sPx21zVqIDJvOTHpAjDof/jrPBvlMFJrtZnyULjxcKLpeXGi/w0TpbStKb9D09r2wf7OflbAGI15okUul5sfzuwP4Xpw6/tlXtzVaSy7a3jLXqT2VSVvdt551UWTKcjAP3KAlkWPu6zZGrt9KJ50x0Xq8O/nY3O4/2TTGecDBecqONN3N0m4mQTca0hbAfPD7/9JrcEycZZuwxLQlJc96YeDfhxCBRjbGag4JUlb3b3d4/ekqXsXXgcunLVuuxU+SBX9YGW96TiX6EZPJTvvLNTWZi46F2SMDWzQT8eLbWEnImI1CLKg0SiS2XJM1Epxt9YuCTzVeQXTuvTSzJBPPz6QwEAosMZJHJh/k6gYyeJh14mSwuiBbWKfR/3exLQ9cZKIXDw97Oh3WEYTG4hcDYWlxCnnZkyLl/Yn/XMqKfsFFpqoUAZ5LF5l51HGPGrD2/8GyXz7j7f6bfZ1eexmzAf5275vOuRw1cNB650j9z3HmubvObR7/0P6fgtJoRU3IdmV/z2I+HcYujZxKa6TVTmqt3ArqmbNcNX8E06dkfpeLvTGncG/ebwTo1f27zQrZZXv8L7Pe1wYoHYGTxw8y5CtgMXyj7+3BSgUJiWp3pxEwbxdCOQNHH6luR5cnLscohonkDzJsie5Vc6U1UyO/RmB3l9NuLKOAbGeudLhc69zO4GHZAFYm20vwnvZb7theSAglIAW0sqn6Ud77xVc7/2xM86IA8JXoiHxOrHDiQYR+ndKxsAxwv2AuBwz1aCQXbO3UUJJjvxb4xJML+KfxmGjLHwMuvLtA2hnOAJngm9RMcyeCZ0J6HoVC3wBePK3F7B3i7eNwLvtw/gi9thmXwNvix4zYVNfQPNg94HeO92G5MCwYdlfyb1ZK4EJl9/e+EXg/obAcKA13X/tZgQ+NIIkAy8nw+8V0XczqM5Cj64nd/bRXi371L6Fx8Cff/hGDG5XYezK7x3u/0K6Xje7bVYg/Da7TUc6+C92+ed/YMPP7w9U2O7shj5rlfT4ouGNwI/n/30ahe/eiSwvfPGfAyXcgp87gwv8SAn8yk/ef48GZz/8vxCyCnP3zc/DZ4D9PNeOho1L9PR3C+jJ6UbcYIVXE/wltLak8/NoaxIgwhULSH3jpDBqW24N7osC26ZftFsTyfRZC/9HI2KY5X6adomLNboTtxUmBpetC5t9iDcjoPWfFAOMBtAdgEKr3Q4HAwd2Ea84gD0vA+NmscQ7IIP2+mPbi4uOq0OZHfvpb2BOwyzi36hc1FEHK9CVSyFqoC7OMWEnYsOf06HcCWnKeVpJXQpeTPmbZ/Vcq83lAg9mVi0OD1pkBA98Qg2OIDhnTgj+fcMqaqK7h3iFQKpf/QnEqLGhL9wXBrIcyZAFWW/u5596HVIlDG+aH4hcuBgMLZPrZvhkAO3h+gYVaM1YbgPeSMGqM3fXImJ5W/E5A3tk6DZLsGozZeydaNP9skqduDpvDlK+ZMcMF6VWFZrZMxagxt54YC6GKm+JG9G4kGHgv8gW5pJ6hVaGmyfUxTGdli/B/MYaq/jPGRead8788I45qCDnY4exzDydTeIUjUJv87MEBYGo3EiXpK0U/cWqaAciRR+rEsSxYcgjtGJpWeIC7/rnZ7OzLAzsyAvplfDWuRFzZEGw0fMdgy/aKi2tCBD1eLDqTw/UPmZKZzvnWMANmQTUJLjhGycWQ8WGhvI8eP6PCGrVBpA0bumsZD8BlqUdcifI34atfVUhczqpkcRxc78GZPLG0ZL/FjHzsBPOl9k4Dr9qQZuHVD6A6f1b/pMfkGkeUKj9QlpFBGtr5PeW6O/pl56tJLwvE9qvGxsg9svGR8qT6BlqSPbcBsoTxjiXAz0AMNWr3iHUV2DxAzsQl4XWIsOQ8FRQFQy4QIi1M+nmJWBj8OkK1hdABNYvz51wF50oisPr3j0BNB7jj/UWaNrawJ2LvBAdRpR5E47c64WnF7J/8TpJaNGEGq9CjlI1+4xCd1hIAGPTdmpG+aUJc5IlNs7ZbHRjcUl1urMRrVpo8J1t2ndWAMnTL4jayJR67ZPF7OK1CVMS+2HUjawAoMjGqByUVeqRAJkdLYE7O3iLX40Tog58wXrEwtsOh/pQUUs0QgKeU7JwYFA3sque2uL+7RT/3J5tyOMCGVMuHRwVa3DpNBVZX3OiY2T+JabomZRWeq2aDfjaJFMTigZzlikp8E6gcpOCM2HCnieZbbG+YYosbQQRF3jvCFBeVATiD94IB/qr0B3+r3c7Kz06Lh0YbHZDSJs2k1YpWcu40LY3MTqwIYBZU5ZDiS9N+ue6Q3adIfs1cYbDKuWvHMt2kWzGalC2JZnCEgnEQuyGx/uCVHhV49LS1Sy69zBF7/M8EHxZ5GxB1sh7huUpMHrzUqQbivUvoIfmKgVcAiwxnzJgPzdJUB9fP8S9I+iCEZIy7EEFiOdbbrUBqJ0sMNwCKbiZJZR8fbp3Nw9mm1AsUOfdq0g5FKvTUIEZWdktev+QHFphwAzV0Qr+QScWDznC5abQ2C0sxqWuGgJZJ0zwQ79/pi3z8AdYsN9ilCLyygEwKkiBsMKcA40H1DewGSDZBzBEX6wpqehs4TiSABwyigp43SgpExyQrBES48ITFvOD6lcK+dPh6P088fa1fpRWZlp4wkdMP06nVymYCciWODMfSL6NV8VfxbgzyL8WYI/y/BnBf68gD/1Gv6t41+EryNsHeHqCNPA9w18M4+Q8wizgO8X8c0iQi5J7Pj+hcSv0Mly9SVZxQt82ZAoG4vYHGxI7clpxeuhFLEcsfYE0VUn+7sc+bsS+fsi/LdRi/yth//K2pcb+Hcl0MV2xiRKPFV/OpftJM7bvjTw27yElZOCb17InjZUN+SULso5XVmUE4kvl5cUYUhM9cV5ibcmsc3XliXumsS4VF9AuBWFs95orLxQcy3xNhYWl5czZ7g9+QzHZi82S3ROGuTvPPm7QP4ukr9L5O8y+btC/r6wf5cW5F/saERl+qvULWdoTP9xJLXPVGGKSrbhTWs8GJY1fxxfdUZzOhmQdUjA19blq0beEn8v+tr4CvHXJqdRCLd0NPOR+++tvxF/r9wqS+SV712Br6l7ToPWqJyOLCdnY36bnr9vXqYw0jC2H3+Sz2xc03ZnXL7ttC/T8S61YWjgOfltdEJgTuewVMXxUbgE3aX48C7t3+yO056ZJ7XfGJRnFCqApJ1203Gaj4bDhRB1RrCBvmsOP6XDAvhC4AG0rW7aHG6LOekOLi+LII4UCKButttFW+uBBtD1EGB0dHOugUZxhAHgUOcH/bGgf1m1gs3oeQA6jvQnSWtFsXLwANphOkrHMO5/76S3+SMaBA+gHfWb16OrQQFCdyEdZM3r626n1QRr4A/dwXmz2+nDuiLOUBaVHMLXIOm/T4c/N790hFDHhEVQ/3/ZEu/fy1MK7CkIt52OWsPONVRjVWIAfS0A4aMA/iHtp4IPQ9F0OO6InUn0dKvbtS/KBrfBoXSWEhFeii54qEY6d363L165RysNCrxuOB791BlflUuK9EqVChHOM/tujyWuHG2K9Zp98c8QRgn4qUbtf8eRGokD5WA4eidflomXy1NTQuxK7UG/ewcnDc7NBvFqzHesxo7nm8Gw15iknl5TSA2iULwmC4F1wSPUQivxl6YgTYPRzFUEDNG+tm8sOpDijjq/ptWk3BuIbf3naoL/fqwkG5uEBOzow5IYHVyn/U7/0i1j5raaWAefSyDRZveNqP5Ns9fp2pC6bH7Dm62ZS6DlwU5XcWSKtcOsh47UrHfEoT2TigUI1bYn2dx47vpmdFXO7uwcbAuaLwmGJiMUR3NberfYFaX8zgshRQhdMBOVqmg22CerSel9t9lK1SaSlEApJj8x6LIzw5K1iMV9iQ5nmT066ZzOiQkfgoBD1QyytGQRatia14K3puUOCci6r1RC+h5/HYVHOLiLPJRYsqmfVM+rzV0JhdcC7aGS3fRws9kgrQaaIbPCyKbbLUAw6NEa/AeoSOBIVEtK1bzxD/aDyotZnQj1YEeUfXAXBDlcdC4F/aHcrXpTCtG+qQXaLLtWZiQb6h8XZCft4fGwObp6cBe3sQ3F+yfbXLSHdAbnPndG6JrDXKGzRiRW4t7j/0ERbtIBRSSA4P1gOH7QoB4CJgzM/CzQBQaUsCrScDue94E9LtjH2BBNxBDDx5SJV5ygx9SiedjCgybhAEpk2TTpdCCfLCcayvss2Qg22KP0ujlsooZimuH3DnTT8GuNo9iog6+k/mvGnO76QY7NBI4wQwudpCelI8mRJu8OeUDGJtuSiG3I9imLsUl4Aa6qzqUib+IKcbjQEBUpmE90yWTjfDTodto/NG8u0+KbSJBwRGuSJopPiDK5BJzZgy2Aseai+0iB7mz1L2+6zeHjdkghLdgl2oRH7Nl257IjeJsg6Otu8+7R+qbQJgpvbu94Mx6xfz8Mm9dXj9YtxJZPfQCV1Ydsrh/pyWHzFnaVBwtlR1eD22TYvMUdMNCXoawHDvlzIwGbLTi42qhJGbIu//BuKURZAhFUJro/DnVpilPe47FLcxZ48DBInR+c6hAh6gGDBCshArP8gMV21Pz88B4AkqQ/uM1eZiMBVcbt+NEW2N7g8k2nmz7OAhPS4iiTFAWQqHD0kwyU8wjynmt1C57sXUNL+DwsZVohjKBGQhz9dfWZuiZ13NaxnlzLhIVEZcT4pKIBHqoC4U03ypCG7nMjOsLXaatz0WlJBN7IjTRCD9+EikKFyOicKAfUhq4OcxkOfE46fZkWb3CRXNrtw6qu1eBOv7OFiHWCRrUDG3RW66aVKx7YzEsrHmW1bhrx9IEta3ryW1YDpxM4s5qYxxOc8x80qRoi5LljUbaqqT7MrfKWHnZSrzyXeWHcNEJIfT7odFHBDQ7zFeYla0NUwK1KFeK6X/XymyjyPH5/S4zalrVnN+kxNW9eg8KatlungejmG+NINjY7sxvfUN91m6/oyqGCb6tcurU6pT1HpxTZ/V1hQSETNTjyGy1jZF0NrZZJXHZ3ls6tEc495L0CQgjjiWHlzdOI0XECPQarxdd2xWooqF5h2GOqzFgdEfgCNTHbRAx9vvqbzwC3B0SHvoCSPKxgLljGI7og+PSSaGjLIsL/62a3+6rZ+hS2id0/yTR2kbbmGNZ5E3Wo19Ns48Xak/iZZZheiNG+8laiw/q8A0B4ivRCD3FOgpzam6JchPXE5SBBpy5fG+o1O8wBTLNdDCOvDk9t7x+NIsvTVBLk0rQbbA9lu6MeJfCvE/un/AgeEaWbfju96PTTdil5GbdNmbPEqiprooIvOpAYbPSpfDunnuRWL/cnd7OJu4DcznVGr1JRBESgtB30PnF4hO9/MnfVaad297pV3MO+seenVFajUykEfBtiawfiSQTApuQD/PrkmNwtRvq2ElYcaOwjcJNKy52qCZv2kwOGK9ANW1cphAK+Mhkjp2GY1uVee4RgKYfO3ohd/0O/88+bdD+9Bfen8rXgBp0vlNj6XuzrFKwzMpoo8VPXKlW97V2fx10DHgiPqWsIWQCyK8ofM0kJXT/6RLBiYQQSzhkHV7PqrDWZcmiu0xcHdQEiJuh50oBgKxrt7sC9TTuXV2MHUIq/68n8ojluAH7xaL+L2U8aNfZdPNqKoLNlv0WzQJZ+s+5caNWu2eQqBK7D+GOz+sRGawHgJnXog3Ly9X9hmhj59i7w1uY6u21fKv0NOQiUJcG6LKGafKkmd9VkeWmxmiws64A0gWJO7DRn4KVnacyn7NK+0bJrRxyvl+ixJBAS1GIbE2J6+baa0FRS6M8cXZT8K2Nlebpg7vTGuWWIk+oN3q4YaDQ7G3qkHrL3EIqH6Jt3zfHVXK/T9wmtGqBypCSSDI1T+IhSeCYFjyaj4CA4HtcDa3P0u6F0X12TQ/Dzy4Lg52tTEby2BGJtf3XC/07x/ybeXpzUFwWpN2r1aUhdWvG/E3rU5v1gil/hFP+CEfyLIvS+ICjlsWgecf2u6T5k2chZAAv1mjg2NBanWQCuZ0SFJG36plI8tBreTSDH6yIgReufcVn+r7islZqGR2Sw6JuCkR9PsyM/ovogGXKy1xmN3zZHrSshxqRtX/kRaaaDa6d3Pb47VK2UVg6DqtkVBRvyEFv6OGiNB7N/74xumt3Or+hzkOxAxrv/7v93/zV1RUg6o+R8ILhMCriFlNVOYBgSqKEqL3/gvguQIiOdK7lNa47u+uJkPBi20sO0O2i2VfPEgv753R6oTrLHvBhJZGg+Ik51xKuC60aoVw3/8vbmHHQw7O090++Lf8sl2U2xvAT9p8nt1aCb8pFSgySm5rbZGTuxR1KZJarqCsoImvsnV7+EmEw7HY2HA5IlqYDexVG6QjffDAc9MY90OklePK5QMuNPyENSw2tF/mGiMBUy4NdSqSYtLSNDCH6nM0qFphLTCd7KjLm2EzJlv9dLZLwKmszMl14XaEi8DppBKbXI1uHiSRQXSM7TK9G+ZHAj79x7WqJME5mqvzoKDdIGU0yW+IK/ao5MC8TjKB1+TgVf+Glw020nd4ObpNv5BJcBir7AzCed8cssv5nMJR9wW8put42JRh1ctNaJsBgdnpfqZpJeOKvCzr0UW8SPiVYEOCWBZ9Vh2gOhaFjWO1toRYBz1W5/vN35nBHFR4GS9qB100v7Y0HRKdxG0E3hqVza3v17yecFtqgQSO4Ef78ejDpILRuQUvZLalPTxsuoRDelxesvBaDHGL5aEPjXXSWNlho1+F+BIq2b4QgDMkvXg05/nA4zy0jh+fjdnuOWIiD207SdttEBoLywImRX4oN009l+v/umCQkLKlP7f5BmNNvtnc9inkBcAP+mcqklmPOnTL81t+NtKcdCz/uDPr0yOMNXz1rmDeGcD9p3c83r67Tffn3V6bZD1BheGhlN0rv0y6RUSlZJC8nKoPuNWmV0UahXaLwpVQpYVjLMAZGgzIBBIJAly5QIimWu5yPdGewWdN0cjkx08vbBu/f4XCZHEDEfoKfH93P4D4yNojQ1FqK71xDPUS6tP52d3RTkgj+SEjhAkPjz5wK+VOHpfhm7FJXNtWCy9yFR5JwYhZ1m66pc7otHz44FL+fgD5ylBPV/ELQyfN0cpUCrYnIODw6OS3j3ClbjSnC6coHA93YJFRlfDQe3SWl/kADmBBgIFIZwdEEq0nt6zeSZfbx+HO3sHx0cHpXYfUhcmBOHzR/7g9v+kXwNm0fy8edeF6qXlTr0oPtavKVdlXhDBpmTDc68dEVi42uj0pdn9JN2DTNul14f7L/Z/aG0yh2UFd/bhQwGGX0M5ByTWH843Hr/9s3B4TuGOHwu9cwbXn1V1fcCFW/t//Bhb+vwh60PP+xMUH9I6fyQZkxa/+VjVby9+8Pu8dbe9u7R+72tjxO0IKyMmaYpJokgXzrD9BI2u6GU5cAbBGThcny/C56nw+EDX5NDZRmhaXLsuDD4+9+1SJbRiRsZzVtBDmNk09/qd3pCTt1Pb/+eDm8hmf87eUVDWRDHtacvkXAApm5y8MRQ1NMOBzf9drleq+Htdimm+Cz9Z4neQJRC0kUBQe+4Ee9mTBImAriJgORSvPQar1Ux6f7EPnDc6aWDm3GcgHN6muN5eAT6wl0gqm5XCApAolc351RJ3dEfCx8EaImA/N88Hw26N2MtSQagtSxf+884jDkdZAGNh83+SCU3KeED3JxQnhWFqvCnEi96i7pyqGCxZs4UAbgrqSEXgPMrmYDmzGFmTizz48H1P/B9ueKpVwM4zgfDNop3pfr1l2SEppZzIal9KmUU+XJ01ZSXs5WGl+fNcq2aqP/maouVZEFg0v+vmw7ExXZaB5H9BpgqCE7L/3vP5S5BT+4qJsCGoK+Hg/GgNeiuJqrQnH5TNTDiPDO03+HJfrseDMerUrAVh4WyQSJeVwiUWMakBvFUJVtbv5V2we9sFb2Y9MpR2mxpFkEF+8e/L/x0ZgaCDUlVd87lSNtCnoOjyFa/7Sw6U/zD4V5Vt62q3M9g/Zv8vajk0xyBfreqggGsDdAQ6fpAo2hqSMqgyqcVAgerzM3NUTn+fcY6f68B3+s1ln4Zb3U7l7i2Wyk5GmuICxNTw3RjXsSNXwp8s5Halwxhvmdna9ZLM6Lr58PN92KoxF4DqlLo3VoBfj9Me4PPqXM4DUJedIajMQJWiiCmy+c9GWeZYStjsCWAHnH5NCdV42zjV19Utr9Sb9C+6Wr+qr6JgzEo7MHAJ36wzYSRzZtmpyvkivFANKp/KzV2nHpQo0C4FVKQVQI5E0Txyamy+KowUa+1TQAU3hhVpzYqp/lYdMNRXDiV4cJiBG/nnkyS9Ki0U6U3zHqt5qtTIjska2ScW8rm8wkcDVtourSL0GUVkfYNrputzthob9UjJHNetCxXv2UW1CKCji64YXE8RwHF25mKCSZ5vSAaVTrwvmKDj27xVSr2AlEKDhWBrJNk51WNh3SXosm9EV2QAlKtxtGru+PmpbTzEmEHSl0JESAdjf/hXMwBn4h1F3GHTbqYxVRA7t/0zrVaBjYxteeIRrwe9K6FzCS2DjFVZUR10jlVumgAUKa+u783uzeihb/Oomm8VGEHmF8FVejGWrmTNP/XwJW05vOMtF17VjpcwW8GQzsJ5QvQfzMLneX7vRvgnbLIB7xMEl3nZZFI+BcaDm+GkLa/O5DKJyMeAP95/vz29nbuDsyU1zetdK416D1/c/hc/NMb9J+L4dlrjsZvOsPeraCJvU7/09z11fVLsVA3sMxnatlcuE3P58zqfKbuAtso4c0ouhPnN4L+VG+hAc/EcXYMkubGWYnegzq6FkWAKUuj3UU6bl2VdW+ofUaDzg0+xQbhl9FAPY2Hd4Z24K3Bb7DAW2OhEpINamy8a1fpbJO2lBEniQ/DBMOVULsAHqDZcTUC97Rc0hergZINip3UTisZ4F0xU7mwyvSmJmOXyjYbuuCJRHVqSyjpQ0kYQakEvtkClrrh/c+iEEXxX3hZYxj2owe7SChbVCROshMcr2iJ/ONVAFofbdweCTI2YlagmDnpuL3LKTfxwSeAw7PuBGCG+iBWy4ISe8fwQqbpL1112u20n3vioViKyHvFprHIlpwxr0WKxyZ6Nllmk1YEV3T2Z5PGxMhAJXeJypTXg660qv1wNRiNf7rqTNTB0Hm43eldCm41ARZFXLWJuqD0D1lrSKa0lE4kMYLA22k1SSDwVIcmt6Ria5TruC07Psxq1iE9Dx5v17NgtzWsgNOEK87mYkXveSZcD+RQr9p6jQENB7dH182+TV5uS34Gl6ZWs2tOnT2xjs15B+Ai5ldQGErDK2fHC0WNrVW4JxR2eZl2RXf7kLEL0QA2do2CY9fgZ5kttOGFPK9AukqEkFKB45PaUcHvCnPJAyGUIu1qMDpj3w5NXwpRxSS9CqgJkFWXXBBvXs8H4/GgV6I3f56Dph7cS7nWX33gpsi3N+fMthVyuVQF456WTxUEOD/h0aPJ3AVtPRbONco2M4Zqi64zotHBLkbOWBOcY8XZajGd135jIc1Kw6w6/bmlWXLyH+AbsbPjfIeZ3E5bA+X/o2Ieh0LASl1MEZ+J5lQ8rlmcv2nV41uiejTD15TrTPm5Gg0S+iqido9qD4zyoDmNM0Vc5xcWWKuanrj2z9PhcyOM0yHvJDRVH9TR05y2mqORWJXl0tV4fL0aOm7t7D8fDwbdEZysSkGzg1zrlO00K9NzquIqN0QSki2D3ighdG6VcZtLzYvfvulrt4pqsvNFLIJ+s0vdzaoJ+Le8uenjBd/0zKyCi0OF8M4nEmvMeVakhGftyzSdGiTahBrCWgkl1A/7tLlOkdoVZ83tLx0Or59+fjoKvcEKB9wmt6zzilzr1eSntCvIFz0UMzdbqyGnCI8h9TFxidEENsK7UdEokbaTi+Ggh269cKNN0u2cD5viBF+GRXTZQUsErCAwDLeaz68FTKS2UAOJABBXUUSRwfJNtt7vumg+indznV7v7Id0LH5qvU6FTJet6fCmD3lCDvqCzw0HnbaeJVbdKyHRgW+SqGAo4cFdVJWguyCeWl73uM21Mbe4wHzl2unnTis9Ettp2tfRwPbrCN9vv9+t0FuuQeqYCLEJH87AzH241YRLqARiH/yJ8ZruKNO/xMFlgxz4pDl2ajCNxM/t647g7/8CEDW2oQr18DjfWr1KUsrs63XnS9pNUBrQfVWbh2z5e/h+CJ8J6gBG2/zO6P3VoJ8eDI+Bc4/Bu+/9cHAuHu4o7TTl9jBOxAptJtdQZA69AMPA7XT0SRB8cGWVw06YPzVHB2JhDDttMZmiFTCikDOonfw6ECt6IL/BR2AfWLcDcoF4QJZDiAqbJlqVGJs34BhbrlcyR1sObYI7vqSvDTLiNswrNMV+ZJcDJQQod6uLXDejDBrOBnLT92KDQt6X+Y7N1DU7oF02jq+eLvpaFNkdddPmZ+gUV0GLMycgAMln7N5fzptCN0mpWOW+rtzz1sAAz3wjVp74txzYGf0woh10cgpf3mN89SPq0by7ZCh84egiaNDB+S9pSyc8qSbyBjUpvwgy/gz2BZ1kpwqWFOcNoDgS6+w6beuX375/4LSkkmk9Zj98M9LZz5KmWVyneCeFJEg3Ksj6/62/FKSfGEtCfa5WSl5uPgGnWij0XxP/D0plSitJIMpqyqpmZ0VL0UVWd+Bvjbn632TzQTkvnvSnanIhFjyaYPHIl+CgCglpmKJoBsbf5PVNF65l2e1fDOZ2+5+bw45Yeuplgt46UOX/k1PLx3KGypFCNBFchUWjPDzR6bT5O712hqKn0JAHQJJkHim75Feu+vLfUGd2NtLpK78P05Szj10iYSnna+7K6BUtrT+HtbH539qOoKymDDB4zZxkf4xxCJ7MMijJ59hhh+q2VK2iQHBbFDvzbl8e347TkY5C98Dk5ubabnNYNmkvRp33wEqL4WaMP67lx8mJotQkig0B2/AEoXJOY6BD20Iu1IdYdG4QzF0d7T2P+HbxYKd20ErzhgU3tTODmdpZwUsEvVSUY7TS9ZdEACXq3wBwrzm8xDtJEZb8PwAbtJ40h58u4fAQgGfqutKWYNvdCJRSz5XrjULxTT6SWzAEHV3DnSIYd3QrWG6grmgcFxnaqHsahbK+L6U6S299canVoYNPcAKw4wPCPjwNyXxDiXOnxH+cv0jT5guE/w/4JX4XbEA7w2Cmqik2qyD8X8QK6OYGAKheUS2Z/LiuttGXFfMTumr2290UQuPa+4MxpBWWWznFw3yE7n0nCC4wOhokT++lWIUj2bNiZZ+BVT1u4rm3+34WbpGytiNhFvwLdI6zPIUF3fMw25GFFw0ZDId3YscR0wpJlCUv4w5U9CxVNNQ0EGFMq2/PlQod3RxOTHaZrKkm26BdDDJADUTKsrdWKsksujD7rm/r1PUt7j1GCSzgdRZYm+qXx7ryTTX5RE5InLoC3vR6d7gtw+ZIxqilUvtnueoe7lCfkRRVK2RFC4xFXB+gXCUys2IpesmUIYTBiWu1ZprXg/SClGGkWCMflCAn3p6ckteh+yA9GCesLXzVqfPJUSO7n4MX6bIGF4kgD4dWy2/gAvj2+Pj9MP2nODCND9OROBBFbzNvy2OsoJGbkf4Xc73QW87P1G0FNl+rfC3BQVmOP/xPij7sgybKS5Wo27282FZHIWX5MKytmkNDbVklbGvu1ZjdnMNBMjpSJogAgweqqJGvYhiAGLfhZ0jECml98OFaILgV2ycfRQB5r75wRie/N9u9Tj8LQCzLtntp+5lAKuQn/7Vtkn+l+xlpI/uq7kjGjs6NMP/GbF3GpK2WbJJO5S+5kTiwtWoyq30WZEUBWN7lNqwv+IeVEmMLJcQ/EyCDuUBWT7NA0XEAG9DngRBjajxDEB8r8sTQmAHLQEMGlTy5+YqwoU/9MHH7da511Rxujcs1OfbPWYwv6y0pI+egXondTV24cj7xk1ROCcDVWF7Kq7px2sIrk06qLgGkEYbWRGNww/0BYbyKjgykaHAEUtGOhqRLNlyCQvB2k8Uc6wABYRwMl3SEe+E3Bj38/EHRa6QIWwIyhdXLwLdVxUII4uwO8EXhITbfHMRnVzfnH4bdMlQMHJTzSpBJpIM2IqLO2avPn5c8Ky9gQXomCbPFUd+8dsg89D7BCmc2ZCGoCARi03zx4v+UQotKlcJ2IifTRWXLBdX5sXh6pZFl+IS1Qaw3g8FwMjXsAkSPo9Sz9Jqf0kO50ZcjA3jmjqDGfuY3+Sy7zWdFGn1mW20+grSEnuTEBUvstzJdBtl+rOpKHalAMy0AQfX1FgXf4RztcumHneNSFeqp+vRc9SmRJnJIR3Mo1njHuq6STVTyi2PlpQSpcCpzbfxlStPcXKo3//foYF8GXpQZBFSqoJA0gEjpM7kBgFJmV3NNvSnSMie1U0yTJUZitUTMSOHt8kwV8eDUbquDRQhw/dTLF+JIHbo58oWMO1l7EtgrNGC743x3xR4NyN4HguSPDz/slDgqR8LSmOjrPESe9s/xkSKLwQwveICPx9ej0EZp56B0OxqVouHvIfAg03FP5fBWsD11zpKhStUEFoCvELYrTcJNmYsENcakAqthtikJ3LOwl2DE0zNDJw5uxq+FkCuaJohpBOZeq/vOybkTM+k9Xjab/Jw1MJKa79o5EbirKqeDk0lGwme3XZrfwpg1DnO3VIm71ZiC2VWIdTLykdvyAj2AUOSySC7ao5Q6UIl3Xel1C8UJ8RE9O3pYA8sHHWX+VS/dTJ/brvK3pYQLXSm5HLYvh5flD1GFCVtFH9yxoInzm7Eh97kt88aBVGcb83nuqjk6uO3rALtyCSBEU14SmBP58tTITGQXkGw6Ax9AePjwJeJbqbkYLbfJwqqgfMz6Q7C1kutn4RUQPk54GcJHDmgZOAHKw4kvw200W0VmOyVUoK3qQwh3s67OtXzDWWM3kjTrcyOxEiSXEWenBbkh/fTTT3OlCslXI5FR4AWXLBtG3suttFGwUkDJgBe85kNJASdEGTnf9EjIr1UJnbT5MTt+lBYrdk6IYMO7ayGcqNdVfNsdXHb6r++ur+wGH72j5Z5qewKSZVTzcyU1Q0yZA24QqhdM7yI2BSU7stdX4173aNh6LdkM+wQtOLobjdPeVquVjkbbab+TBtU/xkcBiigFoa/buTD4sr5Bfp27QCUtWwGqUmfr5GNH6sfUePCTCHpziQNY86Y7ZiZrfXWsfzwxLuFXQ9DlhsZWABL6gycxQ2M01h1clFE1MZPQKJlru49JJHMdDfyS7l/X9I5It1aOgC2W60p0Vo3yW/9Q+vO5gWAXGI3jnV2zxkssJn6o/e23PHh2qHXI8W9h16H/7nOPnFJjrl6Ct7IC+AV7tfrX7Bgbpb/p8x6e7cgZ828lZHsuhDpsiq+wIXnl+bkTAQGiTEDM2VOw4b8hv/GwAIgsuopjIX4nJtZmo/Rma+9op/QcOvNc9+q57aj2v/hbUPB3xjNrKqj152FrUh6DjWB2hNKR5RjZCy7owIHO6oUXqjisqY3cRsuLZ8u0ZbTRhZJNrIiBspxYq1fXA7QsSTze6iUKVg3Mzr+2fo3B6Bl1gXAoiy2oma3Vg/qB/+YEt0oWEOnWwsJ8yQ3GElxQ8UOQGpX1wMddJWxuMBpLxYQ5altwqOllwp9XdRsqVd0hlrlbNYGpRAgvBMq6MnubCQLku15ZIWGIScm5fMbODnSkKNUlftElt2NWH7W03PtDSdd66fhq0FbqHqvlcRWICin0VwhxvY6QgC60MV4cNwfdz6LQMAXfVK70+XKlx0nstG8FOThjahWIjjVByj+edUCrIZni1QV1XQpEI+aE5NnnvQV1RLDPa6zgbWd8Rc7PziV6ns4hVJen70Eg5bv+rtNLj8XWVS6BN8zz626z01+DpN2CnMcbX2ahgbMmxGaNYtBpd8xUuLfzIREoi+ImXpIGY0XfruOtSUyqVPOJiR89o2fZxJ6I/bshqLwMLdGZLSpViryKrST2TypGuuOWV6+8E6Qodp4dTA+XTrIUHK9Hq55VOkr7bX4FtRXvgruPWrKeYBzY6jBL7HDYG+nLVD7itQ/vRkbLbLfxIoogolp19N2IglgZ7EtiKKkm7LVzdqAOQcQj/1CFtQkGWsZVKTuUkRwlf4OXtJ/O4XQfY9qtDVnbh/2tD8dvDw53/7GzzdLg0iRb8sgAESGQHA908KhzF786I7F5wEmiiqnLwO8P9Ccf/y6aqVwYRSl0BoJ4slFnfMMvh8g/oFDeElb2mdzIH/++8CbZOTw8OFxNPvQxlQEm8pcDCrtnUmKiHJlADCgpMxclzBQm3aiS247gqv3BOBET+GnO26Yv0PEV+gA9GULyHvGTmjYuRn7u+sjE0R4HerY/kPcojCT9X6AKa9Av0L38vtxeAWZorGewwKO43LelpxnVxUsdN6F2/ObHpahrHeSEeCv9YlTJm2kcaNGAvmAwbIwlQPY8ZPQOJrFn8x7JHsrEdHZjVjygYeB6CHYD47sWyk4nk/qU1YppOKnn9EkSPtkDJBjPmChwjZedVKgVsaFLSTn1WiCeN2UCKD2E2fjICTRx9k8JvOEcufh2OfFUu5Pt33ubM+25Cyl/GfWArQL/yl9GcsnFF5Pdz7K6H93OLkZrRTtVULGD22JfnHqJ0dPBjp3Ey3iYWoIwMIWAGhApG3NVOrIWVQgsiFBBa9gqO1t+iziiGa/THosrd0cotHYFXR51LvtNDMrZ8DUCxPwcUQUQ4zI95sd0AwCOx3+6mqVd4QOKCcU4BG33huIT5kW4iKkE4c0TW+LmrZ0uili/FaKvhbQaKK/0bKg0snzWXMfcwZlxvy0XLh0XZwsRk4ATPSq5KmDNlTujgz5k7ihXKtMznKDHUoDAuK2Wu6/FF5HTp6ecEvjXaBVfY8X6ue6cPoXWcdZCzmy9UmCFm65zqwabrpUKAc+I0s34YnalZBwkHPkcNzzMXAL8Dy5q01tgyMVjpOkWS1ScKx0lmvWMIZuC7SW0iRAIltssdt+k6eOONFoW7qGAd/sHKNZJc5xulkqkvQCb11oBY7lFwzUsK2rAFls+Y2uvmooChyPVJOLyYpFGj0XMjUFPmtYThTadNy3Pr0/uUGUpBjJnBRaSQQjB3cdkSRIHYrzewIE7WqM4elbNCSqnYoWpo+LlnLJO1VosEcMLl27up7fk/CuL+uof2pQJtuV2en5zeWn9dMJXAPUy+RuXwO0ZPLK5qvN/7PCPAnddGXxCAjcCNFyA/yMOTqKYlbFVVKBsCjce1Qwo7OVaLZfl7IcSeYNyGoV6xsXN2gDKojz4BjFbEQ3Dh/6Q6xgq7r7mKSJkFaiLwC0NAY4+vH69c3RUKarF4CK7Ew71tDBJV4JHxJBiBP1TtB7Cu0OzlRHjlHBNgEoaHqNku7KyW+6unrDsTvUD3qnFqmLo4UWc/nOOLERRI0ZZPF3rpCOGJsGWkLbGaXtOpkgWdDWGQw1wy770sBlBPDwoci4xt4Z74edaQcEqq4P8WFZNcFKa55hNxKvgaeiMlIn+DRk1MQpwcBviweoOki4gY4Q+NpMLwUBGQsrot0dzufVSuXSC2gcXFwmUyuglJuUc4EnTGpnoBdWuiXgCkYepIyJ3WZu6vXoYz5MlZ4oLNECVuKFLHJ2LOxkxNpNV0eS1BK12ZvjqDxs/dvTDYo2pEVrJh0xFHeYCDmkKuf21qTrAXEEnmKr648yVIJ5SgSlr5NVmhcdKhusqLier10UrZhr0sSF+Nch9YUkPhp3LjuDJCWYsldc4h06EdrWtP90+eH388f1OAn3blAGs8rNdhz/8Q8m2kCvtbDu9gCt75i5//f/NXUtv4zYQvu+vCLaHbYHtLtA9tUUPsi0nAmRJ0MOIFwUMbcwaKmzJsOzEadH/Xn4zJEVKihP01JNnPlI0H8Ph8DWsDt9z1I83f+/Eo9j9cvPzP5b9ULbwEpQ+uRtp9kGZwfZAX+mcD8M5FM2ht39Ji4Uz9sP10XHM5jKbBLyoi+F87WwTdGu6o2Wwl68tK0W3oOgr05FUXlqXfd1EfIOR+KqZ+AZD8c2morHvBmu4N1fNtZvu7TGZ3hs+dv+Ui27VKPao8ZYHrmqTPaZmGr1b7s5KypVJwjDlbtowDBuZSIy/WPffjDWZrCWA2KWsjvbO8Es3zP9/y6LXa8HUAe/TcxW0ZxiEf8ho76/den7dGJAKbzQWneR5/0oSvCDxQR9u+h3Opj/8+k5c6IQJ5Mvblce9Oqj9seNP2DNsDQBvL1A9M8GPz+jIljshXPlXx2ZlFVqhX5t6+J008Mg4Tcpa7Eag6x9YobfwooQocop/PGVCth9x8EHBftGyY7PbGSwr9we8GUR8jYMMuAHeY3EhfASalK0YgdUtcl8Kz3MvOBOHUlrhjf1/Kjoh/S5J4Lk9NfsV+w0CgEMzpp7AZGKLo4UdqwoNJj9KSRTHHturTq4YFEcOjADgJLkX54VGvcUl/OrBu1Q2a7KnefcbtNEwqcHZBQLP39QPMqlIHK4CGdSH82leid1G+VgCGIqtqDcd1SsHgyaDFtuLyJfzO2oQLHXD5cvlCzE8/zSpLqp6UV46SnVEAFH5WG21CBiml3gk9YTV4gmcnhliTpSsuqSUuktVRVeVqNifXAh+mS3kWf+bSl2isvvLvy4p86Rn4KMuO4kDADihkMIKR+pcBgeg6zNdgyFsw1mnR4MIG6qKIlAHYh0GIijTK/etCzfNTpTud9R7HWTWnKXJGfXi+fV57wBKJB1MV5ABuMmTxs0H7wc4EO9MAVoK2LEkDstKPCUN1E+nN+91FyE3D73agPGmf5Va0Ox65i+Dqb+eFNmqj0Vxvp7HRTTrAuJiEvprDys+BvTv77wiy/0u2jwIx74OoqUXBrO1l94WCz/KBwGc/AAORqKGcXQ7ALM8DUbgwkkgXtM03AAL777/x4sg6kMoTRAFeSBT/GoVFXhWJEmc5g66XsSpv555uWfANJ9S9NT3Zl1dZ1nYy5BaUDN8Hiz8uOhKYFvhBlz6aRbEkcx6tvDy6R0HWAOmDWCMZF4JzWpyPLc0rq2M4EuqJkdMciazYcXPUgM6bLZKHxKbCjjTtwA7rpRhUe41y388c1zlEaR7EhF6SDRWOTEwOlI48d8YtlUUP5IFxAH4qS6GGtYGK+0xhRjVXdU4oNksmyWWzl+ZYZ+p6qF1mGzJQochZtJsng2jDnUSH1a1kG1xLDcVdI6p8IUoW2k7MU2zGCIjXnYjOhGcWVn2U1lvVYxOga/gpGbO1B5P/UmtsMBdOkLQht3fEdtJBCuYOb0OwgBZvH796HJ3cu5LCDbiuLnld3dq4NA+YjSdNdIMOOlKZU+IioRzGSLV1TeipcbJ/Wm+9sLQ4SM/d/k48h2gyCbMz4tomssOMPOzaRokeZzq7k/hY0oRliyJl+Fcuxaw7ikjViW7vZIzKKYIGvi7BPrtfDrxJw/lAWYyDUHiBI9AHOOhMx+ZpdmCbBPDGZKdE4FxvU0O7Z0xb5SE2+MY/N7hsuLIELp1S2H5DwWrDQPlfQskHBVpWs6ouamprEDIs+o96b1j+QS9oON2b92AY6+WZEwO88SBc2nGvRgobbyHCtdLXozRWj37Ag2YKFeIAJ49V1Iwbfr8+Tt1QGJRHg5S7Is0/O35EU/u/Ygp16c/20/78vDuX+/btWHjWRMA";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.DEFAULT_PROTOCOL = YV4W_installer.HTTPS;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "443";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string")
          this.DEFAULTADDR = options["addr"];
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = constants.WindowHeaderFontSize.toString() + "px";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    if (!await info.makeRequest()) {
      let err = "Cannot connect to Hub\n\n" + url + '.\n\nClick on the "prev" button, make sure the server is up, protocol, path, username and password are correct and try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < 43805) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version 43805";
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHub_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
