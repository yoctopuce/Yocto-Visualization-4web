/* Yocto-Visualization-4web installer (version 1.10.52180) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (!(data[0].x < end) && data[count - 1].x > start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 30 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.currPos = 0;
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    if (!this._hubAdded) {
      await this.signalHubConnected();
    }
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    this.notbynOpenTimeout = null;
    if (this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().catch((e) => {
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open");
                  this.imm_disconnectNow();
                }
              }, 6e4);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: multipart/form-data, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("WS: closing stalled connection");
        hub.imm_disconnectNow();
      }
    }, 6e4);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      hub.notifCarryOver = "";
    }
    nrows--;
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        hub.notifPos = -1;
      }
      hub.currPos += ev.length + 1;
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.52180";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(0, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    await this.HandleEvents(errmsg);
    while (this.GetTickCount() < end) {
      await this._microSleep_internal();
      await this.HandleEvents(errmsg);
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    this._setTimeout_internal(callback, this.GetTickCount() + ms_timeout, args);
    return YAPI_SUCCESS;
  }
  _setTimeout_internal(callback, endtime, args) {
    let delay = endtime - YAPI.GetTickCount();
    if (delay < 0) {
      callback.apply(null, args);
    } else if (delay < 100) {
      this.Sleep(delay).then(() => {
        this._setTimeout_internal(callback, endtime, args);
      });
    } else {
      this.UpdateDeviceList().then(() => {
        this.Sleep(90).then(() => {
          this._setTimeout_internal(callback, endtime, args);
        });
      });
    }
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos >= 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                }
                let newlen = xmlHttpRequest.responseText.length;
                if (newlen > this.currPos) {
                  this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.currPos = 0;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.52180";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.dataLoggerFeature = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.globalDataLoadProgress = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  getGetaLoadProgress() {
    return this.globalDataLoadProgress;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].startDataPreload(this);
      }
    }
    this.globalDataLoadProgress = this.recordedDataLoadProgress;
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows )");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = 0;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.globalDataLoadProgress = 100;
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (this.globalDataLoadProgress != this.recordedDataLoadProgress) {
        this.globalDataLoadProgress = this.recordedDataLoadProgress;
        this.reportDataloggerLoadProgress(this.globalDataLoadProgress);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
        this.load_ProgressChanged();
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        console.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec");
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      this.globalDataLoadProgress = 100;
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows )");
    this.loadDone = true;
    this.globalDataLoadProgress = 100;
    if (this.previewMinData.length <= 0) {
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].DataLoggerProgress();
        }
      }
      return;
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
        this.FormsToNotify[i].DataLoggerProgress();
      }
    }
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this.preloadDone = false;
    this.loadDone = false;
    this._loadProcessIsBusy = false;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  load_ProgressChanged() {
    for (let i = 0; i < this.FormsToNotify.length; i++)
      if (this.FormsToNotify[i] instanceof graphWidget)
        this.FormsToNotify[i].DataLoggerProgress();
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    if (this.curData.length > 0) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.loadDatalogger(start, end);
      }
    } else {
      this.loadDatalogger(0, await dt.get_timeUTC());
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    if (M != null) {
      this._online = true;
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorValuecallback(this, M);
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("--> Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
      logForm.log("UpdateDeviceList failed :" + err.msg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeWidth / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  showRecordedDatachanged() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  preLoadSensorData(value, index) {
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    debugger;
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  startDataPreload(source) {
    if (!this.prop.Graph_showRecordedData) {
      this.dataloggerProgress.enabled = false;
      return;
    }
    this.dataloggerProgress.enabled = true;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  showRecordedDatachanged() {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      this.SourceChanged(s.DataSource_source, i);
    }
  }
  DataLoggerProgress() {
    let progress = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData) {
      this.dataloggerProgress.enabled = false;
      return;
    }
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (!(s.DataSource_source instanceof NullYSensor)) {
          progress += s.DataSource_source.getGetaLoadProgress();
          sensorCount++;
        }
      }
    }
    if (progress < 100 * sensorCount && sensorCount > 0) {
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (progress / sensorCount).toFixed(0) + "%)";
    } else {
      this.dataloggerProgress.enabled = false;
    }
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    this.dataloggerProgress.enabled = false;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (s.DataSource_source == Source) {
          let index = parseInt(name.substring(12));
          this.SourceChanged(Source, index);
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this.ownerForm.showRecordedDatachanged();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "H4sIAAAAAAACA+y9+3sbN64w/Hv/ionOOa2UyLIkX3JxnD6Ondv75uLXdrvxZvvlGUtjaVpJo52RL+o2//tH8AqS4MzIcZLu2e6zjSURAEGQBEEQBNfvRqfZYJGt/ZwWF/Ek/T1epNlsbfMqOYuaz4773d79KE/i4Vo2myyjXqfX7Wz1ew+6rWgturq66iwBeX4xSDqDbBrdXf9ufT3Kzn5dz4eAsH6UzIZJnuTrpwfxIlbf9rPpNJt1fi2+u4zz6OeEkcg3ot1oMImLIvrXd1E0yGbFIr+Agmbcjs7a0aDFC6JoMU6LTsyg4x3z/Yx9P0PfB0ANvn9i/xUL1qhB9DzPpu9P97MsHzav29FSEcyTxUU+i2bJlWKFF7ejXktRmF5MFul8sny6fNOcluBNGWN3FYf3oinj665iEL4O1NdBm30b2rCJDXtuwY5s2LENm2pYguW3zVkJy5Lo3WjWVhTNZ+B3pknuDYc/Ny+rad2LLjtx2/B32TnT9OCbYfL44ox1czxY1KK7ZtFds+iuWXQX2WGWzhbPmwRRWSJoKmouZhCRxvu0w0fym3iRp9cb15VjuR0N21HSjs7b0agdjdtRyj5P4lFxs0Euvw/Z9yH6nrDvCfp+zr6fo+8j9n2Evo/Z9zH6nrLvqfienkdNVv1u1I2+/z4a6k8xfOrBp0R/SvWnkYYb80+qdZFobPTHrhFZ5zn76ePJ0d7b49d7J6/evd2RoFD1QBM6F4RkWZjQq4Nnb09enZwKKp9Qo4qTPJ4VE67nWAObgsL3JZy0ojusTiyY4tUwmS3SxbKEgOLAYAMXg0k2S/TomiQL3oJI04fW+ny2kNjqSA1RUZxWkLDlhUa9hnNGflsrJzH25N9E/j2Xf0fy71j+lQNdz7cRk8AwWST5NJ3FaN5NxO97TDJyLN9Vg3JNjVb5ixzSEuOpwhh6GCMaY9/DGHsYiSUXrTM5h/eiNa04OQP3jPIE8ripC+jTeVaYIVDSVbI201OsPxSM+LHZqttfQ6c/zpz+Gjv9eW76yxkpb9+9fUasMkiDl4/hkH4fWOvGuVo3en4TvaXrki86uhMu+aqj++DSDFIbNrFhzy3YkQ07tmFTAdtyTAzGneyYoKInFhbTZSXLQ1kvmNqVvBPJRnZ+XiSL9+1IfDglFE8dXSLJaC0sqVm6+OaKpdeOuorD9/xzTzPMv4pfLL1hmnyULUx792ajSXKQjFQ71XfRznHn8BXrOP3jesQs2RLGOMogKwzZdrTGfyzSGf6x246on9coAl3UpHqdejyIJ6qB+1lyXjqEAABV4nytXaerZ8qq7NkVlFSmBkP0R9lya2yx/eNjt+rGVHDUUFMx7iyyY/bTbMRA70WNti4ZBkvOgiVJsGQQLDl3SloN0wL9u92IPyKL/+fpdTJs9jl2ZHFJlwzckj+gyF1Hoh9ZyatG9ChqNDjYP2ao3mGQehIsOS+tFxtWUPVJqOpRsIJwSepV/Y9Zo3R/Vr2ysg2ZMMeMppuGoYXkXQSi7UxBTkvXPmtFd1W2XgynZjEWG8LqxZ4pt6m9FsIuE62FU20ACNgzGzaxYccW7MCGPbdhU7TGTu01FvFwbvEwtHlIbB7OLR6GNg+JzcO5xcPI5mFs85BaPIxsHsY2D6nFw8jmYWzzkCoeyjQsGIHp7DLJb9sErGV0lQ68NWUAig9quEkrWRvJxlg3FfNyZAssxnl2pVR1NIhns2wRnSWi5Ytk2NipaeRrJ8iYNvLPPIwBjbHvYZx7GImFcRDeSGiuRhbGM4URh7myMZ57GD5XQwvjRXizktB1vPTq0BhnNMYrDyPxMIYluoh36TpQYmOJ95b8wvsBFRyggme44DkqeIELXqKCV+pz2XybZGbxBUdMNkk68BtvhFmejR+HICZ25yFTZjfqeYXImmHlfeEdOn02u5haniFpbp3n2VQywlhcxOksydvRZTy5SLC9Pme4785+ZZufDtMi765mh3k2Z9Np+TaeJoVBlfP2PMujJuClnH/253E070yS2WgxZt/u3TPeGJjC8w/pLzCHRbXavyI7WBP/wMt/sd0qfLLz5sFyzSH4Ep0WEUz8mK/imgQv4kANx+4s0rMJkwJuC2p/nhSsJR9+2flKEjFtBtn8wpQXY3M2SLJz0ZWvFsnUYICois78ohi7iC3lyfqEhCblynAsD6ImHPQgcsGxTeHFNJ6BYz4+m7CvnsD4+P4oukJ2KnJgfTSdsWtwMYBFH/yC+LvqNjRwrdEqG8cb00FATt1qjFsOkoDFjNqDpq3tRSoGeTqHVY9GJpsAmGzYyXFHNkCPSod92/f7c5pcHWb54jhZLAA62IFWD706en0d2c5F9tPS+en3LJteE7+5cK+ncT5KZ86vR+SvJ+SvT8lf/5YOF2Pnt5dJOhovnB/34zkTHIyX83hSJHarZOHxIs7BlUAh8rJTp+xdnjKW4sn7veu0eOMxZxfH14FiQtKqiBabKv07Fr6ZqM/ZMAj28TzOmY2mjrvYapXmTEkd8l/bbLz9Ds4dRmB/HM9GyX48mZzFg9/suXtRJDkcmrFKZheTCZ6cPioBNGM6kP3c2MvTeNLAJekinqQDopM+nmWTIfX7IJtkoCpO9+FD5+mEVYnL4wkzCmfMlNyXgBTHxM9nOdOX8DuzH06Ps0k6fAq/NHE9LYxgC5Zh2j9gUCxzOBhBXytlSfz4I/XjI69F0LeyQbAYMYXA9FE8afLff+Rdz7B63bZV3DlKoOToglknz1+9f3bQjtwhBOTlNoQBMxOJcWPpPzVeaOWnSvWKizEs5e2NPr14aE2LREnX5gobMDXXzSK7yAdOfd4AgRVYAML5CfxuNhf+SOgYaTJx/gwci64aqtpwA2Bq0IxDCRYRhyTEIyeXu66aNnKGwyO3kyfDPL6yV7BxXCimSeaEjIyQzPr1e6A5UNKx+q9Q8FajQNjCVnjs7eJgKB8BV8/ynKm2xjEM4elFwTd0cTTPinSRXibSopNtVoYHd4Dm2cVs2Ox1u+A0F9WusynQdedNJ2SukGLVG15qCpNDxofjBFbtJqE+aYGLMixsCe2J21LFd3Ztc9/T1EgiZTKp0QrBmWoLKHy6JVCC28EhA63gy0aoDXJN+VIt4EsT3QRehNsgYAONEGtcqBVqBfSbYRYxrbtWboS9ftKtsWFwsxzsQPucNTrUUG8p/zIthrkotm5hRczWS/TlETZl9Pjl5gIxIgWHlBYI2RwhKQEFzYlT/AiPjtYOMYuAtKurX814KElRpbOZuux27m+56M+zfD+eXcZ18HudnoU/Xkwn+9nQWy5sdfRj1JCfjAcfT3VWzv+aUl5oMeecicyvjSsfrbLKmoZF5XnQnIbBwszmhb0GXzkG+0d3i/KRbdssnwH6dZ+tSQsKntzXfDxP82JBFcOQ4+uyWnGc6WThACCXEu+Z/pY9d/w6PBJmQGgTadFJ2WS7fnfebPxjxvriMQ6z8QRRLH7ZocqUOHraVxElbA8QJMSqLeaTdCEqLSWJflK+Fs8fooYnh6KHNS/acWF5JSUIvBxjcSG/1hINGFp2T7i1lqHSWOMSDEs9XMFOm4a7wipfwBGG6ZVrsBemegJ8bIOr6XiSXEslzibwy7Rkp0vQVFacNYE8045X5lfUOV4Wi2R6kJzHF5OFUtMeWLPborFTOGh/mi4Ok/wwvU4mL/J0+DwtIdSrSShMoU9T2Jst0r1JGheVLGxUEAhjbtKY+5Mkzk+W86Sy6q2WUsDTLGM9NRu9YavDl+ptq5LOK7ZMsNVXL8W4sLnG+8VGcAaFjdD14V+yUX88T5JAFT0a4/9BGDSP7CNw+j7O22yW0MAbPrDXpzbGpu4OvnQ+vUgnQ+GjrXYlfmQ/g79H20d78znra9B1zcKHvMeUuDiYdxBCwDuW0T1bJGELZpE7qztvDTMNpnFYkwwm6dyumQlqNJsm/joNbQoWnvNqnvOgTKfoJE+nU8aJ+ztUDYvf9saDTeJ3+INbr6umm6+LsQo2OMQcwm3xvC1WY+kaLRBcq41L1OxK0qv9uZFmyCmhAXDNGI+o1+4kr1bVUXSVqhTXpzGIylC3E2ud2ufQozItXhaTtozbhM3NYNmO8o/jdjT6WLSjs4+sMC0O2UYnOWeyHFo1jwtmbPMj7zSbHQg94fpW89FZJQyu3Rm7ufPdHdtnznfXRnbnyMSdG8qNbHmQYRsxEAuFOKzOpvOLRfLy5M1rsbvYKRcCl6oVUP3y+LXqCLfQaT3+anm1US9wKvjrLuCpbSzYzbwSx1gH2eQfx5ZVDvJhPW39BjJiHW/9xlrZZ12pt7q2+ay7yiU/IsifEeSpUWIa9GnVrlndETrnwqzrDkVnuiONDD3B+7iwNuzS1//RBdK7dy3FMGT0r09KXBPZrKL8bFjQ0jsX6miYU6GPhzHnHzicd0Is6COMMP+IgjpiMT/trESgY/oJLAz5s6HxKXwUHSJO3KKiznxBePyHn5gVof1GnUXGv+/HhdYK/OSedcbbFXuJPL5XdEoCGxQIE4TNjg534L8FehejV/awJUobtbwPtANetgNYuw+BhOLHgt+TakJMbctvQ+O/GoYNHikhDsaK5JVa9RWFXjvqtxiV7RaeL6Mg/AYJfxaE3/LgUYSQEEuTr24MbosB5zzC/ay1UyGLXt/uVFcsm5RYjl48fdTAHTThztL5OA7yv+nxXyXR7QBGWKYPAhhhqcJxoYcSFCxvoStavSTVlh5bkW9LeuOVpVesLL3J50oPllMtPGbfMetuUha6g0/hpG4cJ9fmFoxqxqXxhGoOuOdODe/HbHg7cZqNLjhLC8uhXASDylHopzKjTL8pirw7wY8r9Tzw6plX4Kp1y8fUjwX146TVovS9YwvdVP3faAEQ1WUM/ig5n8h6JN12hBW0M5zg0C3bsRaEQUeOfhUdyb8xHT2Acw79M3zmP47yJJnpn8U3XnDGnSMqHtUKt9P9hVkrGYRCx92kW3PqxxH14xnVrfpA4nJEnSc0wBbWDv/cvTphB/wHis6C1ypGShOFjzKsTcM6LDYtfYFgw73vIo130ByLZDpniyT86Ys/G9Y0gx+iJ2zG3u86c1agMkZ7/fstUWX05Il1r1MgR5vOYiZ+BzXAMF0NxUv7IbKRYDHiDEGQLnzb8ceJZO4uR7+niAr4Xov93tyGyF7R3HvRRn8LVtz1aHur2zf1AUm90UFqjlPZsb727a8bFTtee3Omdl7WlWG9hxK6xttGET+feT8LcbjWhtzVyR4wNXIhKRIgJCE9qQHpnZ7EUTQ1tJT9mqEmCqwdHO+k3Wir11XlE9lJUp6qt+V+9V70YMsfXzDYndEh/q5BkeM8ULO9fApQtX9GxaMVK9adNIa592DL7iMkkDUtEKJfLMGx+eJtns9uylbuNF4JV7daQ44IyBEJeUZAnhlIfplc7u2PX1vT8Ui1MzeTUN8bQKH+5haF+e2l+XhsPr42H6c8wvKIMfci+pH9fRS9QIU8ivKIrctE4SDLISpMXLvvohsH6WVaZK4ji3Ib2VriKeOBcaMEJBh7issfA0O6nPMmy1/DFAWMe/x3Nhy4bnUUNie5y4n4nqKu5yfqel6i12G9Y0nDsEKx8drTTMeAA+rkrkBdE6j3EFUghMkaks7MCNIS6sqhCKppDRO2KPst27DJCjjT431WbOBNk4+43FnnajZfYgHDCH+hvrww3Yr2OC9ICg+2MNYRpveUlM5LsbS6K8YR6KEXmPY9I8Uj1tgXfm+oVgd7ghMRUlekXrDPRy2vGwhSmrWXtt54Ga052uXYBjh2tc9ru/w1Ltej/6XjQz52fMivrePvC/uy2x16hluqDus2P7DGjqmJWUFsBf7fTi12vMEFG8AQ7Li85VqsWM4cBX8a8p7J1CrxPWPaOabNtyC3SX1khWJNyF6+MfEzz9onPdXucYDjqtwD6sgb4t9jd5wntuPEpcb4bSL3QJCadCbYjgQdQFrgFRs3xmzgbXi2y3Ph7wQQkn9exJPmoJZvgPfSABe5uw90EqU2wWwyQ7CT6D7iqhiBYiaoxjQ/1SFg5p4mYH6qQ0Ds1e/gnXsZmqOYBY3VxARugDvGJVAHRbgI7mCHQR007k64Q7oTbk8g1lDNzSmPnc+IGm3flTvcvEnsJKRRlx4mKiENPmzdKZ/MIdp5IBmOR9vMQFMQCPxGEK55ro/ekI0eK9vbd1QYyzgnDPkRYcifOYY8csLE3AuT64QVI/3pTH+KkWfEd7SEQkbt40YT5CP2T3uTdJA8FVFAAd9/fxMcs5sP5FcYDi2DP1uk/7xI/jZOF2UktoDEBnzq+SSYJgyjdjUJEnEa5+mspGZmjisCvb5H4HdxCa604YHKnybpqBRX/9Pverhp8c9SifN/+kzivYfbHvJE3iMLykv838OaDcbJcG8yzWbDqqp5T3X9NpeOk67pLB/t5zSbJIuSftpgrd2EY6y+3+I8u5qVoG6zfzb74j8H8yKfLP+WZWUN7jOs3oNNYMHjfD+Ga/GlrX4IHGxBV217Qt8fx/kiTy6KWgOUQM8GGSR+KOEeDk160FMbPnqWx5OKnua1P6BQZ+eT7CrJyxvf60L1mw9hyNyniBTp5LeqwcY1iz9J9vN0WmSzsp6D4cb+IwS/jGc3UikHcf5bnVHe23hIoVbWy/ECyC+yyTCZ5WWDVY5T+KdHksjjZdlEeYj/odD5SUgZ/11KuQDu/x3Hv6VlnEO1DzaAxH0K/008SmaLuExDPCwT/btJeplUNODBlqx+k2ThXQ53zqpmzGZIAu/ywTgt67wt1nq+EHY3KfyjZFjderLm4xi0egnjGyB3qLrX75MEkrhCdD3Qzb0HD+QnggQoqvKpc5/Vvd0L9iCnUD6Cod/uPxT/+QROLvJ/XmRpUT57+104zO6SFCpXKdBVQIOYfkkyP0xnldqOK8z7FPbxb8tK1dN72KP1VjqtmPtd6x8HOxuOqlT9Bmd8k6z9eZonZ3laZpb07jPJgeLa8Mb+8wksVJUWpDYjN7058DzLk2JRMYK51oSRR3BwMRgXaVxRO23cvIjTWXGW5VnVQqX/cfDHWbGoajxfIgMW+Atxb7NUbj3KvKix3vR7D6R9teHpjYrxxq1X/Y+LWrnO9B9QHAPeaTJhlknZSNtA2sIm8JJtgpfD5KqWze+Ps5fZosYUF7PMN6pezYZpPCvV8tzmftgX//nYo5JBdl8ZGH69l1m+rJxZdIsrVnUhLaEaPNzX8SW/w1K2Lil0PrNpdKaWzD3QoA3Zlbstl8bVrGph63Od1ieG2+uErar74/T8vHRxNZrJ16yv4UJXhQ3Nx2tvW0qCwK8y5De74akmCJSapf3+Ztgg5vhaU1TNPSEG/k+Pbku51uDrqvmHxK8wU6AtGw/kJ4JAnQn8ALaEDzdI/EpbS1jatK0lKFQaW6Bs+YLZu09LsdJU6Ikd/DY9sziJamur1+OblW1pulJEFkkyqRre29KN0Q/Io3pQbeGR6lKYJtU7vS6FVtEJekZTApwls6pZoFWjjVu5zymxNd7EeZbNKhZdapPwJhmmF9Na/rJuXzabGHuCTC0vkK8KBXLlJunBttinEQpAUDi8yOeTshbAst8DZ1+/95AmUT0D+fyFXUavtxGgUb3f6fX5dldpJJLKHOLmqu0hPqR6W5s0lRobn/t9uekhNp+CiNj7lG9CHwIBvoPzpZIOZ9WLXV/+1/OdsW/S2WI/T+JplVNVTzEXv1gsj7Kill+13/fHZzYYxEU6q+WWfeANzrfxZfxrVmsXwz2O9zcICstKv5O/wr+bDF/Hg9JKN5TofHXE3SZ1zHga8yCPz8qUCUxFcMv6rtV6zpZtSnkL1HJDmk/ihyRyuQISWx6hPryZchhPkjrbJpjufbGKd0kaFVYMmKP9rZ785OPXmPC9+4aRBxSNGvOdK1AuC8JlcRjP42XMBvy88jSBaw1vvB8m8WB8eHF+Xrl75TNuy8fPLyq2UlxPbfs117ABH3KF6aNOLsoUFFeO2135yUHNroaVDvX728og9+dq5con5ymhJKonC2U2MG26rDp80S5Bwi94lC3jCvNwW22YCY18HA+Hk6SKARhd3Kf90MevMtX1xsmf6sfxbFjV+D7sMXrb7B//mK7axtjcltw/uE8gH4+ZWVy57d0ip/dxmsxmZa50GKGwyfF3zMfp5LJsy87nhfnHQV5hW+KvCHUsKkB9SNuXtTY0fdXh/u7weFZjE0K7KupbcerIzcGv3kbdV74dwrF0Urq77ykkwkVzkpQ5FkrcCidjZm1NSg8mt5W3uufNjZNsGi+yCmGDrXnfU6InOgyDdtN3vU2jg1+9csJ8Fiq467W76oBAuB6EW8tD/ts4iRdV1q0wDh/6uHXc43SbOe7xNPutXryCrxTq79C7NGqlvbMZ3GtTt8jFlT6eFeKpzBIXyFUCKX0LyCMNcSoxJHRxLsRnONNLMJ/uAMX8L+dwq9glCyFajYuZ5LThphez63GR/bR7CD5w798A7KycZVHne9FZ9bQEk+tFMhsWSrD/0rDg84hzpl+HbHFZVCA5vcBm8UDfpSou5gn81vIEDVdqBj3vZ7imM+h7reyVNLPnQfdLoPu2VA75UA0MKHEhkSEPfpslRVE1vjSgydlWL1NzxcAsIAH3fjx3ybJuIH6FZGe/ZnxrC63j/qv/w76zPfPCTsaM+dWfKb4N4JOoG/0ohBw9inw1/e8ydUBIfwundbOkoSPaFznTqseL5SQpGV8dFZq3c8N8qKq3qZQeaCR4+eTEaKCw9DjxcNRYobDQOLIT9DTPL2b80kMTxpec6hOZ2AhGGkAaIPWr1gn6hw/mU4MPzgbk2ujCP/L7ThjhaXKZTDhCjyOI7yUIR5DwmCP0OYL4vlPB0v4knc8TgbdhOFM/c6G0dBvlnOvrSRf98UfUdH6CxCjwtgnD4+pHgegCrpiOksEihnR3QfUk3kO+akdjq+PgwtU1msVgIuOcPLC0X1EPzGqlyBOhlqebey+fiTi1qn6vxsp7dAmGl5yqklN0bxVX9/zz6iOrsmoZiMcMDuM8nsJrScVxsqiXw01iQuo+6F/8ZrZ6IgHKOsc/v9jxsJ5nMllcY73hl6o3HHrd/qZfqlOO0sUHh/Am0MNtq5kvklmSp4PDeMazI5a9hGC/gFD7nYNkBjqZfJFgDrVCPkOevQyugyFuOrqg8/rZ8xNrIWIlXjqrs5F+t6DKEGW705b9YkI+hAfNy1ddARVctOfxcCjyk/XsNIpwa2YQT96o9yns4nGWp7/DayQhgLPRUy9Ts6xRmM31Xmmo+ZJC4G0GqgKQMs/8rYaHeN2A7Wx0KvB/l2cNRnw95OOURpKF9vop4AOZutWwD6XoNtOCyM3tZOAeQCrQ/RhCtEWijaJ500zr9pSjG2vDWAnEbGyib7wpjVrnCadVtw36YSFGOGCBsRLMKYck+JOqw3tLqbbEP78RUlEFMvaPvMzwCp5ojdF5XoMotXELvBtNGXpxQAPYDw8YPKodlgL2O8dRdLfVDq3Ly9ri2fYFgR96iMN7TfEpR0Q7pOAjHOVLz80H8JcSqVz/QiqFF9q6RMDXFZ37hMmhXG+rXjFxV+dvOfVtWyDwPJoFgyXmYFN5nF1b41a1r2uqBC6TOVBWDnOXApXN3DeIbrUVUjFS700olUm+OGH0KfnmhFTF5PsRAtWaLM4dbjQp6ScI5sZFyrZ+TU9ttmlNoR2m/v1PRXbHedAj/GwRsaPHBrvcsIstxEvdi9wQOMwK/SiidgjqX8zLnis+kKgchjS4z4NjEFncd0pY3i1pz05Jm+22cqahXh+Qb3FkB4erajYADNJrvU7OF0LBEbT2n709eXZUg5oABHr7bNYkeZDi0asXL+uwx+GA3hHsRAW5KiGTwjVC/VmqtG83jFwOSgdRkN3dYEvCbQ0MHxesc/LuUHZOqI5mg8FAx5xkc9EtHhFr1ITp0GPGo/b03cnJuzeV1AQYUHuaLRbZlBoynlR8URoR6q3H1x8nuurSAeIzuOszTbQnMBZsJ4mUt0ePUhwG0+p5ApfucoOPtQOBXq0U8H4R7Ts/taz1hTs+HX+VcYC+YatdPEpsR5aSmYW1indL9DcJ4TmyXua/k36soIb2KPyc056wwFzdcff1ioOSbb0C8Xb1Gje0qUfNu1V7zGp5CecKxONc44Y4R2K9Jc6l83RvNssWPP/Jtxl2GbP3J/ykxnet8r1QNnt3fs4EBY7vrW64/NQv/8ojmi1PeFDIltHDQRbigaDgvc3kHbGb/P57ul11G+YQMM2qN1M9a/4msrGfCDB9/9mugBpz1B5NgVlqA1nz1MGnZqo3YL/lRt2ZHnUafBpu8Gl1g0+/dYO/zPphUojpAavy4f87T76SBfHb9Nztr5+r9FxoL/G5WpfsuRUWJW55BnqPNgq+Yu9JG+LvIivq6k/Q1z6AZUJJQkeITqTRkTji0u7EtEjPJtRjRh9FIlbLZBC5W50noT/v2BE/Cf/5J3xf5xQyhxeR+WiR9ajqdT8Qnj/UR5Tz0epC0v0YfLxWo+7c3nvLwdeUywacbqwcVas7zwVewGsuCi13uYSn/OR6YFfNfZcRRhjG/pv4usn+tHFyWp5smE0LK6ExfXbxhoENYtg9wMnFKE/iBT8Uimc8A7J9dCGm2jSd+ZON/YszgaORd0syn4a8/FPbsT9NZ6GDnCe7iGW2ItyxI2KEMPfHyeC3AxG+N8Rq/wbSM08WQJXe+wMtf0GYptQy8CXEyYYNLU7RkVqcDC50LraLmL4dcTKZhcTJ6sDiTGe1xMnH5hcVpwoFy7N5xpPSxpPygLA26OX09+ToAlx1ZetqW2nwyeRpPPjNVhy8iFhH8+Rcx2Y5v5uoLKfgZ/m+Kv6d83q8EEn87BevDf+sCDecrdqqpPP81ftnBzv17ALVFqu5Ky7KwbdiSa7Nl9VNBFC8TGg8+K90/7o3HL5NrrCATjJ4mZyLm4+3f7vQJE4qsO65IboC9pJ+3/eyQqDGIBGD4w5ljPAiX5Cmc2lO7c5X7CIsX5zhPreGlSsDhONMXj1J38SLcQe0bK9Nj6ILrjt/SmXQdys0qWsTUu+NtwJagOhOff4gJvjwkJlUbGjvZ8l5c8D+sVpnNEdnbsxCIVNqpnLGc4hpbjKTXb1UYjiClP5Qxbqx6G86Orx2ZHPfBEb8mye1KkJA9uPZD+BrmbejZDpfLCEWnuE3yAZ7UgIuPq9hMqm4GIy8W3K+vKiBxj+Jjm8D8/JH9kn8qN29V+liMI44tlmtB3GRBBX90bPXeyevfn528u5vrw5OXj4i3kQTY31dc7OzGt2Xz2D3TBGWg3/dtG5F0k/fERyLmcTsSLKGNtUiKq6hFxp1zZIOWHVqWE1E3e8qp7ajedquBqGHxa3MuvMsHyT7Y5gusLifsTFPbDxXoWlFfmARWJEfpse//hGsqds5g7W47RAs7hJ87xBtChzDuiaY3Kf7NJsNXg7HoTxbt9BV4YldQsiB5CesySTmEXCLLOKjqoS8mN+16AtQt4JxYs5zg9O8Fn0AJNmP4tkweonqCfWj1X/85NjaGsDJsbNXQFdn8AYquIv46dW+GovtaJKNnsuJ4JoYsEvZg2utPLa79zmbhFzydJLCw+cn2SJ2H/a2IfaZylq4XrnDmC0t5qBSqQJiP4AaRZTG9lln4e1PwjuNYTa4gKfpf4ZtXjpZLIVWej4gdlKu1iaBPo5gw+Lcz/HB3s0Ozib7k5Rq7bsZj0YIlH6comgCv6nHg7z/bDJl60SeXhPYrKzPYELlgb2JX89cAzJIDmPrc3pTt/ouMU/+yapf7M3SKe/h5yDTVwcE+WIWz4txtlDn3aFyNiBFoginnM+Mw5zZ5kw+STKTvWh7mPnRg+3WGE2ys3jyJmOD7E12mRwnC7MgqOHViYfDZ5fsw+u0WMDJQLMxBYQpQ2DapclMq90n6FHR0hqaiXk2Vn+q4in0njvSHQwEfdshYTpXUkuIJyLYWFclr2bsH7klCeCOlSahkdU2JDzx0TcEJHY1z7N8aregk12xfw9kF6ykMErnmHReHVkXWegxKB4/GQ5xBFAJRse7ooIRO25YVJiOuoUmx/AQVq3BJJ2fZXE+bFTUj06xrOprhVYQ9NBxlkWvJHSIplZ6ja6rEpT3eR697V6JmCFiuAMqB1a1bQTHdYDo2LfZUXLOVJY9nOk1oGlNXwqwCdoG3T5jc1A+VRfWEEJfNtrBmluuC5NzPBskoLcttkuXOZt70HCaqUsBny6WbGMKeTzg4W7pErXe7lbPEKEZod8TrmyoqWXA2VJNDnNteXfc2Uz7eFyoz3C0ia21PINwXdouDVsxf5R5AN4YRIdsESBruaAqiZInf5NkxFAOk1nhHP9RNgstCwoS+8xISoQzMmAleY5JSxEHzicwiNtH3spJChCBQXRPwvTWSF3EDkKeashT81hVEuc8hQTb4Qp7RRhajrfvpkYa3zuns+GzSQLzYu+syCYXi+RQhus0k4n1ODyXwXNwFthGDH/6Se5nAsXDa+cN1aX5fjVOmQnHKtN7c+vt9QKySsDFfMZodiWWef5O1VDkm0jMq/fcmrI5+f57QaCjYpDg1LkhmtLgh0qoWVgDcY6Zbs94zBLEEkf34FSgSJ5PsnjRFFTFHRQoxV4ajr/E+CfZPIzOCl1sW9bG0lJKULSVaJlqfQM2gkR5LPu44bT13uc29t5ntNYdPFR7uf3DTQCwzuSIJZxisJSLtAnN4XWbcWbpdmsmED4iZ6ZQ49EYYp51KwD27FlUuGdcpSM+otGRo7tiwiKxlojMkWtZc4Qs/EaUqoRKpSAAWFOSa/xQbqlkJjyMS56dhdq1stJACooU/QfO5C+d9w7Csgrh1CDAABNtfRzoX3kQsAYPO5sW86m5VloPvAVtMcdnYx0cxN8nq2lTtU5wKX5oLNQK1PjFbpIEhLxFs2xm6xRM6niR8wgO+NyZgpemuS6/3f1Hs9m51/pHa731gfFUzJnZ1gQHWWuHJOW5D8T/GHdRk48oPprYn8fRNvtz757NU2SREbMK6SnN7of0l5bFwSeHm3d5Okrlaiz+fZowJhJr9TXgehHXa7D4sHG90WEaS+ojzNuH7i9ti9kPffeHTfeHnvvDhvvD1i86g7InYL9Je+cLx7Xhrj16aAhkV9hyxi4KNZhcBNXhTn9LhkBOby+mZ8xQQp3ECTLxUBjLEoyei1HSh1bv8M6DrJqym9besYVl7d2ykpySXyk1IObQ+uTIOsioc5gh/ocUthjgIfSW26fuKK1H3sHyqIbkclPmOXaLUl58r8nZ7oL5M+Sv73ZxBR750q6RBoS7pOI8Mbxa0Kn37rkrK217WxW+GjJCbJ+q7BFFwlJnmGezTICOeyJ03dqat3X2qiV+7UwvJot0Plk+Xb5pokpA9zlbbn+XZFHCFpa1FyEsLGevQl8Bdzc0/Feb+RTe6Kaf+/VJKAbj4dC5yGQ9cqsyeLswItuPPh4Muf3kcmK7UbALQzKor/Mg91Cz5HBlbc0/HsVnL5X5I06yjC0DsyWuMBrEk0nRaJWT3rUCE5wGOU1AHq5v2BZgyvGohrkRk5a3ozSU6tIbx6GDjQ5XBu/OAeWxI7sgDh83lyaIhL+OhVl3oovcHkIek8AZWHMgP9jCCJ+YKXhFem5DNsEjrGkJ7zD8YeNjPokHSbPxj3/MwIxj/+IhBiBKQo3/blgyUo2U6Y3ElDTJqA+YXtZOSKrG/z7YO/1vVudMGPwH8bLZQjGcpahv3r09eYmQ37Cd0Lg++umzvSOE/ZyptNMkzusTePnuJ0zgZXYBHrPa3L96+9PJM8x+OmOm/woUjp/tv3t7gCgcJ4NsNiQpmKkbGj5ujIWssgxHDCg7qB/lueKnW68zNir1Xhcr7kt+UR4Orzc6z/Ns+v50P8vyYTPslmuXOOJaZvhNFd/ecmJWjClaSH9m05hJzIs0nHfew1AHq2TeOTUf30dP/HMt4UQR5+cSIQglw2icR+u1ve6uOPwmVMVRK3mDr/p41vK1Hgbgh82CDe0BkUSusgYycKeyLbI6ZKGQJ4yEng30SJCSOm6sRcrEkvH1CnT9Ip0mxSKezv1raWhBcHoauVSv6p2iAui45pkpcHAFwYlbMA55mOIWzUD4IBPqgzbLM/DZpUhfrE5vBjwGX/pwmo0BB1BLhoOnD4uv6GJ9Hjw2VY/U6d6LPJ6P00HRdLBEmlh4TQExzJMJg6Wf5NzzPhskHaYY9fKTL22DVaiR5kjmnJVGKVtEeawjCnQcJmcXo5FxsHHsSTZqNgQJyNuVgKHzKIK7CElHnkZY4X/CCxnPCx534/HIdgecf+RtB3uBCZrw9KkhADkEG/2hkrzCEBcCIeFuU7gNUPs0DHx4NWVc+rIFpFZFnA/3HPPWlIf7qB0WtCi+HKnGUCTXg0QEiRGM1XlW2Kealae1ueojtggtmIobsM7hK6OlbLvmkCwAbh2W3W4wubk9c2fXI+Bss8j5Wh52HvK1ldu3YtfqueNKkdgutGPxQEnD225bO6qd74KHyZ90F1l2Nle5dY+rbU1Yvq154pq5DnhwXXoc9VdD1MtQFWYoEspzvEsf+gA0zMQGL6XkX5cKB1/JOkiAJl4acVwE0sJqRNsLqR4ihCYWIY/ZJBHqdxBf6MhLa9RUh4uZvSo9JuvQ+KQtFOc2BqERytZ3TKHEICld9/X5Pp6aMDHljXB+sQ0uaECYuXc5o84NcjSv71SE7pkO+3pqp+wyimqy7yCrJzZ0H+R/rbjMbZOV5dP0cvb/LxRQExlRroQ8WFsY5VFgBIFmwY2QdpT4UqUjS2pFJgZDOEt2TZURnGXbJByWVjqAOJijRGX8V9n9NMJwIP2d1oaTDy1+dcQS7u0zKbyCPL5pbzY8yK5mkyweCpsbvcHQZvuL8/hisniesrHKVpl2hF9T0N/UhRzzWgJ2pvD9B3pzgG8u0eYRBf3AwKnadipjvMZeE7/eYO/27Xcd0HUhp8EKD/ar6pkdH4J8ZceDixqy1k4DBxhZb16UPXpx+PaFFWTj0Xd/uRc15rNRg4r0qV3p8c+rV1pcupV+crtEXubwhOsWk5Kt6ZmwKlS3REI1mnKyyqi2jwOsw2RSJA6qXY15skW1ZxzdlcMfl0np2QSvDDkhJ4xx202+ovlarYnuICj3AdXxAB0YD0Q9149CcH0++nfS2bNj3TFFk8a5alo6ac11Td95pKpXXiOkQc34OGMAv+3Uq4/N15L6WOkNqpRT/JGzO3FP0iSh6NHF7LcZvO8Kw63heZpmwvJ179igq6D1bsG21eJo3Q9F10ORVWTcYsITJ1lttFYxBdQWZd/Y6yIoDboh+418Ts4K66ef80G7TiCnrRfSBxjh6tCFGWJDqpZd7fML+QgtByF89Dfacksr+neQTeeM02S4ovjsS+OqHW4wJJ+9JdM6Nntq7ooU1+ZGoJY/DqUhA2IW8fI7OiqRo0NahL0Fs0vPLhZJszFmo6XR5jQqIBXlhmcS+Yg8LmmYFvMJfzNXhLLtuDeuzrLhshPP5/Bi3DidDJsS36M3gHt2piU2gZxf0aIIfKrnmLSS7DxntIuAhc+HwCiDRPcMyJyNj9hCKPCMG3KSFTQt5aMM3GWjHZYBYOy9DNEjTp7C1+isA6dhAm8QLjVHWuxC4rdzQ6SKbPkNm9D+SYQTvc2GiTU8XLgAuh/ub91fq3G3tepCqFv+ObcNiGtFobwldW8EWneK63m3hNv9vOSVS5xIAmGUuNQ+WhkixEV5sd6Ls5CP/P4tNcEcuIPsgqnDILR3+4+IX7IAAsFLVi/bkUvuoTFYIG+sizNskbtMk6tDtnbIxVx9tZNNBH0sTvWkZ8X4dyxg8KioFJRucLg+JnAx7Njtvcs4nQAFNdasxkRrUZ9Z0fOOekhnjX0mHkgyXDr0HkNGCxx16NWnM17oA0d5e9D2KvMSVuAaKyhS/o4otwNvFbVR500SF0xbygiOOb/I2WbNgRuLbYcvL3CzyelIC/zJbsjzAxdNOKA0ySnIsRwW338vKxfXJZ+wvYQTMjy3blOi/CS44G70UCQOsaJm+SbHIqaFh2+UuBGjUlp+NCre3phoZjaiVDdi+dxzBs29skGjKWnFZUlwZVrWHQqzAZrbF3BtUfONSdWFXHhL4ZElUqhq3qFePjL/s3Yjtes6spPwqMrcuYl6YG11Try9kaqmGa4Hhlq/lK59f2JZ2hvq+nJVb1DpmW22l7wr/Ee0VuqIwHMmfk22hlcCMt9WY4TshyXuB6qeVXpi1GEm/0S/Ffz+9OXfWBfIB6rakXgi2HRy26rH1u/e7MPnudJsZ2ukWxfbK9Svh+v6c530livs59w33+xtbzzYbAUHlHmMpWJE2Q+o2KIvzvkrzLxY7ui6Oy5ESWmNkea8olJZf7+0/v5NBhhRS6+0lt4K014nEtDjoHnNVXeJGofxzF1vbJSsAGsvPL22u3zgyz1ibIoBxQN5XCtALqxnYl4wa7MIHW/yiAb3djyzBd1NRYV12FZvWMDlpHT2syzElmw84MmRLKsnaEx6cfjl5qQLjg1KLTXNgJvlhIeIiFLKDXoLTJbwB/YTVaxfyNhVoqVMYwLzz24Xw0g9yQ60c0aM3ZIocxxprhHtkHO4NWOrSrcWG7m8MgJbbML9eHkN1AqpkJDhbmHXsN//slRrWqpiNpfMKDbhsI7qvJ6KlzofY/kyhdt19zERjbfr4tn8fPqT2tEry+mIllO/Sk5HtJz6q8npP8vKX7lzTuzOeannclXvnNi9gxA/cxh/nV3IyoJ6elNBPb0dQX35XVLI4CDMCJhB90grouO+aMVzurKFoWy6YQaX9Qif+oTJ9ruOrGt8zcwog64Lt/ThlhTcNdv/lbRsBdXrc/CkdIi3VpoQf22L/9oW/9tui2vuiD9zMxywrOvvieGctfCvs1mJJm3Xshc1g4GbKAO1HTWiPhzAFSKzM7aBeL6LE7ixKeI6eaaURhe2Leifjvqj/5oPXUjyUicfHFk/mSi0ChJypK31SgBOJYBJyW2BWjm5UXDN10/KjSp3LprYDHcoLncp3neohgUycztxTHLeEUSbDVbMX6JOF1Nm9jQhVFFsap3YpDIarBhoiHu3URMiDwWNcFvtNvptY0ZTsvh23carr9dxNqe7dAsCDazoPg7TOcn2J+n8KSRYdTrBqgISImhA/m61/mL1pyIKYTBV9ABGZG2fJKU9KlrjNN5rtFiui2/WrbL+Wv3q8robaESokeVdK4E6/zdJ5nYnOOSbDQCBPuCgGc+BE0/4eabVr4oiT7BfQVIk4VfZ+CtoKcdRJUGRe19TvRLG3G/ANo9DnUVxMWcqIlyV9ixV1iXT4+vKxtKdHKqttI+9vuW59O0M+ZBM382Zj7LpqzDNYCb9gbpiLKSi+B3OU+d9QSrxO/GbCoa10t7rSFj7Ncp56v6Uwn0BKht+XCwOk1mgJPSeJpQ9z2ZUznpIDc1v23KBWTyAvaWvOr9MSfRimmXs02z0JhsCv6fH+IfOgTBhdxz5CVm7EpTlgWvOEo47lZ8yy3yS8hdKG4ts3qDkfuXcZTGyH7s3VWQHsH9RDBER8Ug+TNlZZFD609HrZoP32jpcDLDil0YqJJnOq4tTwiSzppVUgJ8TWF0fuig692+DKpGBqJSSmJtvdnZIXgaBeb8lPO/ijkMEFdGgTuA6VXnXf5XPDGic+EK8IXqGJXFmS4JDhGRxFqVsYsMl2Owcv0rqi+acbbBVm846/O3Qzngxneyz0Ws1yycL27A4Z3plmLKdlkMfZMpaznp+qEf2SMbb2ojysn63bQ1TE4griEDqbJ70/JiNd0CRzPY0t+UYPY3R9zEoYUgqga5VMeoyPD1l05nJmO3xmIAu5hCnzFQ+35ERkeq+vjpDXQ96qnmOe/7c7nmuyCAb8HlnHBcyV0l4wzbi20PY2jgd66nGcxxEB530/rQ5b0fXTHZL9t81bHP71uTszLK92SJl2+24sPte3Imz5xs0A3+F82FoSBP/+D1kFWWAvejHqNvZih4ZN8V1z46yuu7BY5eiJgWzdGCWBMx136HTJ+g4MEsP5pP1IJ5QXLbczxJmCR3GbgzoqAOBsydZUwjWKQNJQJkQtl0mVI6JDVX9BL00Z8TmffedvpuwNe913gO9zinN2rzPy/teucse21GDhd+E1xOdFOidIr5MmnUZAwKcSuca3m5jf5fy75X8O3YwYFW3qaB13mRS4xciOY++VwQbBvSbd+puCgOcg9eHP3Mnrjk0vBYUzMZKgiyJVHPAkn+Y2o6En+dKnPzYHSy0RaZD88WtkUI7IZnh/Lwp8FHWqgl/QFo8S5TDbWHWswXKOcJveonyXS/pGUNQsbcojw18OU/zYgEDUprJd6Nep8+mjaTFEwbf1RViv69ImusmXk+n4UAFTtKJSGAIaLGZCkmCz7KpG4kTRooK9VOR7D94cnYq3HPOI3YmoY9+3NkWh9d3x8/93muzMWK8wpQ1VNX9qirLMd5Uvj93ohlLgq/ONafbuaS92pQDrCbNH3emn2GnvbXJuE2WKfJlfFpOf9CjlAxradFvsCBa+hEtVqLfzILVjtzCZVnhVcv/bdxqlVq59VX0p8olzTmEKR0z38IMcawHwnhwbAcf4go/eCugrqyTxrH1kq2AsIbzZ5gfeb2JQnWN0EvMLiyUWkLTmpo26NWfiukdWMwWkCSr+F3pdVs/ai5wQjSe7V6ieQsNGfOGYOUqaK8rWHXw5cTCYEuKbL/p/3tsN720nXhYfM9J+cFPeF2Asa39NmyTDocphoo90OfCJwJrPohdPBDVOUqGOHu6zjukjHt+usnW5S1eOxx1beF20PBw2MVRrsWx15Z3Dbeyu3rJJtKaotX40G4XPy3AXxVgwr5Ss7XnbUwpCjqjlIXv1eocJlo1LyXmWL1720dXz/3qPVKaBZsQvoReOaf82Xfoj565O3Q84gQOt+I7pxrVr8nH+bpDE3KO8pHG2YRv9+S3SjwOpZDlN3eo3pqe8vRDYWolxMoNFVe0k3iZXSz00vf1dAGyfkB2Dh9fRmBfQLGrMDeH/87SzrNATVUn4UL3UUl2hJ4p5Fq+6dYHMTOKxzEV4uTT7Ds0q0mS1Iz+vRYPERDSuPb0n9iKPJ/Eo4IZPX1n0dNpl7x2Xrd9UUuz8fAVtBithmtEt7DZ6P52pS0syf9asAGfbr6Y8wWq74wkHF9euoL13YFpQoUl1+pnZ8QRo80fb154ijvmZFyb1xtXkEhVLnFeSB1Fs+/RLCMZpPYpZCGBoMptotJRaCeshWe69EDUCtX8JN6+gLsdI5M4VFxInSkTmn1sYo0mXCCFKmYfreIyP5V+F6bJsNpQSTta4//y785TXi77jiPM8gypnfOzySSdF8mX3TMnshIw+4RtpSOZjMHTxkX4Z+Gyh4h6Oecrt9mqUSimrrRJfE+TzP4czXE3Q9BLh9lkOcpmqpfmkEi9qO4YvmXlsOqJlMe7dP7TUl8DJ0nvfB2HLr6YzOv90P2l8x42pWxna231TfGpLKafeekJXWu1gs41aNzGfjVpORcpwcWnMh+E8l+bNqpOES26taYg/nUNKa7hE+HpGEyyIgn5ruyZogaWMGbJYWVPDnJI9VYeUoxgHVcKg7KdKdYPxp1i/VzDjVU5XAmHlTNiBcTXGLRhXlKal/+NQzd0IFV81aGLm7gPNwujBu+Qhl/8fzJuEZDl9fpg1R5YTf4VzlGVb+krBuSoGI4TNxiGDubwYmZwKiWfBpFEiYq68d5GtqJsaE6syBzMhY1LcODG9Fi1H+gHBIp8wONd2jyhExjOzBbMB/rDT7PUO/YcEtgSB3ZU6uPSfLwyH8emJgDWn5fo8xX6PEaJdqc8w1mhcvNAxHbQm2DCoK3IMRFiK4LHdOigDitbPZxMhEOWwLlnperEsusWHCc80rqA8FI2P7w4LmV8V8CNZETKvl0PFgDEGb86UK87yBxTP78YJueFfe/j6UU6gRR7LQcSwkJZFTWhgW5njydy4+f8PzyG5oLui9LhbgMe4IbT648/sOXGZxM9h8TKf2g8eQye/+h6t9FtREv+rxD7buMHZTS7OLJDBIT47IKsP3m8rth68kPLeYY8KQbxPHk/nTQvZkV8njhzVfyo7y2vf/j/ojv/9d//01zb2f1x7fdf1kftqDngqfQb3/8XZBEcdAbjOIcolr1FswscNHasaLPKuLUG5OR7JELVisvRvevpZOeM7Ym3N9tQwdkii/V7BR8ZwL7sMpTfuE6AjNfldkfy8L3rnhDsdc+TO49k4YVLohBCWARmn8BUhUu/UD023BBry6Mf+F0VEffF2zrkaXZ3RPFaNo8H6WL5qIHA4sl8HGvASELy0SPhtNXnD5Uf6gav2CI2MSk88gTHn5RGmqAAj9Wm1qDutGp8hDY7Sio884CkOCb1umaJSpd+r6KZKs5VS6eqOHKtMVUrB+ooAoy1eQy1X+ST5n/dqmxaDYcRDWhrWULP14/jcRX/E5xVobT9jcfroycNJ1KQIKneilSnfXzbf5JBUlwdnAHXfbF3CjZ+h3EeT1ECc72zr4zgxNg/wBegAr0iHAPulGbjA4DUjN71QPG0ZsA/+NGfHlulEaAlM21i4fH5BmvvymPKXrA526BRu//D2IewIyFytuH8Ycl+7nVFwSPxlX/hQ/C6T+Ponx+JL5IAx3nyj/wfs8fFIpvLfZ6Aleq1AQVrXK6PHDn3HDXL4LCStSDtLlkn6hQsVdfar11rn6513e4zPWeJcSi1xO30aEuPRNJKUzoiGKB7lJwnPIGnDNa7IONzO40W8TivbtlqQVdhVVpjEYAzrOplICpdB3TwSMlKwAc7Z9fXVJBGiEPxcbXbsFb4rrWI3zjMixSle/WWoLFC4Na/Rz9EYsrwRM5/MutslTgs6jh59Q5d6Ygg3L/yKIBtSGUn24cCLb8TBqq7m/Z5AQGaXyvQMoK5JlhKrLLzk1nN7teAlQMAu2XLhsANDqL+F3RJiV7kTpGairF2sJwIhfgtmYFLoOgU80m6aKK8XfQZN8DT/saCn2xDOTrSrugc/uix7JfgvoR3g05r+2p2KJy7HjgQW2MW4jjLd8WTCA2OtnYeT9OJJMbpQIp7D52DQg0IEFfoIMwV9Su0+WmKhAjZZMjsuAb8bTAbjk2zfBpPGlZFoiMNUrqIJ+kA0MQnAvEzRgi3pTybyLhICm4PCYML5Ih2Hvz83JMGD7G/vxWKNPxPCOAqnWklUVhERByI1A28ulmoEk+EBeQ41zgZdK/T3/qyIUlrdqzQqtFHayuFGt2m6kKROY7+umlIjuiC918jJGdNR6jeKPpmbcVQm8/T5cu/tPZtau3+Lavtf9sA0ZsrSyo+kBZb7z8woPPPrWUDMZr/kSGQf2693AxMqdZf+rlaP1fEm1Yeo+hj6N0G/ziJF6yAcTZ0xkODP5c2dAYDE1QOOSeTJpQ2ew8gtyTngA12FbRYdbgSOgp3jlL8cFVznhI8Tf/MQ5UQXfdkpSJAjognKguu9DlkfQVnXVE03G284cMSRQRRHYVihFDxCuFCMAR71aJj/f4aV5iW85OS/HyqMVaj3xu+Y2r3z+KWKo0x+zfsfT9Y7Bt2/VfreOhqpp8f8UA869dfWRvkz5/nuywNz/5roHy+jvgsVylfs1t+VN0KIXVOHg5NI5pli0gf8zFm0tmQrZRRthgneXQVLzsmYIjf7zhX720GSaf8yAiAmdkMc8SpBFF0Yu0ql8I7a2vQIwX0zdraEzuWyQo/wq/njZcFZA5XiaWa/c7WJuSaxqGe6yaaswWWAU9E19xAOy9FRkeBOnS0B6mMkHzd7VtFWzgMfEvzRJ8c//D4x+vpJLpM8oIn1Y0avU4X9Gk8G8aTTCRum2WN6Edxun7n4N3+yenhs4j1d3T409PXr/bZYFhf/9vG/vr6wclBBLGXzE5fX3/2lk3g8WIxf7S+fnV11bna6GT5aF0ZvusMcB0AGRIEt/V6neFi2JCRA4y4CgLmxrk9ithkHUwbJvOABaIzFHMYSOT9NIO9X6MbdY0i+EjEEAqFg8eTt0thsuK7W6Jh/W63Cw1p2MLsNSLRJggu0fa/HXKiQy1ZHY/XNSAR0LRaHGWr4VeohxGqlA8jselgDXjCduw7XuytrkOEm363vh5lZ7+u58NsNlmuq0yO66d7s9HFJM5fxBejpPNrIQJz5Y9/F+PJDszlP7oxueK1VUUVkt2AWjvkv9pRuaWQeGHka2A41rxnBdiyzXWSH8XD9AJ6++EDHNE9j0Pvm0IJThHIvvLXWHmQmK1kFTdMc+/lebyUMOKKjb6xjAjx7V6TP7mDDkcMsQ+86BecnU88Ro25JSWhQfkD1TYsIoFFcBV+4/UKP/BaaFgreB1MGv5DIF0Vfk9dzPjpRbGIzpIojsTbBWx14wTs7FWqL3UYfEXf22OHNdZ7CzpCA4FuLwLArcZ4ROC+Pb50YqeuvKUzTWfNXpd9E6itz23Lpx1rHvLJ6UfIWylZ3RmJ3h1tRyi1uj0bg1DWI7n8Zos130SCK/1QFf/xOBmBefImvn4t7N7d6AHGEWnr52SKVVHGvcWQ6lS4jZ9O4sFvFtQolIb1jEGOuGnPUXuGyPM8m+7lo7Nmf2urHfU3u+afVgmFfpACdLP6p+W34USn5d+NtnAxHxriNjL1XjVImUm1BGCBKPe7Hmm3i2ZJMpwkP1NFA0dGL+BJcQ8AieAoGbrXGS7EGyVkb5ryqh41kFhufRrkWDwL1uvSxV7RBbPpn8c8L7t+rMGUoNBYeTnn4qyqYRZIVdssYNy8XhBKtnCLbuA7o4Qk4MMHJdyJqyYWLbg5cVE4jDOLYekDvZZJgG0RjbOrt3xcWW8C4gEXmqGi1KnaGVcChimQ43nCE3lv+aVCt8DgfdgNlfZpVLWl2aL4mi2yi5zudQvEacFBnP9GtkKCh/udiVI8JUGIMrBmmN5VKafhoI2nQDHvm6MlqfTx+HbFM/H8aWmm8Nx0LGJafZ36+12ifjE+v6EElACEG8oeC/RkqgnNrDc2r48u+PQ6zDPwALDOjidw20SWdI6evd47efXzs5N3T9+dvMR1/c4sc/7UyS/YIgIxkJbQVGQUURYQwAWsvie7aNmH/MD2GyVT8yLKgXgjZdiiAqaRlchGPqQqB08HsxJHPHlzzmDjGc+d2TQbO/bVPa2gch4LGwUZksEnSIWYypxfHAA8WI41jbOL+GvsY8OJS9Beii3pW62gDFowM+nuE9lCdfcxuLDRboR0O93H+sh03wTUm+g7VgHuu3RWq++4DvyWfffEcFKr7+LrWn2nLV7isAtZw3RyectcVgEVnrXcpo1Px8WkaXX4Qa+4yt4LwbCBYUF88gefBvaby9mihywCwEMX4xF7L3tv4O0VS7YVZJ84O4UApw6Uxa5LgeLZ34/4jId2MzXY7tdiu1/Cdr8G2/3PZ9selmXD4gQ/lWsPDYMf0nBVXgmzd6rnmfD3cp877qztHy0HCwRLwcYl+s3dW7rMkguLtd8MmggIxrEWMDbBk7efrcPUonykLKgxsvjs0XGy4ujAO3HtC9I2p3yG6UG3ZYLeyodFyXDwhkGw+2tKeFCi9QaerhsENdwgpNeClfZLKu17lfaDlfZrVurs1ANPxNhAmA0Xn+DHdwZ4aqLCpVDOeIXiJADpBpx89SlCez5uVzrcV18hGIChZcKxb+zmfmHcTjz8flWpSAfOauO4qrF0Q8sHbk0mjC+NZsKUYyYQVkDSu5WSlh48s934PcmzTqMV9PTVbU64IW4TKAlKF2Jt2WWzkgqhFGP4fsZAJiIPDrNOUKFyElE+TW+iVjtHqZbTLtAabSH1WYDa11JpQX/ulxBWWLd5YEERfZ6GO66v1igf9mqazXFtVyk6B5zWey7NUjXo+9ZXOeSr7E7uja81hy/sxGYElZuOd3EicIMeVUcJdboUnTAEmmsArHYiPEpJWQcX9RlZUe3qk48y3qHcZ51jBTmXpym1GNdnLAEmdLnFhMGimMDnNnWYQKc1NBcIALOB8Qg+7EMgT2+WniCF2VQHRmWcKhifWY19c03JT6vqTSzviKt+b8iTr7JWShC/kQo32CfmWG1VhvrVDPVDDPWrGOqvxNDfwmEuCMBn5m9fL+TFPolcZSqa08fyGWngqImJqJTMT+ukMzBNy45MK9tRYQvSsMH2fH1bMHjGe0vCsk96q8whbx3TZ8vhJUSUu0uIxAosIfq8umrcDiZJnPPwtOG7s1+TAYoxNicg4rjSe1r3Roc/1cc/VP7hwDG77+FWguXkaZnyIgW7NxxCmKQVWP27OsdBwZXo0LrlneR25pDf/feW9Sbg7+Y2FRzfNUft6KodjXFF0zid/ZwmV4dZrk7I1dfjZLFIZ6NCCQWDdl5P43yEQ72s0qPS0pPS0qdu6ahzXP669ct0NP5/F/EkXSwVxgmRvffU+7Gjc4ybWHT8MuIms+5FIlqUJFUUNXvbGw82WzReJQIGxs9FqUM0q9x5z8mKDIGZtAe+DrF7jGfJpIBuFiMjdkpE98trEW1L7K3Pl9z1IJHPl5MjBdLiRGt02Ro5fND1WX4/m6Z/YuiPXUInNP2nJP3cjthkG7gbMdy+GR8tuIwNvUYccMlnQtJ8kM1kHjkIfINHTAXPd6ONTm8TvQoG8HtwKXNvnuRMFwA8XKhAL0uwSrd2HC0rdJyrZCci5JXJfqJiNa26JUH7HfNkrnaCFup6IPzTsG4IFGJvbfOsKdsH0l7ItYZzw65VDUjD0OuIqcldPgAwlpyl5dxZUdyze/d+kUzyiO/nTTVn7jnS5O/AtNp6zK855fwZmRa5WqGoAbU0yQ61T/DNugWqisih2aRPp9uB49/Wzp8jaEFd3gO9xQhy9Qn59jtH/DIfKSnoHXUB70m0oSQ16uALfJbc2qhfvZY7/jxK/J7Lz26/42Rthw9KvMp9fyJVP+V1tFnwXb3tUt8mWgvBXXKQFPAiQNPzud8Rj280rk3ojyn17+w8ihr8br7tcFfvKnEFMeq4Lx4rBhC5tuPK4a8/tqnl3mnIYaazpKMUgnpeAg8m4w7XY2ba6mkNRRLWecWxjSncY6JBP+rbTuJXvUY7KVpUa/0m2t878lakbJXzCrQ3jowv6s4u7wSd2y0kdhex7cU1VkpdaX9A+BzJrxnJb9SUvCd0zZIn8ToN9UI6pfR120j5f0JpmfNi8cI6rhMFbO4tHAcwWvDb0X47Om5HR6w9R8i64ZdS9rPk3DxNHvRnr5vLGjfaYDnbNthiXaZFemayVASgaPtDb4qm5h018LXr0BE3hvcjf0PdoQ2hlq0dj6T9+PqKJONrmyQ0iZN8wpm1myBrfOd1hKaHLw6hPsDovI/B89ZURseabehxY5KNXtv6uwt8cQMUxZ2uR6ZtVkmg2v7NqnWIr1KtY3U2JRuy7l5LW6E+6mdZoKY3DRl0MV/9D9fRt3GdnsUXBsFqNJj30BOVji36q5hyv4JXERmjv9rGKOokBi/Hxz1SVr/SFmoZx+Jm4q9tymhFRika1ciC3aMtWB8YzNm9VssRxCevU1OIuBcTRM4gRGvNbYJaG7yJZEkYSxaC10Hia2tfW8LuoOgxspVSd8VRLfoARrX8zedPlQr8jm1whixpjQQfLKPaIkducpzFkVjTTPYA0HvrXnkLTXjTEIBF/l+3mrVdMoxG3/134ckwfxfoXoioaKqz3IMDCAYfrUKJhpLtJI5s5Xt5wfK7HiePbZeEk9sNU6D6Z730SJvuZJuo08N2ITKYSzqY7GKLkCKxSg+TfUxSVZNp1U7221rmyXAtRsqfocJCPc65h4Nknr42gm9FwP+4cryJ5SAIr2467OPHdPdQckjxv2P8FK9ffNQTBoNeoJpSea4For3XnQX8iJtJbM3RGF7EC6wUzVXraPkr2QhnLKb39e3IrBusaXdhd7C0fzm2YPoeDPxyjJr4KeB0qq0ebjpER+VjlFaimrsvNk5H/2sG6lcbpV96iJb4KERvIcdQh/2dGv+QfVAK/oqNcn+FGp0v48n5QRqP4AomjOvOprau/pkvmsjXcNd2PGCvw138zatCHDJnszKvSPMILFLMDPTjfrW/hEY8DjpPcIv4Yuv7UKw1mHSkeL0R6gbq145OqSbEQjpUyjQWPYwtQyjoGcb5Hx0XNOEb/ozDOrjuTZ7VIWtOR2xRPhh8KfHOLr4F4ipY2IBoUw25bO/S8Uh3SwwUSwcAL3wmxGdFE99CWfPvTbbkyYutnMPXK1F0gfNQWPDWrdd2iv49sTP0KJdjrXlYjqE30eEol1YzMJF1MkxeHzxNJtlVMnx3meTn7JPxsaNe4J1wl+mg7hY2gXHFyHBlWA5RYx5TvJIooXrQbVmmIFarh0JR9dx4ucY1rbZml6zXJWs1X6f1BpwKo7NmC1+VS8D7NjiMiKONEMrflLa3EUShd2S6SR2VGtgP3cDhZXjZpqj0gkegrB18qUdU4Jd9iko/TMUxD+655gGishFukcPLPZcXV8OQR62BWFUeG6LfUmx64a7o4MF3myBabdSWIGNe3JmVgTAIf0id25ZHqtnnh354YLs0Hs4yFOhK8IX0fg1wfTe9DnCdc2Pb/2VPpb41l7aouYTHXl9NJzS9aLieA9cLwPUduH4AbsOB2wjAbZbwZ2z6IjB48Njsh8PqgMwb1vvxKDEGEQ9SsyLZuiaXnYxCOsyKxWGeDRiuOC7+13e1zR58Eu7lUgsmPzxIR5A2/iAt5pN4qdMf2j9/u8RrN8l35idNq5nYbPOB+s/iIZ4wXTmLF9pGc1mpyms2zn/XoW7v4G1RNwMTBgDmnE55iYo7B8/2X73Ze+2kfnx3zmN53/CZ/vZiepbknbfx2wAUPx6sgipPVEUmXDuvlZEIdbzeuTHp45/RI3JE+qNzIpfQa0Bws7jdMJvQX4kyvkWiDHua0UzbMJhlB5tg2JvGda4e/OlyVni6hGbKA8OM+TQI5iiltSqD1byF2KriqCYzlmYMZkM1IE4+VITrXau4I/VnWjANqoohtZT1O6F6W6smoCKykNkEkV3+eZnGLLJ18la5K8+KfRK6nWGBBPqESvZ1wz6BffKN++TxLiWL1foEpQ8Ldki9RGLuIr9ah5TcrXKA6E4J3qryrYrayvdrZoY5D940Okf3i+pc7eGW0B0iRpXbLvwdIG4gebYNffPmr6suN7rq8lWurIRD093I8C8UnC4jKjr+e/FOcHeX/x/tQ7/IbRuQBzlcnkDSZjUZ6JskJn+xR+VpJZWnPpXPGUjxZZzqN0DgzkwzcAOIvDTj0HmpHn4Ye4ROaEJPLUIgDsTQE9ZCWLIwbfjNiVaxjhHMOHUtYd8hVlz6xxHGUBXw0Y/o4AE9XBI9orDQVlAeVdgnKfWWaIOuXf0OkOfU4wpXt1gtP8FFzTtwqWfPIcaekDba7TJWk5jZdVmnNi4NtKuuIOGMC3875p4KBU+sC5kjTnNPBNFb0fPzrLAPjJgi1oy4W4rS8S6XZT5/BJV6Lhdj06nKS7GOXr14eYKZWaky4E7IqMOfyXh33mx0Gi07zGt1PtSroRzTeyq0lM7rZ89P8Kuec+oiQ+iSJNJd8jDH31/yIyBxvN4O3obEGs86xG99xuWTwDk+MUbNZDPH9METevpp1FIh7z97e/Ls6DbEjEMjsGz+QwUrp9UjJ/hkkpzjZxCQuoHATDH/JnGxeKXmYLvh3Y2Y25OSd1oAu0NhQ3i2f6mC8yVpFBdnQhKQiWlu3eIJLAqCBSdCXEZ7Ar+KOREDwnSN7JMP81+An0a3YRQQ/MZ2uY2HjeiPP9BvTJM11ojffiB+Y9tVP/h8Ll5GDcfGh2Vgt9/t1OCqAyRrrjmfN/cmaKasRbW1X+s/e5Lypeq2ld9f8qcPKW85cOsGB5+fdr5rnstTv6YzMPpCXYhjRzxIns0upq8WydScRepfhH7BJ5FShOOLaTxjwhiCF68NEOKcCd3+5EeSNDiuvWW/l+wy3SE53SUbsEM2z24W5w8q8iwxOS0ows0GADTaUeM1U3dixSGMjFIKAgRo7PNQEYKKMlTLyEgYoHOQDFL+JLlHiM/6UjIcAogcwfwRJEpF74h857tPLXeAwRrV9M+5//UJLgwFj8v524LqlJw/9Pr+VJ+Ou+fg79vRqeWMBI/se7Ye7kaXWTqMumwL3WXb5fdoBgEPpz7IqXE+Zn5uPpCcZEZsedStzqX9mtpJOoVghsskZ116GOdFcpQUF5NFsAUW98XFYCBSPHHnj33OKqh0vepYBdnkQsb31qlERGviY+Vz5cuzqYO33n8Sjv8I9E6Us1ygY59pzt+IUTYf301O51P0E9hlstbvRT2dA/N+MSDDv/f04zkAoe72Bym8oSiIoilTSOPigyL3Br42W79UEDw9td09S7UdZiSesw3uaRLnTfxq/Q7BwFIaVs2lMgbXIG0Lqhn5QjwGbocFq7ZQa/ePKPk15MufJMrYPq8RP14USX/zpT0oFPv88dZuA/Xsy+wiL8gW2HyMkX06xpJ0vFwui9MW3jhYLXup9ySefc95ZZwhaUtGTXVqSO+9adg8cMQnUa+Ha1bQhyFo65qwrJv/WWNlBArOao1QMKwlP1ZMCPlT+ZiY2qNv6nXfm3R2sUiKyiHY4C+gT1EnTv1ODLJROG5Xj43jhOm7YV02CsRGsQIb06LnyENw4khkMkmLuvx0uFgwQ1PE0UYLFagtaVhdTIvut2SwX4fBb8rhRlUPj/UxdUiP4aphThPPF+UqSR+8lSzWNnGYJb8ciNBSuWhBii315fRUPGiqmGFY2+obzL0NjQZMbGs8NjD51H9gfujCL/2tbfQL/2mrp2nsH/HnLPuaTFocJZOY56OEM6DNB4Yvztlm96GmN5T2pFiZWR+9zgbxJAGLxFyRyn6aM6t/n21Loe98sXLPKqdmfLBMnXInLPSEV3goC3Wr+LoO79E1fo1nYMCeJ2fwh+0o4U88z8W3Jfz59WIm/kx42cUI/hTJHP5kgwX8mWWX8GeYDBq/ECadZWJBSpZ0EP10sv82u6IsxlMhHH2KLuBPsp9m6TWQbQ5Z+YJ9cHDVzzAXOBy/GpNsOIQgtlKTumAfMCmYW/p41vDBLD7IIGChsC07I25vIBdOXYt8yc1Z0bcn2d5ZAUQ5HTa5fOMP6g1Zw01dV8DmBTJDYXyaMYZS+jGjhxUBhG0HGRA+MBCMtPgw+SUqdmuA1bIwVvJEvEYEK539o1RS5kcmC54cIpf3A617/vCzHspRxIayFVRvcPOEbZYGCQdqc9+em+YHGH8OB9W+4KBLA0X8OQmogG3G0kXTEAZVmC6U1sTpiG2dRt/CNZhszsIPfSKzT7qA1Ay6+Wtu6yXz2W/JDOQpwCWfaw3HzBNgqlZmCvVs56fo3TkMuVcQJcvBP3R/adFXvlxq/TrUer9YviA14ohKwYQrPWGkK+jXq6DnVhCpCVLe/u9M7WYsmVdiLQk5nfdolc57tGrnqcl3W91Xi16EJnhpTxPdd7sVREircMDnkyymB4XpQzzprT507J07BhAsHd31oenOO58fzMOYaoFPR3zloxF9Z0MYfeMSwdCi6egX2cZWqGKumQuk3KH+tpgEbZgwLRtObM94vW0l6baWpHARs1UOrvKpH/8HBh5yE8NypB0tamVw11931TLCdq2/4NrJNivcTJrHM7Yk3Gzp5GsAXna4YnctLpy0lJXq+XuA9f7MnspDe9gxNOtgCGVDM2NjaJ09uV1pximS8L3d6B7cBX6wvWluGQp2djmz2oLv2bRp4ZfXq8RjWjJDZ3wCypXRyz+FjEBEG9t/Tgm9+dNIaPtPKZ9jWz7oDFtCyiyI360iMFpcLuOfviMEdUP1VRh1pV2+sIoU7Ic2wEv3M1Zk/MZlQligtmeYr96SFJePs81mhp/O16vAdqM19dnLyqtgnuwKvWK7GvjaqEDWBYSVBAnv7YdOMPjQ52RN1sIGoL7oaRpuJGsYNMIyLHo9KPKmRj/yz4+iRndISYvhg14obSEAeCmyuV0xJJwqIm+hYJ/ZBkPbQjPWovG+DQtSctwrMyblxTm6obh4c6ulNabHFhqnN6TBWNgul/f2N5P2lJT29o1lvV1H0tNbkLSigaY3v8bIg7AN1bsidgDlMOBaZodkP+p2kMYvUB/pINqu76p0KHSrSPQqSPSStY0KEo7DNABrjxzTY2j0IOn3dM+ZkVNoza+HDR81RaNC9St3oAzsZzZxfJBMFjGsB+3oMk2u4MIn+oleDY7H2ZX00J8kYhNrhqAD8JL1e54My4HIsjd6e+WsOVD4Um7RiKKDeOmUgHSttnKPCB5UlQx/ChOiyfiCCZHg0xM2Up78XRVlS6UWZa6gQ7TtBQeLtRZtsViGiDsLNuqZanUFfVPeM07v2ugUsuqPUkSjJu3BWYqE17HguK2wFkqGtH2YH6nvfyhXu3Hym5rcdrdMyj0Ld1r0SCQt6TBil8YMIRQ2tJRRkLwNzSUTgh3bsDDGQqAHlnoUpY6GfJoU3EVwXldDLvLkPLzlN8EcePv+76Y/NUV1OkOUgU+HGPO+anBVL9+/yBiWjhpVaBEmKYTwa6L3A+j9euhbAfStmsx3Sfy6vNPYNVnfoLE36mFv0tib9bC3aey6Ugs0XN1cq255oOk18R8G8Ldr4vceBAiwgpot2A42oSaF+/1gI+q2YjPZICk8rEuh39sOC6Imjc2NUEM2arfEsU8Qjfv92m1RDk96SrLS+rQ2S2ltrkTrfikt5KKt7u7KFq5Arf+gso0rUNvaLqV2fzVqvV55Z/ZW5K7fLxfdRm81epub5cLbXrEvHjwsF9/DDZIeOeW2HFDjRcjhdYZd+/SjIwwjmQ+6s/f0+N3rn06erbAZq9hohTdKoU2OtT1x9jn2iYZlBlVCKqPIBeQTYZs6LdFytXdBdfZBPgEandgJ+ajbXRK3Cg3vhUp2Qz6itRsK7oeICvU0spF9I5ZidotGpuxcMeTdzVj1zsnCI/ZP5Ru2EHYIuRyvcLGcbZjTRrJql4S1N6tBYOz2hgS4sytCxPQmDhwLpjNa5S3bP3L5wvtAGufAk4aoqRTpjYvEp3g5zulpoM27BiIgQROuF9TCGtZWsjdx9fGZ0aqIgDQXkKwKretHlob/+vePrOqdC0g20x2a0126BTt0AwM3kOhlznIOOPSbDQUFUWJ7Z9x3IF8Rt6mpFHzl1BQUvwikIkEXmXg4gS9KhnZIJq4s+M0gO4YS7gW5UZXiVhDEW+oHwOm7LNN0lk4vpnBD7ho+WHdb3uCsOOIXTsr6hcNIMh6kpGrdgxEcvYxnwwkdASr6s/kGkrYAkzhZkTirfQPVurEub1AoB8wrOPvgbKxFHH7HjSeVL6fzQgYkkO5GTVGrOOjmTwkLMveCEG5I6kFyHl9MFiizX68t8jn1rcRLy3mSncsCfoWqwZav5JzNtGHDySGPQHseqHvgjhpnkma2UQJNFPntIljs9rxTklqMBKj2tRCQg0o0/rGq77uKJGTQEemMAadDON+Ppwkb8IVIQSZIOAfNT3RJH5W0QoPB6S2nY9PiQDS1eenEGN+RKdz4wHSw9rPpGUNqvmF03/SJ0dyjhjMeoX0AAGQYiF7kgiguw+9J/B7Ct72lVTUJEuI4soPyxcmvMNd6ZpIpDNZZFRgiXZ5VxxMBYvIEyq/hOiowVB3BcznZQX9LF2MxR3hXedn6avaWXBRx0iCUfU+2oRLd6iuUUVEVVHY2rr/WkNAKGrIKyocZg+vG3FooYC2DWwO/oAVgIJ/QQvmx5mzqMpGzZYypEJ6h20k5JumYBN5zeYyvFRbircNB9rM5A+OJwjQJ/s1DtbiaW9FCaLdu8SjvqFZxiZmSf1/k8exiEufpYmkzAMgi6ficZKxHWppGH0pVqHQg6hOhD3mqTKakG47hJYe6kVnBdg6DhH9vR+ILT/vRZstcsUhn/C69LEa/SBgpW8kgFcVOvknrkv7gUoZXpEA4iLsPiDle3JF3iu0GjnJ0a4SHT8f5KFmol9y08FVgyL2ovNusqwYe9mNMnhgfnTmkx0PZEj+pGVZeK4wAiIw18zBPk/AsjPPEVM8rX2SLeMIfUti3J6B8zaRI8gM5fp2s38u967QQUnaQ5OPwDvwkGTEz7ZAsOwskQZ/Fl+koZqzTJOX7xJZzSJQMZUZT4jL3RyeztpdOfaEfXdDTC7cABdCZF1/cHwvRUwXSclxb8A7oMNHpV5it6x7evBX2QxRDJp+Y7QLYQI644BtWVk2IQOGWDyxh2F7uWLZly8twviKS4F/ESqLsxpBbVI0UOr+oKsUpTTUGkdUUjTs7FapQS1Ah45eP2+IwyfmwL9yq9YTofPSBvTBLkqLFWik9l9ORvAvEJUwLRRd7SWFLkEw5xjKTkcYy5bgHEJZnvdgZmYmBW257v83Ynn8wFlUgezuU5JfQKW5GW8zDBxf+l87eBSM9zpyUt0xxEM9MzKl3UizlZT+LMsAvoSy8x080JvF4iSmr81bJJ7/r5skMN0irUaJZSMXSjbN0cJ0mqnxCUvYSH1LfdBZ5PBBvFYnnrlrBFuhazXsgbPT5DQmvEzr1P88i6zf8jHrHx1layPd7BujlHvv5AADCVeOliHq4xFqpaOm7q5nqAPexjl5XWaeCP8jlbP8wgocg7J/OYP62nZh4q0m4ekvjiFU0oG5EoZWKWsJTyaj1ghyYvFRWarVW0wyoUsyBxiBYQCv/CjwMwpnBB24+8EEoC/ggkPv7qxlEJQ3UMzqwFKli3FCDE1gdHlOWC14FzPtV04uCp4KP5cOPl4kQk2PHINPr86VYIg6BRctClGFBSGiiy7VJuMJYA3sxYCWxEstCAkjKOhIWZ80694bDt8mV3Ds4O3Flp/LbooOkKVJoy1vfscHBDYCMj9z48dWgJodtW/eaDM7mJByN2sPoay1F8QNJfy3q/SK2yHWBxb4ZPiLxiNbYkimxqX3/j4MB3oTrusZ2iJpBAXJL9/3QclFzELfjLZPE2fiZVJVC+p6jwxZwV0nySeRkFOFO757aQWMEop+6uEM6+gHH+lh9hrXj1t7nDpsbUOshajyGWlDjVxr4aaf8AfJj/PFHpIshmEO027pDV9oJtqBriTogU8cej3wo4evwXtOoKRjkfKIB1NgpG1fQrvL9E37B1/VKPCnfe7Vcd8o+2y3PfpoTe9dOPPyVLUUvJtlZPDnR+zNnvgY0qUW6lu4j5pR4gPDqdTrlSrxcKHejh1187wb7l2prO/WEiyvVNc2Hozg8wN1opRotReMuMSFc13bVgvUHg882PsWraKv9puqVzKW76vrBK3NIeY5eSb7CG73KOtcWFbdVdcaRvSrvLbKTKqoXrRvGpukr1r1rCy402hCQSbqymKaz4LrS1apbgPLTnDqgywqqSwxaTnUZztFCCcbxdU/41gJ5n3UVqTOt+MyY8qMvD1C3EC0HVAtTTxiKLj+Eo4HxOonpE2KhUHbMRQ8hoF+FgH5lFYoGRr9iiQiOlmUt/ZVJHafhW5a19VfdRYZ2SWt92iXtxLS9VMTGMpRHmdAlO3S5qGOqDiFdW1ASWDoEMACnsJyal8VezYokFyZ70eSWd4FXL/ELugBLLlskZM91cXye0czJi9Fru88+13zWhJct0szVU/w5xNoci0hZiSUNU8Sc0QivYxfaFpE2awOlfYua6Ke9xdNklM7S2Qgu2/f84md8w6lKbqhtfDszJU16UTUPPCPYC+uUcJuxJiCoi9YhaXtmfEpaqyltxkvLk+RfWpx04WNu1evxgBUBIYi0pD5oEVUV/C5qUcOIqkTIIw1lFPIbZe0D/W52EZTY7kV2R3m7DR+xxubDR8J7kXoWEV0xYfmEAK2GVSNxeVRFEHCSK/DQddgImF/B3tm10UsNKBoYbTCtkVlzvDDYlYcKx1lhlHD4OgOkUvy65lIA3pzVOgaL4db65F/kfkmEBLiuOLF8t25S2XdfbJ2+PaLUatEKr3R2M+0l7jZNh9SYDp/+XP4M10dhYtQAQA6boskmwhk2+mK0VD+Jzvx9g3TCrqGL4xjncQlOj3oMg7uOrQABE1FoBYIZf0GWL5CMnRZRgyK0/YSx8kSMmbU1M0CofUhg5+VuTCBicK6PEYndAJni248oPE9nw/1JViSFjLa4bkd7k0l29QpepZhnk9jN5vG2Z+dAfdu3vx9mhR1FV9M5hQ5PPsOkvPYXA8sqZBPiWvujVrPoXJtU+iNISsYaw+Li3/vB7bWdxlN62hj8GhB54qbJ5LJntFjZPaD65ImdBFTl4PjwVkyxa/sFLc7HW4wAK4EN0rNBTLpJ0ces3OIYaoQS57Uua0DoRJThQYY7c41L+QMjIea8+gbJ14Rp7jTLpFAWWKUNdIA50dJMnwzIflJLcLm7i9msz5CHLZvVWoFL85oaPtayX9ni76Jc2z/J9MeSaXgiomlzsbSEv2zBPQKnQ+AyQdPvEgyx853XkDnxYqazsBGDI6QrFvmSNl+wY8wOwIwGMX+jMcFxnmcXo1GSu9vxKYcMu9yIKxyQvio+K5ph3x8ftZ/tqhv2wrWldG0SsV+NWKoILYpczfRganKnLpoutOxSR3ZC+kJ2w56bd5FT769OvYR/otp+yVrJ68EDSL9Q3iQPsl1r4iuHRnaox9N3KsNtUaRvOLywa8J8T/J48JtzG8oP9G1HwzRnLBz6Yb9lgb3JLBg6W/C7q4yft/E0CQGIRwji6ZwCgOFxyJhKC6ZVRCSgF1BrwcgjMtnizgEu6xwePdt/dfzq3duPb9+9fvXm1YkdAyyu+5ikJfIxXd6Vr6UTM+pbhUOGwe9LHqQirB+wu/YL9vt2ALGO2+pD3FZ/a8v8Y42qsywfJvl+RfSxgArGIM/j4VDIrGdxBVf50kE8eaMep7eLx1me/g7XMkMA6PF2ZzjQYTfwSh/xMx5wMLXRV7sV8It6dsyKJ3YrgCC55xnsfOWYFg9tP2hHOlreBJKZ2kLBZDY/Xzd4GWqSk4uuSBbiehQ8UY2Zp36olCVfMgrJmso0OxYIZsrGJVhz9cRNGdSqJMygBnEZNLgBBrGeugmDhCoLjDofMEinBgUrEtLCpcIhHV3qNnTAdtUXi+Qj2ZgVBFJKx4uWdbhaScW7Dp7yFYU66CnF63Yatk4Ri0hIn4hSOzhVYtw0aPJArVv1YibRMneTUYxXQ7qRGAI31MK8aWOZXcW22dIrUa/Bzvp9o6nrrvKB7nXBrH72aIRksFvd49LWqNnjhI3iLTTSTKEbJgtxcxQ8oUOMxePJusRsqO4FZBAF2DQAFqsIj2LXsrNqhhHXZrcikNoB8tn++kHVvkV5ezKR5igtC1mIZaDgb9r2Q2n+1mu5MZZvoiRskzpwPcKCsW5J2Ng3bbA01+u119sE3GhBcLYKgUXBgbIWBpfCV2k8scW5SfOlRqMuGSldR9/uQaqQvGoktWj4fo4ksNrtteq7a0gdtmmNIF49p25BOTeFYE9GDwcoIXIOIbPOyjhkmXhfP+OQVb1zLxyz3KH53KX536GbF8g3VGHlmrf3/IqYGnTBeQaiIlL3gkPEe3XJ9oBgr5xYtza1LifX7VQRXIGiItmtpLkKUU21BtmV6BrCdSivRhrRrkV8ReqYfD36q1Zg1VCzipXrsCupW8vq1Tj14IpoteKqE56yCzt5IWGX7fQ16bpemwu5X8YZbG75up7IEjexWKZ50xCDnUP5c+fpu5OTd28wRsZMl0lMeoz/8rf+5W+9ub/VvaUeuP6qoaz7ry7ujTf4bMtWROO4gHR+3JCFp8UGi8my/DYsnnvVtiy+U1+s5Lz7UzmmlfII7CllqbWpVBgEL0gV3YQZqZdoXmQhZkXBE5wYFXezbclf7py/3Dl/uXP+cuf85c75y53zjdw5yJi33DnKsP/6nhxVs+PEwYx2PO52PYZ3vKYEvDZ6C/P62XPlo3GJNRtQCLvA18n5QoxqjXfy7rAUVZYD9kk2X6MplGFLTB/p6NWLl6X1cgBV8VE6Grs1l1PQ6BSq2PGVE0AwQOZptlhk07UwtQpChgaJXdoLBgRxYvqCHF5oWPEtPN6awxbe3qqbLfxbldLny2zgVe542daf2ddD9vU4WSzYWmrvE97nMubNJQLhEu8h19rfs5nzSIcAyGW+8nEC3eXtdkt8BVKP9qj9Pd/V99E/1goxuMiLLH9K7fJtEptd9Z+fbI7H9QmjQndE5xSXdPZ+OnlHcNy/KcchXnnaL+XR6FJNXcljgMVDJ5m6hmZW+Uc40EnIPXJWQp70vxyk0xd5vPThwlUE9yR/+URu5hOxZ3M4tMrAuLFVCDsQXGVpC48DW13QHNgwmAMHO2iOmsd4xS9GK+EE2VselB3v6am2m5ihfxrvilK3pY6EHuFJ6JW4Enq37kvwdHsgN58LZuXp82hQOfuIRcRrSrUqrdEka7kpydKqQLxErRqXaIa7ln3G0OiXDo0+MTT6JUOj/4WGRuWgCAyHioFQNQQ+e0QHNqMWeXpD6nBApzM1jQhvTBGh296cGouiTZoPtbemzowLS8zMSYpJYuI6WW/d6d+GRFQhJh1ymGHTcnpQmnI8JhEWMSQt++z2nHx2l5Swe0K5PR3sr+X19MzQ23YE06PsrHx8nYVHVtBPU2MynFEj7Nu4188+b9FzmlzG+EnYyX7yjZzspePtMyTDWqZcBU2xEeCnfO1IfHnJLc129HrKPZ/t6Eh9OFEfnooP/oBV2/2ORIaX+tTHP/5wfAKdIwN0FAQ6MUAnQaCnBsjhrWzR/0Q4KjTnmnHKnaFZ15yTUE811NMSqBMNdVICpU5iUY+RcC/VRgH3Jur6V0evde+zz9ftiP27bEfXf8+yaTtawh83rbYkDeCMMPzZCZQvRfmSLP+dkeaXkaGOIASQWCoImVMiX+zHczZnE2D5GL7zC4ptsR7wt4HEp/g6wPu7PGWSjSfvJQKwIT/uVMPzpGaqhlJ4KSNCcqVoZtTRw7EU+e9SrpS4Qx0l5cll+V50mpFrh0aTOMgBpxSt6p1AEncb3/RrNncRgzVqz53JGy9gyuv8Eocx8HJCnL/I42HKJhhxKtNrO7uQlY5pVj4X0Z5D61TE8iJ+/aMRq3rnfMQw3KG53KW536EbFzgs8d2oqgMp2s0GQPBA1otFNoUsNmJNtsm8evvy2ZGOjw1QkkBA7NVsnOQp69Q8m0ZTJj8+bgXlkBjc5nN/vvHTgzcfe+3R65lx/sWuZRf8itpz9X6sWyyqPmE9sR9PJmfx4LfVrnZfo0iZLlnwqtCvkhL4S4T/sG+FMTGe4Gad4LDhFu1N0hF/3o8Xd07UT539Z29Pnh3VDAXEUYBsD/ewXx0KeMAqPEqGKwQDxsyYvDoWCYO36MiErdID/K2KE+6tel4SzsdqpwEVL2n9GV3pX/VFqY85PMLT63a9pzp5qg5eCic00d3osmUycmuXOpqcxPJmzd079k7SdrsjwLLJz70/uM7e9saDzVYIhb81xGeVfKVRDuviKuWpWJzZaBaYQVwk/syEg9FHdi4/uzpcFco8dMZWp992SkmLSV+beG8l4vxsuTbtPkmbMCHcTlOD4hByl2CNTI9kX3PjMe0TGcgP9vgm9f/AIXjzEyprC+CEWNqbXQ4puFHwAIc3v/L3od4GqbWjHcVs2bXImyXLPXOmFyYg0FnYb2K7r60HXuf+/nuB/XuSZwACKfxCS6QcW0ZthHn6UQeoRmtOBY90UVm4bkVOma92/mT0meqUO7v2s7elZ1Qrt65G+9B7nuCbLI8dvqaCh6/LoodLe9x9sddqeqtuC/BbgbkakxX8W4Or1tB+VAqm3rG3gt8tfizZQBarS9W3dWeXKyeqMTCc7Cxbf2czBQXY+PpJzyWcEEu8vIxxWyanm0OyixEvvedbAlrG6CJqsKztWrU4T7zUqwEZ2FQV9wJVfEeDVyusm845hf9uxh017sgFS4W7bbSud+pth6XQooL8VT20J7gzEEuLo5Ds1YvMvasGNT3NO3iy1xnGHEmFDhh/qekRe6xTPXa5U2ug2FXZaR5JlVSzk3E6Nn2GXa5gl5SCXZYp2KU1QpmhPU1nIhBKfIuv4UkygXh7qpYZSYF7QKzEUoIASbAtt7RVp+zhpe12GsGt1XBL/n/23rWrrVxZFP2eX+Fw7+lhB+P4gXmEkDV4Brp5BUwC6Z3DMPYEnNieXrYBk71yf/vVW1VSac5pIOlea+91zu7gKalUkkqlqlKpShS7w5FtAmPSurg3sKDx4ekDGTE9eNyAS2JhcpxAyNpqmVSa9KoRn0uj20uJO6ejypJIOlvCIX7+uqc1T5+8v+ZS8DntD881B3/9Q57xT3jIM6Ui8Oxzayxe9KyaYjiftg1BWdCEBob7dEz/U54u/cwz4+c9gUp/sPR07H/2S6Ys746egVv9nR4kWUZO4AO5PI0SPgdorJAbjPV3+RFgJn/3N1OPSQOeKQk4gWmFwieUxXvqS0up6KAbS2Mp/fW3laZrR8VUWJZ81FZ9dFf8kQSuJrEtW62DB496yeWaqsNtZTlvvRHxWOpue/gaimhOvafyZgPOgrilVDeQ/IrSXEa64UJ+UqSQzlhkfsexnP/qi6VK9d81cAWfzoBux4uwrY7XpXQ6tSaPcQfPyFA4Wb2P2D7vtLhd5ufQlnCEveHSVzuzxnE97NBp4S/uOqPOZTcirhRE4gPufnByw0Q+4pZbppeU2YJKB80DVCZ8lOiykUwSSBcG75tbKW+z+EOb92yYFKZ8+KHb8rp8aFZ2n5nxNsF3WIGd/F298cFR959vf3c1y+I7XPIvtMULmZnBM7GA7+FHU9/hW6m1dvuzyFoArObfFXKigJoCYkwCqEw29B0LBN//Gs4ENiPdGagA+4PtiC7xHvd6fQ45sAUlwOllP8VRCDQMr6FQAYwIo2O2aJHaf2G0FEDsiydYWsgVTxQiXU7Vp5Q4wx0dvecledWXwDJ/THfgIEgByoJVEG2hthR1OWgi+vI6tSuL2jljp84R1BZQtOP0QRB9Huz8H3Zo/MjZb07kmPgPZQ7nxw1E96W89DLVCvw6G3/kDdhHU4Xn6vJgBYN3sPr5mdysbV5ik6IDvM/mZgq5VrPfj4Ux5JoJ9jwk+ZgNLcfPRdiyOXFbzhR8gulZ1fvCSXYsD1oDbUq5pheyHPSwsaBHRTqBEwpn2CAmP55z3mmwkCu4cRO1vm12RtJsgLKmqaeoqzkABt4MhdYjbcINuNCEU7mqe4+KtcJmTCbKyQsSdYiTw3ybc6jMdmbWF6+wWdupLyX5vRG9xjYr9kjVm3aN9dZ61Bq/XbUDL6StMJsEu8JdLpLJ5dU70UDKtJ/sppk2EQeTXQOPxFkJehrOa6bPZ0YLK8+IDG3pMmZelBI0T0najxloyhUCeXnw6+N//ZzIX62E97TeS9rgG9pnf6uoNZxwkAJe6oYnEC0CgQmUvvQY+jDyGo2NKYbo2DYEPlBH8xAK668ZUU15dYequCj/+hd3ru75vPORxZgha0p9k64ry5DpQzzZORnHgxPJd2jjB1p2nnhGvn+C3oXiq+DR8GvzcuRX5R+9morv4U/N4dj7FrvVBiAScRkNDjnuBAd3V+QROYo5x/VGTlkn8dGAjriB3Cxb/pMjEhrrlIJ1R8MaPwyi+CpnPqzmZm4ZwVx1+lF7JvcP2Vfuja5ARSuhicLiRMUoobZ9x3PfQaqcTC1IKnLIcd3UpZQ4PRmwhcqimM1BS5npXYyLeGLNJgMSiKtC2cZWIlKdY8fBUdQSObkGzX5Dg0PIlMOuW2z78PFigNzgddrvTPhXCAnl45QpqHn7Epv+bcZbzkV2SUeomptROVpFtX3GNW5EQYWsqOsxGTHyQOVgjZ34djjyqryZgSiOxgBDxg9uxxFuAnXPEfSYqVghUwCZKfO+R2ObHGskdtJIfCV6Bh2fRGzXt4F3rsjQOkKodbudkVuN1+DwWdXXuUpUQ8iiMD0YH4YrrMp74oGWcRZuiz0xHZ7DpdtguzNhinet4LpP4kTdVrdoDB+OmsNRxCZ5mEjoSWQ+VkAktozSLdkLuMjik9x07XLEKUzQt25qJLqkF6EOlxuB+pRcZ7go4CfsjEB8o7TZaHdGg27z4Uq7ic1sbr7e3399fp67uXnT670ZjUpXVzNuu8aJ167dLuEW/DQ6l9Zz6YS227+Ksx23stUmO+N6ze5JxIQF9WxvRruBqdPuHN1f6HtDeLeR5U6jmOuwY8UouvLOk7z8QAcbb+MehDed65suv/zjnr4pcfYF8qWd4XcUoRJU7vTZOPQTdtgNf6TsfFLPyMsUhuJfUNC/6mjLprs+yDmJ1UtdCii3AJmKA0dyFgKMagdkHlxDSECVhApSkipV4HYS4w5IAHpKeN1u3PqmLCF4E/Xs43Lcn5TxfANXoOpUBq/bfgo+019lZfHUgYQbcNOBVZCPDmpLOeg4u+LfOsa8SpspqHut3xbEvQ9vjOSJFdwBXWmo1NRiDGkyebqhImNJY+A0fRutwZZ4moAy4OAU2J3RphSbGab2NN7PlCqb1SshhUZ8EIiqF5UwD700HHFTmT5Q5VgFjBW3WnNiqwmIArIdnVGbeu5XbITUBsvVVWyx5N/mOF+or4BuZsGXH6j9S5AWQrXlSObmcsKG+Iq1K+vk06INK0NtJPRgG7mWkt0Z5OVHweHQMK3SiapardPU5qSzqVKzm67dydZ0VMDPdfab1/3O+LYdHd0PtUd/N76ulPMCIpJTUd05WfeqG7NjFZYU0JTkyB6oVrP2aahL2U7Hldy7d5Ya0Sh0B4P4Pl8pFzEkJAZv8Cw+YtJe2+ZwtBvCf90RXvVWtB2+ztVXUA3T3dycI9UaqPUMUKtZoSZDcuVkSxCa/RQgMnxmWpLkGA4aIH6i0sJr33IXPCcgtPhbTKal45pskZnGjr/NwTfBcIuY8bzKtZzbD/olkG5AKBa8irAyl8TZf3iVZxIMou4Bv85xlRVEhnP5O62ozTFgc8bdL7AWBHMmrm9c2cmoMFilcXwBhfSIXAGBJPnrnQFB587ljkS0RGG3SuG8Qg0o4BPoCs/q3CWgUn6BsDX07CObU759/tDwkIR7n9RRuHef1lasc9/Zs+gvUyouQPYR/Zc+DscJeb56wifR9xfqMP7SkXGUWFmtXCYKD6+uuCTm6CVGaZTdbx8e76813JDdznvwzI9hjQ+OfrDtdn7b7arHDGVX1zJhwMpuojPGq+5BqBmJ+KFTUNo8PDhs7OwevPfFyffD5uCG9JYKzK8Um5xRx8Y0hgtOGxsH3BcCrjOUJRmsWT1Os2q+JbpW/ttmdVKzFLoiFoXAjUs60iJHrp7a3arIWxzCj0vBlZ5cvUJgVTM+9pd18QW4GkUPa61mhUK6K1pCPfmw3aOznondnO32B+9/d02xhsOOSr/RK5JXvLZaxdRknIWQUG+JEyyrEFOs2lLXBA7bA7Oi5Q+fJIRtesSwbrFPIpQcfD4kZbVBaVKgHTHs34+aY8J+cQHm+cKb6GyOHb54pmxWtrc57MPjjouNmFX5/sRBfDd4T+nZ1m1eRl0nOJBzCQljx4ycJgRtmFPvUX4O8LwLuZiDKm5YiGM6LAR91D4GQX3cBrxsQcQHjZZpQWAEDm/vsk0f4IFlUaWwJ9OCWhUrDqCeLqPRWK0lV7g5Mm2uLBZNDEXzycEDn8zrDA7/cpUNVpFaEi+9IRQ6wnkOYS034SGCEMh86Mg8+B7BFd2k0GTVkzNPPQFS5q9XT0DnjnoiES1R2K1SOK9QAwqoJ1CwtjmgCKB+GihfJk9qTadP8oeGh2SH4kqyv36BXAzoVQriuRocQniQgUULS/VqBUI95WdMTb4Sm3GuH7Pd1L+Wq+HBPdk4PtzbSwUqq3GIJ61h3O2KmWXseBQAu3F40Dhe22ikAtYVBeh/3kYR44IYdmDWidkWmu6Z0XTPPE1X5MtGOa8dbVcW/gx1lwNmSrl+fGcwKe2Yd8PwdeDWptea7Rm/9Uf1cjrc1r5LBvuP6t7sdK3InlEhKUkgH51CA+IcPZK6HMXd23F0FooYqiuchyqcn7BOol1452mf8YMJDj3mB1Xwk37YllIbndV75gAEYHETMNdVPMxN2xDmgHJ+0sP6o0Qt3a9HP64/StDcSTJ+1tG4FJ4c5oAaiQchIdTBzxqFt8kCD2LcauhRjAeDehhD7OafMpLzbCM5TxrJeZaRnP+skTxYtkWPAfA1FAELtCPwxtzwmTBG5n3D4bGJH59Yf4GZHyPgSGkW6VII09XQGFZCgwyZ/p3Dm5v3D7e1BZ/uQ14CHG471wABMSANlq7nhgtw4Ymbg3TUVDXniiE8pf5UAtUEyiZ/gbYFuw/TCI3lKo19YHAhzQsJZ2vrhx+3tP5EAc/PiCpYAyPlu2QoIZLAsNa39g4/JQMSVVx9LjR17pRRW+kvvBn0cMjCNai7wmBh0oBT2Qe6QFw/PN40AULCHUpGIitrZqKCkrk8wJftM0A3dUVuBXVI5s7MBUuwE8FEMg8C1DZsRw4jgfnAq05SusS79C+0+TgYpDMiygIUKAoPNIUjQYMQWqhQT8I2ZBeJ8SdEaWEFMBWuqYmo7NyhMq8DaWzKiDusbPkZGkHCQhALICwN1prArQ3QtmAtDucbIvVfOLpJ/3q317yOeOuCWSahXAlvOFdenGkN49HoptkZOj7I2hM8/Nom/NijvJL2AsR4skgLsu9oqIP32Gi44xvuIgdfT0gvfuCA2I5a2BXrDhReDZumVGVRiGq5V7n8HXb8uSvAAK/qfuO3HH9lG5V6owp2NBPPDmbK4jUD74Hw0VEDKs2IpwcgECj7YfxuagUnQii+cyJRKf8iXKpZcPlVyNQKroujg8sI4zESNMEp4//kFsrukxL1DCUKowfxAmhVudOXeh4ymoEoeUTIP7xmfSdQlTN14qowGWX82Do7yjO9GYn4E1G+wSjfCFcPiXJ1nkaZ1XkcyjfZUa7Oh1HedAhDIvw4lNoESoRjm+GipUan9W10FA3l2yXuZczfHwlOq51osAEZver3mO/GDY8jriWHYq4bX28rJRsbkpMq+k4hMBVc1E7I3+RUjweDpOpsYNIFYIPxXX5ZPFdxStn5b6JceoXydKXLTRRC4anid40QJQaSlDyTTNa0x8VJtmQPyVk6UcSqcXzbuhGTetWiQleJ8v34Lkoo3uq36dJefDuKNuP7fkJxGLYo/nQTRd2E8j+ih2AHPJPZx050fxQPdcQr/fMkGo/Z7nH8hsQlMHfOoWY8mGkKJHinU27xUO36P4UVOv93SrIu9p8CvWxHnX7rZrMzGjelL8FcJaGeVJHVXEjPFy/AmdNEuRslQVXZJMsJVfSsuq+5G+z4ZZvgOLpivOmGz398i1fyXLl8ieAtarNIQTPvJz9WI5PZD2RwQ8/H7GFtQgRjG0XDDhWjTUu6flEfZLfjnZpsd6GO5ct4LTfbUG3iS6gRmCTVaNN+CTVyN3WeCcOr77A3U8PUkXLr6S5gxSYCbQIrCALlVaaCafhHECSrkRWiw3MokPu6ylQwk0e+r6tMBRNwNwqorbN1x2PwTQMaMUYKuKqQESioUGq22wKfPcZ1+F1yfkYso3CrnylSNFiYDlKPzSMGpCZ/Sjhsc2EwktKyQxEz2WazZMBA8poSDhoVJKnscO45LWAYmoSyA/kWPfhDsuQSPBHTX65x2TVW6X4NBvo9LRb3Svc2NzTZzLiGO+1uTKpo3JD7jk3XFW+R3guOeSJ5dULgE1EBBdEE7JqOoWkr/K1T2f+dU9ePf2nqei+um0yPCS/WN4fNay45bdE55ZRQc9FWm4hu5cAfJcBHE5cNeiDJJylogRXR8hisQKfrtDvusjmKFuYHwpFppvNx/fD4vvzH++t4jf3v4OT0Zuv0mv21wX+uXW+snbN/1r9H/WGZf9jbOd7+tHO82ep9vGm/795ddtZPm58q3bXt47h9svawv7G+3v7Uut7/yv9em+x/jScHjbjC/h7ub27d7x/Vlg5uRF877a3uwfGHq28b6x8Of1+72xj2yp95wcbZ+u6ns/21te3Je9Z36/h667S7dbDOy9bft9cbp1sMkfdHG0yPn9ysf2Cfex9/P97aPo0OhuOPw+3b7c2tDzvt5Wh9t7e2u74dr11/3Cgf/P7hdHvzfo+1+nB9fPZ97er0O1POdx/Kgw/3o93f1242Pux/WD89qbeqm2d3i4361feD+j95DJDtSfu+/PXovDYeN2pfx/X5z72Hs93zzc34w1k/bn9a/8gqnRz/fvb55vfL+42z+G6hPvjMgM9//9a9Wh99Pr6qbu1PDm8bX7nxoXO9e1selU8frtfu+nH/0+fywdH81Xr1w7cP3xcedu6OeJ3FhY/zW5Wvn9nfl53W/N7u7X7/YHPx8/1mlwG+nWffexH7a63/7Y+ju1v21+Jwe//g8/r3zwvz0XGjV79fGH1Yaq21Tj9Hk48P48ONwWH/bvErq/mhvbnJ/tnYuf7j6/71Urn/aRB9GJ5ft+fXavc7Xz8d/b72z4P59Y/xXmu0Xvm8367WP29++/7t7v5gr72wtv9h/uz97u3ZVveP7wsna3FteD7Yuxl9/uPh4ffe/W31U2Ovs12/ZhheVw/i77vnFfbn+rdm6/i+ef7t8/XpUXe4uFfdakdrN1/3JoN/3jcOh+W7tZ3Dz+9ri9tHu4eHtd7V2dn7yj+3Pq29v9tnuDY2Fo4f2t8YoD96+3eLl71P3U324265/s9xc6Nx834QVxpHo+27weL9+mH5br6//s9P8fndcfnhMNrbbtzs9No7843W9fsPD0sdbmX61q/zZft0efL1/XAxWo43lxdqi9W939cr8WLn++XR+HxncHS/yCst3c4/3H3f/nZ31Dis7Z/d7l9Oln4/Pup8XRrdXa+11u5Zna37jah8tXT2fvL5fHt94fcPn7/zlRrufPpaeX9V//R572Pja33wUN+5/BiffY225w9v92/O+x92/rjtfuK0vHC6ML9xNL68GnycfLhd3DgrH0WdFpNLaq0/bgf1rc893s8f9/vbB5dLg/1xt/6+tn+z+7Dz7fCsdnR0erLfO/t+eLa4/c/Rfa3+/rZ+0Glv3Z99GrJWX/t9vuRnp9vf99aOfz9ubp71Nz7Ua3F5fXCy97119v3D1dofnCi6y1us0fCPxsOwcvjpfbM22u7v3R1tjvoLjeulo/LRcL11sn9cPRhfjQSTODn9eHj8R33jfHc3t6rDYgwfjIBLMikVgUPxNKapXeYNYyoYO3KrKbL9bk1a0QDarKSRK+5G/LF2fmZDBp2U3DLXYqcOU5NbAvQMEWzT6pFhIUCWa3bM5DZzzYKeVQ2AHpiqOkqY8j3VAL+BglEpUSpabSwb5YVEX8zxt/JOXIxkk5xoN4VNjneAkuji1Lg9P4xQIgIvqQjTSS3wUzPXLtcLSNZXMVt2KwW0o9F4GD9QGdqQOk5hB8EOhaLwOAXL6VOrrM/aJVZanB6VKv+sHSKlDZAAVPQf1WEm7c7p8ElTmkkNdDo0JoJH9ZiuMDrdAbPBozrMplyKC4CS2THyo3zKWWLguClOhvpmm2y41Wzd5PODZmeIjBjH0VWX1+cvAyUH5FX+LH8ByUzYzoT6ivfqjwwiM+BlZ+f5g+ZBMcf+oyAxTHJ5XrMj7Jjsn7fIdqjuYVjB7GwBRDl4KR/8ijp/dr6U2l7oY+etoq3KUDb3E/YOCEUMxu8U/QAkkwIME6EvkEB8iZy9OeUvAN/lZKvkRj9QaAX3dokfXl/Zifi+G182uw1tQshP0Otg8HTQWBlKTuSmsPlhI+5dMir81BnfyBBMeadFMTcpJIW/cXWUWL0gFcFcNBa8qSx4BwNVjO47QkgAlueS+4ALLkqLiRmhJ+zytckbZwH57LyDlm31Fhd1CR91mkoyAM5SnQeR5hVMNG3TBpOLmmoVkPvYSW+LUusKACDcvo+emKui26EuoKCK3AFUrz/A35dMyvq2kmk69Rub557Q5Z82oSqEUazfPj95gvyUxPqGKjF9a4XI31pJSOBayZrBNWw9UtdfiWhVCbSqCWhVn4zWhMrRDVaMTHVH1zfFyEWeX0AFkkPzIhTbW5wFgcjeogzoC+cIce1IIJQe50KsCPtTB5d/SSbVBqRUkNEUIA4nHCkSB66vyFJPU1EH6LTdUWEgHJIILHvwal4EMLU3YyPh5MBvRIBQH5Xk5YLxvFjlMWTx5Yo8puxFkwGk2zI5pTRoXkdnxLdz36mJ6hNEyop45CMuiCmrfB5nqpfYMDn68Eqg5GR5T79UFs4so3+yGTGxvizWFTUSxjqp4QmvlHCzc6rZOW+WjB1xlU2gNEugxGOZVeG0G0yI2ueidjIqn0GkBehzIMKGThKbqqtzvykvSGypxaLU88vJFemTJKbty9vxOO6LOMJVfuQRKvFLMtNp2J0lQXHHloBAAqCkNnko6xPDeAniO0ORL2WXmq1p96NwYg80UNVlZcdWI3o6aQ2rW90e2wbDzqTUY1u0M+g+rD98zH+MuNdUTXh+nJ1vxPGQ524D4HgMa6QBcMDRmYjYcQa+nIsv51Zw5ZROkdZeT7orscVlVd5SVeRF2hxRcgwan9PwG6gKCV9du1EdrMvWODFMFiJUM14V3jTS/qeBiulrxGxP5b0Oi5CB8CU/LwAxy++YC8Dqz7Z5/Mh6LU3UoSo2nqOsPYb2M1G/j18i8s62xFvCipRyIp9vHv1VPlR3sEKK37dxdRyuld7UapGGBaY3zc51yeZ6AyVsrnQg/NCYZDw1UDE0YfI9H52H67LxwOqCaTBKTQWO0rVBMcSyFCvblnRQlQBnoWoiBkNVoPlMWqfniZ1irkPV8JhP1p1AAEvaEE/mVEHC4958uJvac/aSejCg/oVRqcqtSpzu+B9skcQHtkyDWslJ4YbnUViCtaQ6qBZducYzM4RDgyYr5NavXaA2x3CuiX8FygUcGdaarpT9ANV1eK9vMjGJ35yaAS1fIs4/lgu0em897h6jq2TSG6xr21+mxfBZZ2TZ/rtoJBwfzsC3my3jAGqQe52sTkEYB9FkzOGcWVMooVq8An3BrWVbvwsdI3zDwWr8UVLg8BeBiG+H4r38dLpF4OSZhAYlymb92zGg15XOSCazp/nz64TpmnsiZDNfWP+izZ/eoIuhyZhN0uNegyVOEJu+K6GBRpHO9WgcaD0GkW4bMBpjEoeBqhant3xYrPjXvzw2r8XWwhQGixTmRChvQAwH/nYlHTPCVzbCzumeoC7MUA1ZmtIYL22SAzyjMw0yj669yLVmK1Xk0RmdpQ9OIySAgPznJVKBJ3M8cFbEKjnU9IaI1FGp0TL+LVXqLHqolpPTNe+nKN7pevcT1W4wYHjpOxo/dKNSy7j9UZ42Jfme11iPktqDR774GiW5Jd2xXozcPxLxeuM+LXYuNa3Ako6+8rGccWxWCYibJp54NH1vU/YFSNjf81jpmVRI3RRp0LOC0OfSNWVzXoc1YSiFiMCcfDcyJOYyaLVeW6kWk22R9oy4cUA/EE9Im90rfvrrlB/5DFaJuQxWD6Rb8I74916n3RYJ07P0MvuYXsQcbcTRld1Gab7CbCubZ+5yigtcmjTpJkT2j1K5Uszp0jc2x0RAfgKDnXOm+BXAcU7RQxHOzmyGBviwJTUs8iiFYvEP53QjbAYp24dqEt5FSbU94TehLr2n0Jaimod2VtIGSXQOSEDRmP5mcygSb2oTQfZtlCvniSssLhP5iZAf2MAUyh+eTYkyl+gNlrcWnkGRlz8URdjrBygWy/RwTL+9iztt6DsiqGMibqldC9YsjACRl/G44dJMuCuC+SB0AcSmHh4QWHPau+YtHVTCdPTgdPTgdfTgzB0wEvHB8OxARdE//wtdx8jxPu9w5WAfP1Y9RDgyYlxmWHZUgDAIY9qTCAMgoD3Q0GwIY5PQXt2Z5BwBz1MRLydvOuvPFRNtiRnzoD0UiFACz4Tmo7CzSIHl2O702yqHn3JbZopEUThe80BGt30ikkv6izbhaSeCiHND0IRJ1QxqgR+H4puAy9MSfRGuc6LjQiA/qrD3VOwbaPG7in9vd4ajMU4sB/uW8A3FQGg5CcsgpL/e33TYcZlnhXO8/jto/VM4cHtChS3Cgdi9FXxzJbo/IIZnujywDbgkC4srsFiL13qMBxWIJ+9LlryFma2cCbEsZa8pvjvjNRjz4i/kNmtHl7fX19HQPd9tMzFWscx/zURLGgvOoz/NVWqa1QSxwlk8y6LgnR2A7Yme0x8mEZ68pxOIinX5UnqwWfLkTRxRiPxm5XpyjLj/7KroUnrMIv1ZgOkwEGwyVM8o/zFEpWN6ctu+04g5bS2mtm3Ik5X9GY3V086obx2MpvIGdvKIWAdfDN213HGhBYYIuJZsnR86wk5gf0qmyW8WrB4A2Z1+NnjMWCXPB1opwaSKL70HrK7lxnWWlVUFEtq9a204bD7kiSkouM3Mm9uszYRr5GTaBg9TIzbNUMbxuNl101eZAieHsLo0or+6QK5LjWiiQtZ2+tc7HRGW5tz7WDphf3Sj9c74KBoedSZR9/2w097ujDWYk2i80e0M8sIB8DhqjZu8vgj4kUJIhce4vPs2VEDocoKFDQOYStS0swpGW3Kb6J2NeB5qN3MiQ3eI3PMdN9s8rcZBUreRkFdhQI4SSiRhDNdTtZSx+LDs37xrdrp8c2lqQCvBoziZ9Duor2a7zTMBzBJl8qnyGD6wDg+X+6l3mwO7CB5Czoe5HGnDdD4fO34P1PYAykAZ6y3wy+OIjia7UXTd49kV9H0jT5CprZKg2l1n1LmUBsuXbhn1XEM5to5kGpvr0n7UHAmdWdCcpc4isVhXMU+eUInqyJkbckZJ1gK6ikMAj3Dd+/29qSTiG7A61fKK4/XO59rJFIrXZhZ35Lb3SGHCxZP7e9fjHfblFOUU+5ajmkxWqNIHWfrw4JYy0khAETj3SwQFbk6FHGS99/e4vecqkLVbOKjydGMSG8BFJPOyEGOeTBLH7M45fDhAjj9pwZKGNhEPGdyRpSIbRPVH4L2R2uv2oH3n8CzkVgLPY1wtNcPt+H8ZE5T0IGPSPKey8iK41G5bzqHw4oOlpyo/nkMqTNR2euu29rAwR5VTEcIMbnm4J8ZoT4w9PsJNWlAYR7UxB+gIfpr7B27/JiO4H0T2Y3FuyJTln/SZ8TzShrgl4cOHQ3hO4BMsN4ONiR/jUfIZeMLPX46RohoPL27fjFnXFQjP5mXZR8JOUIvSshbaoaQ0xfkmnLCkbvXEJcwbStcuDjR+n4SFfH7p4ji3EaeBYOlJHq4aOnkVPUt0SlZ0PlvjrYfiC/LNW3hhmfT+tLV9IOvrXfdvRgmPX+FZeomftjJvHjVvE0jMWjK9F4RiLrcSp20uuxKVlQKmUcy8tW/YtccMNEOvNI+dHrkshLIaIFl/NaZQGX/+2gVYU+qsTdXVY8hfpIPAnMmdyEwzcv/LudVxgFtdZGFXTyXDudVE28PP4lc/YbX+9vP/JMkh0zr9fSUHab37n7vq3vxnYJg3z0MSyUsP1jgDVk+mgH8fIeUxK5aso2VAgtexQktQxlkPyThpSuJzCTj/mbJN1p0C5zx90TPN+c8Vj+Te+7dW3Z7Mln8FR86o3v9CjvwDeOm09D0xuMA0flnq33v17w10PrsubXe6XduImGsZHKQoejGt+GO7pFaDqO+0yHhbu9Yfd9a6neboua9Wf5IpWU6FtByfnWeyHdPfS5dymk0YqIk275JbQDMhvcazwLyaVt951DmYiHheuNv084yz69nEI2nBkZdEZ3yXZEd31jNo824xWLkEe51+FLhPP+LEaDwWt/ODSZHhUXC+cdt4VRQE3pAqD7rN+ESSkiHc/H0xdy2cGYEbHVtJkTpIOtmJv7essxR2WXtnyvkNuu8y9xbAcvzmgLG3Mzr5+J7fZ+Q6ffmGMr5SjuudFi97Ngc7gM1f5mXnz8i/gasdWuu/znHOYPA3854zLefUNL8TUsK9ee91DwTJey09YseRRsy5AXJREjkCEVzu/YJ8wjfki1770oPwZ78vQr+9An6gfA9/Yhc++Djb9ekAcTjU+3r4s9vpdcYOAfATkI8Frr4c85/92dkvMNLTdl4Nq3RW1CMsnQPu36PdA3P26T5g3hyXxBgJ9zAmgumZTwHoXU59CVxgt2MvLif0Tew1J941JI207xPZg/6QiQPOcQECioDObBtX5o7cQWI23HO0kkY+0BvcQCsKNF1Y1cfC4rE78c43L5IGFeErPqiWxLOkKpbVg0TEmvEnoRVEOkn1q6J+FdW3Iuw0W63zpeCyHNytAraCCtl3+Udp1O20hCtfHwXb6Av2SQgQbI6Kqq33kmOFcn+QQVPZ2eoyY4INeRzIzo7v/Bt2/AWT0NHgvkw7m3BBkofvaUMBXEOoAumMAc+EZKZqfAa/FArJN/lq7eDMa49ljpWI9/g55gOXItyIKV/o2f5L8UVrBSE/X/3gUVYW/v88AtXJOBqI1+vyoWOwtANAnasoeRLk61z+3j71uAcK5L227Cb4oMoOv/PxhfUkUAnoPy45S6br1AWHFwwP49ZyjQcyEHEJxBp2bAaT5KmkaNiHy3nqC5fzpy4BjIMrzw/PbWgsPUNWPJR72BwgexxT2ArXjDJ3b6MXFz7F6qXRDjecCaopEOrWDc6XrKD1Elo5FoGz851PLo3wP5RRICHA0kO5+KiX+wlhR6QscRPQz/iOPnumHd1GOxquQQ/u1jO1W9t2tyaLqv8BmzWwVVNaJmxHhNmv2XwTufnoJ5Y9sWZmVHynnD19p0zI7dDQuwXvTElX0rYzVXyKRsImWkc0GLJu6GNR7Z/mhIdBVgHLR53ebbcJfcXEjuJ1fFoUXzt9kNqu7IhUTg1XodanqqgWOlRDhc9xpsonL1fjk0470njAxwxinko7w+/IPQ4745n2/0AcQUbLf4NUW3NtCYOcS5Zl5/2FK1Ux8V8ixo1cTAG4tzQlfvkjBaNT+bWV7VhaMbfFt3xlobY0b/kV+1Ti3a11O9f9npTfK6gUloBRV9koXcsSXyZ6YUe85BXMCk5WYr/YOgbagzeptre30OXefp4LYuFSI/+mk1/n85KU5mAPSbRYKITRlSZZaykIrvjjLOgc99N+Z0y8quo2L6Pu0TBqsa0b97G5j0B2YGoCg5gHYy6ppYVvp/OtIVK7QOQBqVt4Sob2dIVM3K7LLGv9Kjj5iasWkpH4AB54tEbnGcdDWKR7cB+m3GntKR1J18Tx0ufD6DWKgHIT3/OHbiLSWEfcdvzrXwlj5W/OygX3zYHPZq4ZTGFPvweSXpHiY+x7wX/iYIwRdwW2ppVoboFjKEDfsGnr8qn7HA1j/31MgOU9Ao8fLzLAFS/0AR+b44ysWhC9uGV1VjRXL7g9/XCWXOwVfklYGsfbnUnUzuPdU1jJ+kKBN5Nnc+A9gthi4AXCO8sD8BpD1gAaTEFyMNmaCgnhTl2NzU+t4C8EvDw72iaGZf7Ut2ODojpuCllewPzA7EzeBpXGnXE3Um8skek4MNteW4WX+uQvQMKE2UO3mnrq2rO1WiKOXVgcOJlhlcaw0+t1RG5RR0eU4zhTl4Bo4Sx1zOXw6wpbMpvDD0yqlB4q+zgX/BH4riFm2QCCGAhj4V/3NYbN/oiPS123nhU1/CKUPOYErznaFTDe5MCvwsqLAAlmWmv3iyZOuwP44+GCJlXc3TF/y25H4Nk3wcSu5rzHbbKWL1rnbTMjTpRRxBZC2NZK837MGsfDMyD2T1RyKLXZwBt5EyHJZKLi7x3VDyh1C1WIm2I7vWgj7nPfBqYOrkcjEbFRAs6rkEYwspEMkSQSVEVX0TDqt6LCkzVuT4LT7bVhBchhVVpaBTWRgGrHjsAFpFBbu+AJo7Owk6f5TWiRiJJGoA+HOvbckFLuyRoQaiqBAzdUveDIniAcAJSG5GdwLyToziMlHreSkb24zMyPEfeFq5qrldmCLS3Ml5G0NvbgNWIDTSXiifJtnlxu+7bbPY+awzzb0uID2zDjG/6rUvD2r/A94bIhWGnnAJgkGB/GaDdZ2wPl7hBauIkUUrhbyFxu3rkN0irfqkoNtn14vL/WWDttHDrWFiWsJM45mzN1SMoZ985mwpdqSsA+yBdTiEju/FDSEjwCkttRX33mL2yFQPZ6zdPoPJiPN3prEMQzpniAuYwcA/6hYqMDy83ZHkc9P1Y2T/WPlCsY6jrhH+TlYBPaXYM4L6cTZ5fA4tLa+snh3mljizJTCujbmcjtMcQmIbsk5xGcBj32ol0kvWjutL6NBKPlTiaDZp8Nm305ioYnUSvut7lDAdi1lUi4GIyN2fA702B4U6H382DiKy8cbEQHb8W71Zk5HpNDyIK6u/ycqAAidBBDZjINbpShDRHFxxABsqFD83nI8EcZr+AxzPS7suOuVIHHsZV7U2VhWJkShjnAy3g8jnvKWCfXAVrrJP195C4LyHcWH5gAyD/oc+yNFVWzm+gUOlMqrD//JmIauahCy0UwqE8wDykVNO7xvp2ZPDNTk6LmQRJUF6BllyuERok3udjOJjMrpIpnYahZZFBDEJQImsPoUTc2KLOsfzFDOD2g2x0Ev+BmTrDKGxwKxmk2ODQwNo+7UqP9QYrd9jYni9StafnwSmW7LSev6ctp1xQBd+ReSGJXTPI8kQIOXqI5iuSM1mWYqoRyyXQuxVMToRRpJlP4qXZpKjgYkEsAWazCwbmrxUPQN4ejaLsbs2GaKQWHvuZ46gRWLiZZpSYww8kSpxaEsZwpLlzjtj2wlEjHv71KPUkFoQODOZAuLU0xUNqFDd9ajBzT+FituyRAZxMBY4sw7A2ju058O2rYBXo+vayq9TJuAn4WXun3spqrLdQp/U+tCT8ygUqH4ow8RkPkVq0eG1ydiQ8VfvVVEHHkKgVPKXpqTwm6qNZC39r1w0PH0T2DoYP49IF78Om02PQLdBEOi3u5EeTvJ2tPufVQi66uPRIvMmRVc5MxzaVpAjyjenMSQGIktz7O8asDsnSO3x7UC+Gbg6cwLJWI/TEsy71IUHrrO8C1/asEw82TwqWlraTgWf9H8ksyVBp9bwCHYf/29PPtPLkM4g4Hj1TIvXPi0gfqHwm3SeFQXJCRmgkh1X1q874IbVwxV4btA0MBkOEKrvDyyHsQv7Ge58fehNibB8hI0lQXfRehzj//hgBfOKRrdLOQdGcFJcDbCFCIb0Fe5SqlesCOlHGyvE8EubqXHAXyzgCExHNo2BcrxTWA2ap50DxweeA10/aCAQ+oOuEiah5nRxQtztDFwVjqSrIECplnWJVt80eU7kPjRwfZFG8CBMR3OdcaIVF6LXtEAy6bLOesRiNeu+VyJF9XJ3owNVDGK4Sey4OuzqxMP/4eP9G50PbnzO/N/kwxN7MdXfJ/9ptD/s/aYCh/PfB/fr/ty3+6ouz2mv9zEg34P4etMf/nIL7j/2xGrZkvYFIEPu/cpAtiRbXOwbXitCVGWSxN43eYbxvmc/Z0EU9NJxOJsoqeus0++x8nLDHBf3IIQIL64tZut+VbEVFJSGAFwoaoa+/sgNo78e1wFKzOJ2NnRz9EfcsOGHSgCEgzZW4U3Nlxu+n1QDdMZ7sdR8kd9XrBjgQs2VGv5/segI6k1TO5o9Eo2JGAJTvCr7XFdfgV1k/s4Lrdzkh3zO2o5aTur66C3Ysegt1n7j2xe7WbVpWigYevGQJjzoIEZ3MzIg5zu+2CsRvoba5cqriiD4SUNz/EEc4Nyez/vRGnOacc3ssbubbmT7YQ7M8S//PqasUPcOqi8FMRyND/Qvn5EcjQbW2h/FwdZ+gthWKydLYzk3zlBl09Mcc8jrhodqcUCM2jtd2pKE+toj0VPL437VVJuYyuSs6cu5JyGWsuYCKmvjPJek8SvGIknhJphOCFyabN5Zgh+QAWGIA5OzHjpp9tC2V57PHEkHsxA61vN2BqlgE/ZnH6RTp7F89I83Y1Ke9rWvtzun0ja3ubOR3m67tPezWSBTEK8M0UqR59yM+RPEB4urOVF8L+tDnIB8RF0Ry8EotGTGptRxPiOyP51s0UqRwYCtM0eb7IHdOG5DDvZ93KV2wqNrrxiA1eXkSZeecvZ0UmV8eExsB4iUv5//RcyGDGgypkWWZuZWH4KSOxngCuupN6WJsw5N2RPPC7zF2+sF9KMoFWxsrfsS+JHKWlkrfSTViS0jubyxCOSb4hLp0X3BNSE2ByK98l2Od+7WjMthJjYpsmk/kqxEyzmJRGMBsjwuVM4HJWMCSZCMe3P8Ft1ZneGmTZkgWEnclNAgiLtqn6xabmxnh3mj2G+tAziJjcESSw8+mBCcUo3GblBXwftcXk6MHICc0C+tdhb7hRjtFxmycjaxdW0CU6hgH7lEZXuq1AFWd3RBmQxGGT+NgwT4YwDJggEs6m11AjaUNm7MTZEGUVjGRyFmMqAOTjnoU5WD4kYPkAsbSZGgPEOsuH9Yra5zLR8J5U24Q1rUBQbjVMurMcl1e5FMgQJOE959FT8jjKpcXyItmpt2mKKXg/HZTBKsMUFJ8+i4Xnm8ZfgzBnDlWRchOxBcJEFzqL+I2SSJ10wFbE7g+kmARYm8rmxPSz/xr+Vz9DPyqkUW/gijNcMDSyAegBPIT1ECIsl4TEobURF8kficjyv82zFaNI8VMa6EKlTVTr6HhrY/dk9/Dg4uBwb3d/t2HawdHCYVAjfgA2GBM5zJ/6274NnOO7BEoKuFMUkDa8djRqDTuDsXm/Bi7H7bM3IWl04+tKWfnG5HUX8Govy/Dk0yADPPMwX6R7xerui8Sg9e3NPNop4m7t3n8ghAI4oq3vpK2AZYG4jaYf8vbwOXsSlrqJa5ymHnITIHUgRM1R+PNPiDaPuVUoghkrwlF5Dsdp/SnR5ln6MvEJ0wmA/m7FtCo53044wgDCqU3DbrzTrxHDAE7Pr1uwZ+942tV77OJBvJ9vJb0YHfvNIauNPIzP0owlwFoGE6n3JCht+YdJ3KC1JminQU9cGvbPRG+s4PsWGz8AmE3WxfUzf5aWPXhaSlcQfCMeHCummRk4+WKHQF3I+enBEqTZFviMgRtErUE8f/xXigCCxiRUmVsAPPsqcf0CTfJJt6JhqcoJuHI7GrdlULDxUFqQgQY1iEf4aWYC9twmP8x6hXq8tbfW2P245XtUQejGmfmd73CjcAsgMzFO9rM5CuJKWh49MC/CBhd42UtEZc6GVyhelGj+DmzQEr+RlxcUdr1/+03289ZstZIIFetX0+Pw76oH0wTz473x56PeTctkshH1uU64mhOmCycXgVSWTZXAtg1M1oNZxFd821Owgc4UIku2m0vDaNBttqL8zH/9l3BMYP/1RtKPdWQ8ea3uXSWrrkpCzD28ys/8vzMFIt5CsPb+2vEfW8eN3f2tUEM1poTBPGaP5f7hVBtFLX3tZF4vpdErvG3LvQkoc6kwsnAlRydZNX/aVURTyUAkhlIIrMbHtb3TreA6GBb/VbL4r6GLgq9uaMHQg5CvoayPaE+O3RuCr8QNgdyMnF1702b3Bd+QY31RwEhgMAZ6XJmv4czc3AzVPnnq5bxxE99XN18z19fFeowJvALZWp+lw5kZqsMXSb8z0cjpwW7j70QiyRMlsE2cJ7c3rqk/51KlY/CzVmpv6/3Wwea/z1opfKdaLWm5e871yoLFs6xY4GQ44pYmLm5vNLvdS6av0RebzkCyAjN0ksk3ejoblde7b6hCRqRPKcYqD55rR/IqJKQbmcJ09az9hs0hPhRrE1HCoVboTbwQbowwomOCreITsAw4dbDbTthg4s+CtJr8MtSEJM1pF7kZoeS4pGArHh27m0Xk5ZH2DKHgikpOklylq/Bikbo7PNIwJShScbkDyhGUhJGTnS2A0iyB0tzTUWrLt79p3adC+vEi+AIkI89IKKSeiXAELfUVgu2Dj0OIW7Jk+geGGHN9pUsSd8FTuzXAZ8ktBvEj1EpvkyUcRM3hML6nXMRT2lkN9V2uWqfVObYOgt9w33nvIIUrazdhGpYpU1MoZupn9tf0kwIkAxruu7kvK97TK37wHMXdh+u4n7jGOkK0WpNUxTF13d/mFv933dPWnTTWz/091z3ZP0qFShNm+4LrbiuyRLlXCOLf0fnUdwltA/DvepEQNoN7uAdt4LZmwACOHIpxdccrsvRwwqd6V/kMqnnX/p+e+XPtrtnp8u60aG7nhYvHA3ABNUgSennfDqy3wmMcUZjXm7mcSNc9BkLUKzI0pMDgwCKFyQGfpLDSMQBy/iBNlRCwklSJqaBN8IWCFXMHIM2i9hcnRVuz1Uo7XgMh5q4fHm9uHXuiHXzRmVVoTexLCLBJnXkb7Vm61c/Pzt4Qpw6KzBN60IebPDJKT2BmnUf3g9La5Sju3o6jM3NmQoSC7/AzyNs6PFKAnHTiyozE9NGpzpO804v7ACOGTr+kXkcy5FNSX6F4iU/qVtPRedY+nSQgdmnP3aUdnf+J+LF0CC8wXhEo/v44CrCLLZnU8HtYI6b2lFWND7f9LTy3Cvko523hdLXT72egBFOdz64+rr+QYuuMBqVXn36mPw7HWWZa05wc69r64cctn9g0Yuat+yCYc3ZaWpf9rm/tHX7y+xUzPHVPgfn1hjHtBFPGswGwkzmJc8FSgg8h+5IUkLzE8TlHSqEsZAMdefwp/Qvx5ipTcGmP1BrJdi42kOZ1JJc92do1uvJCUnvchtVJLA8at2g0SBMXgUc1BY/q4wmT6K2S0ltl6lM4lOx5Nlk2BI7kD1PURTHk363yiL95IkgKzmaHzXMcSU+wHiCjGx8T6+sqOXDs+IZpl2LgIsLNFlM2h/mZjWa/H/Np4V5ETAHmeovcIbn/h1+3dJyLlmKuH+dGt4zqz0VM7JnEd5/8/6SDEn/Zebp7z/9zA1VI9o1pIXXxOokVib/DOXq7zdFYS28J7yxxg+OEBkjaDaXbWuWYh6oYdYNhH6pjUS6Hqhy7VZiu3ItjVrF/vR+LmJzn6ENph/X74bbZ7YwfQAxOeTqY4Hj1NAVYvHlL033lw7hwxqwRoQvOLJmLQdOcipHE28fcUW5kVbUKFZZGZA1Bw3ubi+Gp4I49pmJPhh/34Ou65NCnTODO/SNXzr3BnYYWd/0RXUhRO9wLuOiFmb9jJiZ0mwM9L9KhlZuzbR24FQlHlwIYBW+5xhmEiD+krEbXel2bTgkEK1zRwtANbdHzBOxHSbNZTwLWyASs4QLTaf9EVRvPl/AHukY3GsjNxTXIplJTOoJMBlT8BTwmC0+Ore7XYRrOxL2dhkxz/wlMYz9T7FoA/JsE/i3k5/AN+zl4L5y/wRe6fH47/kvnbyEXiDRvC95yJNPVJ3pe7AeD5O6bbKzbnX5b1sk7M+/ejE2KQSSEN0fTJHsI1BDZwQuZcrzkXB7dinsDpiiL1PBr/TaPAprf94LDJpxxidttL9vePc4E7NgF9iiKFQfYvXUxtSn8kva8ni8RqQA5uCW8iF11Jzs9HR47ABhyb+xBGJ6GacELkd+B76wwCNbvWbx5JSiPvUwQyLh0B0Wxl6tZYlGowRocNpqtGy4Icb8b6tlW3/BtgPdQRWgxQedCQSyEG773fjZWwgTIrZLx3L7xVg1gxYCaSCMJZ7G96ghOV2KGy/5N0ptlnSqxmFBF5VpMoG5w4vRvSCriK9+IB/sJa9+wdGKaSM/ypFZejBE5zcoU4VAKgUoCJl4rhE0CMvQ+Mii5XmMexlwx5Wpwc8jYUbvDWLooMnA24m48rBZz6HelgOOqhLybjJFmKkprhIuelI94yuSs6wkQceZRMO9CNW8gQxKh4MhqR1HfLBBmQbCCXCL2J2orlqGYI3t1nn2TC6Ph/6cvTUrkn//UwReeIKAYTeTcZufOIpqgGcfqTCoQcdIVVmhPgtwjlCMYHkgnBnbzAwj7HJ9mt+DRct39E+S6x4hqYFRv4FDc8EiEaSUdfgHYTEw37NS9v380WCECgoQTYPIB4P/Ze9avwK8AuQKdn2YMGSPdOL5BE9f5CKWe6T0Mov4lknPE3mLig85IAx+Wcq8n4nvGJ7bErrGvYp95XaZ+ojslcqmkVkynC+kJLUOODDl28CWkU2WrL/I8mBeQDlubygZCWUCCMd6+hWO8jawP0moubFKxRgRDbW5l9nkFy0uuuekhh3XTEbhQT8g+75onwlh+Qb143WNzs/Y8mQIjsBGnHoGImiG79J78aFTQRVZgCues40uVepRLM6oHmlE9PdqVwGX6dfouXXgCyMLYDa24xy1a+ZlXr0TQcOGIODdgdXMStAgC/M3PUZMlfiJp2eu4lj3LSWetHBGfyHbm5X1AoJD7JcFS10m15XWULa8IOE3RsBRk4APcfXY1HeLKdM6jGW1CeNFMxdyrVzMoLM4dYajhq8sXF9YbZs6G9tiImWkZ0cAMDxOzoQ2ny4Tmm4TOaPjRZMzoTIOvlMr28uzOSiJ35ki7A5LGHSFZuB2WIG/zC4ETHbLnHFlye7kKic8cQWhzbzQH49shPKBsV7pM235ce596GMyKr3OdvgwqGV+p7dhpjU4+vsfhiAwNHkciMIIBOFMg4kM43b10DQBZrJChOu24dctRKbWGUXMcbXUjiVir2b9rortzon1Jx41Si5tc+UbfQ9+Vdpy0MdSiwTXDpyN8lMQnKdOk53IiNfp1ogeCqCKUBw2FWoGiHm/RDKWYWy6TKWz7YVOXpS9j9LqzQumdVUTg1jkGWwfUNYflHVAc7hzLBiIqFcODq9naKf5dTiTq8izBNzHQyYlEDUhYmXr3ur5NngttGudYoa7LXBbrD5c4TOnpCbgVgLgv1t7qNAt4Cfeak1CD5sRtwFGSWRh7KPeiEXrBtX3a/DrwmhMKnkWOXEwXXpjCnbHxP1w6F9nUQNwSkr1rt2blsnTnvKDLSyW0R9XMvC/Sn67ImcNHX2fETnp2trYDR1eB2k8Z94X/fE7cfPsbxlmTO3x7nmXLteM+0w46rW/jeF2YedUWnJfbb4pJxNp6NVEjvoMacAo384PlaFV1qj48PgqoiYjHYyTaKlKeq6UJWZUJvFWgRDvVKPFUqB2CmFR0zQNTdA6LSn769sc7KISEym/JYRj6IdE5XdVBpPlA6OcijOZxiGMpxzHgQ5HJGpBqFTBDQOYB4zEB+Gp2TPebk5RWTQJFwVkEP+C9viXjbqAJ3Bd7sAyzk7k4yKy7ZJWEIBfwQDcYkZ1wDPQp/YpmISHkZqdu9+NF0lRQlGYsC4idNAD/ApYCO/kE1T6Poj6lws4Z18/T0KtWRa8+KSQJSUmPugyBBHg+jVb9nHFp3DAxqX5bqaFrzpN18nNKKf8KGcbUyxPsU+npusuKenFI7kCvV8gNzdVNL0m63CelVQnnPCidQv5p+0mSivdJKVbCOQ9KrV6Kc4EusYT70OXZ78Hz7//x4jGsXfaSwNVTeLrbaxJ3fD7e+FdvOStdg50T0tSyyjBfk2WYkDzxNU2eSBfYOAzvIPkWOkie5SgBPQr5zz9KnBrTHiXU0T3F8ZJFtc8SKfYx8WKzhve8w+E9M0RRzT9zSEoyzqtKTe7TcD9L+BhIy/w1zxmySKnfhJ6WLTwYpQslOkKFMXcBCA+lzHa0YkCP/eEaV0Vc67jfYR1JjxK1q2glG/qolES4DiJ4EOFxKahLOV1KPb6oWHlR29L1Hw+FUNjblwkG0cILPJudESNLIExBZ9UWt3V+stbdkP2RP4dZcdvtTN+OPxIbDVv+2zdqNXkg36JCUf27U3ChtUfjbNCCkKxLiYKHM18nzTQy+HPy2e01ryPanqyGXtRYF3PVQjhRR+Y9M/V24UvibBmnhLQFVbyI9ln6TNqMwfJn7D885kxsAm4VtkM3boejeKg9LZ7fSQUwctSjdNz4lX4nDibkwEPZ8IjbVHx64pnkafvI7tCon94ZA+d05Ri1PYAt0W7dxpQDHAYO4EwyKkBetkdehusyjSzdai0IPilRk4elpXoPtYBNPVwvZQM+Bh05F7MpyPi1UlHxXARcp/ef8i4xcyqEkw4nl/XO+IhNB48I/n7YaW93xo4Hq06nkeYMC54vP8sDSf5mKOX1pROtKx1DoNjT6BLpdp0Zh46/do5AzIAResm98sJ9qM2J4I/oYTO+7+dHYkGKuQi++I6YltMW8vfMGg94thddjWew2642kZZLVZv5Lt0lMoe+M+K86JHv7RgA0YP37k4XYHhD4UXgE7k7EHEt8YtHMhsayexTRnI6mHHcz0WC5E83Edulzvnm5xnmQfOKwWdWKiRmpZyKBSehn47HHEKE/x/oQkSvl/Oo0OBryi14280WN2yobK2D+D5fKVXrRXOtXqmWgZvoAWNOvNVZ0PGNp/SzcK3HlW35Ltjyt99ysFolqlGx94TucDsccuOFMmCmUqPFA7V8DaeAhxNlyNcW+H9RLnbYe+ARMs/PzibZpmSls2a/Do59LmN7M0HgpcF0s5C0Ib2BFYMDVt3CKUz1M3eQ97YyptqtO26A81gvCk940hpWt7o9RrzDzqTUu+2OO4Puw/rDx/zHiKNUK20PWX/nGzGTJtjGHDDuf8aAiT/OCzz6utx6gMijM5lZBXw5F1/O4fio/StAnxc4fLF/zoWvzD/Y3qzz4Afsv6ob1v8w4sNTdxV6+D9WXihh9ULFltFhldjpdc2nbksaoGyOHFW/JX3PpAxknLpevH6diy+/vh6243734fWxCo7y+vwk7nba75u311Hp6+jFXXMoImoeDWW2UR4Go9VtMk2RT3krZrrr8JZPZ14vgpiD+JbVPW62O7cjJyJIp98PlAjRV2sBXoGU1+Hnh5ZOZAO/TsivkiE24gH5XV7MO0XyAkWL5L4VQCZw5/+/4LaSpprUAEuSWthmeFRPuuFUnTUnj+xMNXzMyEAGVQTL/X6HPgqK59QHCNLQnryIGuXOuaCnSdejSHAiFhnzaDNZtBtfb9/2WzAA4eh2EDl1YS3IGbkfmxkTpJWLnhf55kJ6QZnIopInSTs4Y6oqAe1qbinAGdUc658n0Zhn9Rmh12nqSeVAPtk0vprem02uPIg/SutdJhSjWsQ7YlXCal6L4ILy+a0Fwvnm2vD6Ml+tM3GgOl+2/ykkQKgGIZTL9j/E+Kx1ykRBkMVgs0VDYghsVdgqJFQYA8jVurN6J4NIcNNyqeJ16i52y5mi98Mo6nsVwAwcR21YzKMG0QPY5wMgCzk1yvtZlC5OFg6aY2JRuYOs4OZNwM5Fki3I4jGNtTujQbf5YAI02eNh05aUNndPjvbWzpfLYfQ5x+B/C3lCSg9FKVuyenlPtuXKlyvRikSCjGLYYbP6DkvNHDKPOrZxw4WPvIuAFoAThsY5BLUmz4Q3Q1s4XSMBh2N8fCv48NEw5vYlxnOaXW53UCXmlqZxuH7Y2LGSh+9ojHhYJryA0zGSnTZkgBRMKlIpzgQ1bNhA9wVcqLuW7q9GfFB6tlk/XW+k6sl8yUDXlvvx3Spgu/zGFx0NJUkIGzdR69um521BR43jN+UtGTnuMspdC+f2Iavb7AsH1/yMCd3OfjoR5Aoz/sNkdUYIdN3nJuBgeWtrI0MSPnzQ9ATE5WvpJxyYWenQYGaW1QvM7FvQ2zPNLJs+O7Ndzn7ltLIO4LR2+pmmVfC/tGl9Z2unT6t29ghOqzl3836oeHAmBwJhwEP70XEWHFjygd5GcwA9Stw6bM1QjR8+XZjK/nAFWjQ1gQqQqmA7RF2UhAJWMFW4IdfEkVcCmDq1ELouBApnXyryEQ/JVBnQrmZCu5qAdjUD2tWno43JMoksGjD4PCYN2z7EfGBsLIqXWNmQ51bl/KSZk34Sd5Ec4kyKRDkN3QXEKmqCkGxKTw+qAicHtyWW0xV83TGQRwEShoPnLajjHL2wNYGTJ2xnQWqcTEBjinTGv5xooJogBT92XBoJ8E6mlVrizjKVwuOoRasbwcNalDontmwRPrZTZkHqN9lmAKhDZlkRpSdQuEfZQYrOSDStBP7e8rh6K8jLWyEOHuy0mtBp1eu0Guy0mrFTroLQXfISZ3crTSe4s1U5bGVVSLqVLYeDA62IASK11GOu2bcEUM5o5EAFiB1sR6CHdb6M+GU/Gx01dBTfDlsOBk4XvFWrGzWlJ0/78PIrd+XJO+d30ExDQEvQ3vQ9KNLNVE88TPXcao4O65gLh5TmIa3ddg263bobu/peBp7OzeXq5lKCkBpsyFrRWZbK1g7M4ZtwEiLeIWWc5gWUBdp8RwZo8ZzItTTzj1ObV7v4vE81rQr/VcqG3jVcwITrBiWjioHMqHM7z+kFpJMVVaqJVQIGJGO2JSUTk/AalOK810QzYGhRJQVKs5NMxtGuCASBHZqWVBwkpd7poehIQBBH71KbwsJavbNhIYwKU2HBJkNjIZbbDVeeNkFF76zAgcwFgWQGqsabBjQNqYzbIn3iMwNyNtGoosxa0G9zVDV37Ki+9Y51oVQRFKl545yy4GSyRC3yWaQaXW2aCc4jb+RbZtO9dW3k7PY+WIr54j1+8g8L3+VuQgwYugdjeKYJybLpbu4DbcK93Kf2gpi8EOKPdnG4IcDuVTkRZ8KhMnjBCDDK2tC9gRSx/s35EjhaQbSMCV3XHt/qEOThcMF88S+YGoz1LbxK6PCB0F7l8jy88JyrNRVk3GELIu2Q1KOZQ52p1CQJZelfgJsvOHJC2V1glYQkMcnHUhYml2ku0N6YRUOb5VxK2OMLMItLC6cY9Xy9Zf6WiklGqB0jHYKo+CmEsnHtcPaejO0TMwSlMfwMk5o8M5bU8MyjhcB0OMcZvbcQ5HwWTdUppxidZ6VHT89zTLGCIf/Z7javR3hn2GclKGlRlkOtspT5VBPCazlReBWnbXkK8eUOyi5UThf32JGsdNoD7inn6MXf6SAtZzs+7ZmGtxS9DdGp/Aznzi88vJ/jiAtNyyxmKIznlGGuraJ4lO2DtbUIfhM6DSv/exr+DzoNEyaVPtkyTmr1OSf1l51/Tzi9qovg9JpKr2Jzm8T7X7tbzeXzie3vcfufzQ/JthmOjRrjX6RmlqoScfPgc58aP0tbobk09fX5+HTlF/PpbAI2YzyYf3vc3LpRVcOM2tT7T+fSU09WZjZ98786yhRcvrbweC5fLi3V05m9rvVvyfMZJyuXFqfg3lPrBOgsmbNHxjx5rNTRsTL/v4fEcxwS4gXgROt6zcsR4k5qwlvxKG/Xyo+T2OaxhIh2HJz4Y9TpIwAq8pSpFDbJFHQ1BwRbwNpUx0OmxW1PPI7LxuaYWBMPsb+ttlF59nOsPQFaxXTz9m+kUFRSjpofibermJd7jDnUDHM08Cu5GeKn9keGRpLD6j+TG9hzQP2VXN3ebUyyVPfebWGCzNDY3BSCXyue/4nfesXLBn5fzN0gR44pXvhMnxw7c9iAtf64w0i0OXrCK38+tNQUyNkeFUhQqWmUlauL61StPDoYsK5+U8WPhkEJn+P64Gcn+sCS7FxuUMKHQr5qK6OwIaNxNNBx5VF/rwNvu9w0mxwAdw3iYfMSUTA9YT9u7enDaGZtOGw+CEzzFq1ZGNRDRLmHHIwIfrYKenKDnQm3F/G0FfAEpmuwLvU43LwoHL8/+7OzXxSS4uHrNhuq5fjkogjhoMBDgllBiKwoTvCCFz4HjQyOiD8K4SOdm/sVIwuJPd7IiIrkyH5afk3Hhb0Y8BEPRDz5i9438FCFX2MZ+5MBFMfs7+x36Zhj7KcGPYq7D9dxn0wKKha0kPBa5CVyZ3LyKDMigU9FpF+sCXwBn9ergPJAUZCxPJXQCj1f57znKIXcW9GXlyuYerIC/BhNSN3E50XOwAjQs3IzOUATGsw5DcCS4Hw4to1dgjvwggtmu1Vl/uudHAAIortadzodvYI1d9bDXynowGUc/vQMO4wiiXe/gn2vPPqAAt3/VQdUIgreASXO+fFfdTjJlaAZ+GD873ckPXE8z34QSQQv/Qyc2oF+Ffm2w5Fdmlt5bkiDp1AL5nQm2Avvcq2SQ6ArpWZ3cNPEN/87XqWb2whXOfGqjJpMkBfyLK6559Xs3jLmwF9GOAn21qq4ZpXEzavk4+ZVCeLm1Qzips0x4jTPr/FA3fk17p+wVnGYVEFwgdxvuWq97uCOrUDm1NrhcHYYHLZFK9VFbA3iQTt3RHemGuoO8Rwy+LuBUK0vADjyQzI0ieiOCNezgAN67/DTiX2ldHGxCqzXE4H3Ce/vJAVvsRysyZ5osseb7KU0oXaC+C2fR8pQaWvF3E4xd1LM7fl7EIs1l2wzjxMlNBzTEwXXc2QjLWMR0pGsL31luAo9jb+M/bt0KYWvgaOcmy8otm2yzTEzRkleze4XjWBmG2AxoxXNiWqYBe0Ev+mp0XatccWMRiz/mfXjzAMZAwB6sfeE3YSOuzfUloyjeDQ+GsYt1lY+EP/vzPJ8KF6ciDmTv1KhX/Lg9kcdajL6DLgJ2urf9nbHUc9GpDFfJDowHo3aIze3vWZ/GDXb/LF8kdeQ0RMsjcuQNHR10LkT1A2iW6JwXKUwX6GGhYcj8OI9kL7nOoKIDzo/YyrNFHMzy+X/mqyXpUce7fCXARSrxWGxfxKBVRezAGO1ODD2TyKw2kIWYKwWB8b+scBCS4KXYuXFjwIkNp4GMo/DHv33D34gODG71gad1w8xI62L5qCjg3Wdrx3tXpycbmxsnZxIEdt8PThsXOwe7DZ21/Z2P29t8iuzCijePfjICjYv1o7fn+5vHTR4edVpfnJ6dHR43JCNa6Bwc+vj7saWqLN9eHogyudB+cet45Pdw4OL/d2T/bXGBj/l5+p++/XTEx5QbW4BFDV297cOTwU6ixDdw4ut4+PDY/59CaF5sX94vHWxudbgctDcMijbOttZOz1R6Ffg3Gwenq7vbV2s8XkThXBmTg/WThs7h8dm1uC0HDc2xLCPt9Y2Be4VOC/bu3vOrFTgtJyc7NlRVOrEauyKhahW5hfnl2oL84tElVNZh1zMvcOD96xsuVqt1Rar5drCUn1+cXEhqhF15RxwSCqvyf7a2QUrOt0iKp80jncF6JmX6tPLGVBtf/cgGzz+zVQM1LvYPj3YaDDy2dw62TjePWocHms8uDnIR0u329xqbG002PwfbIG9oD+fnqzL+xlceashHQTQ17U9Lu+hpv9CbWT9za3ttdO9hibnvd2TxoVAbLdxfrHPKasSzeOqrO2nw+M/NJnLWlVd6/xwo3F4scFArF80zo+2Lg63eXlNjYVR1u72OYdx9EfjYuPwYHtj5/35Jg9TODOaoeps752e7Hysqjpjug6bblPllqzCsTVV7sgqbA72DjUy92Eoa3uqziSMjKnzEISz9lH39Z2sc9I4PBIB2VDhx+rFwvHap/Xzhtj3FbeQz/mmYiWKJo5O1xk+F3tb79c2zi1Zqc8VBc0CUwVV0A2GVAMlNVQyD0rmUUkdlNRRCRzOAirZ0Nxg0fm8vXe41pCx6MB3SXqi7GKrxpkIJElV6YTxRNuRLNpZO9lhnHxbF1aXYOn62smWoGS9qcHOxBVOtg5OBGc0W1QX8bFxoURH6XsTgl1klU6i/igevqGhmyiDIijC/ug6GN+yJ8pmZvB9nvjI/otDFvJDWQD0IhbKry7sUqk04LL4CAcltJ+BwBxZRFUmiB681OQ/OZ4WhxmrVs2oWKAn42brGw+QHc3kOn2JlBU/xc+SV1U9NrWAkfyph36xv1nfGE+yhQm9vL1SktVppz+uVaXpEEWRvOyMR0SdagHFFF03gEQx+3nF5m9hHtdaAoCWJBzbHletVYlOw5X/LH+xV/0K7+utfrvTNEnPWPe81kun2u2VartYq9aX5ivLtdw7azkwdSq8zny5WmPn+HxlkaxT/SLCGC5Ua0u1SrlK1qmJOoust9rS4pJfhc22xMf7WjFf+YJfXD6MmV55x3THaNeGwaJSLFUWHAOuNnfa2et8Qdc+6puwQwsUq/PstGV/CzNVIff2LfhSWVisVBaWygVRc0l/XqhX+TdWdakAh6m1pYvxsNkfMXx7eRg+eJsbAPOTYu6hmPsuogzmv+f+b27CIOYf2B/fCwiaaFJ1m2xX8t+LOf4F3INv1zzIEwZQAvVgznuVeUXW4l+5/4/AgW06Jtby8y1/JdRn1bSYkwm5RihgonwGPJu7sj3M5vK8poSLwMvq+Xs+lSNZwJC4F3/VuOVr5FRXGjvvYIJmHgRU0Ksvyd8WXMKCCihowYIqKGjDghosYMPZ7UMyk2UiL6mcrvx2pZhjs3PJtHA2U0XVhm+A2VxtoTJfXmYSc7mYW1Tr2HbatmFz2bYi2i6X62yzLlZY24pmVS2ncQu0V42rvPFCeaFSri9Vlllb3fGl0/YSNFdta6Ljar08z5jIwkIxV9UdZxjxPG88X6kw7WCptrw81YjrvG2lWi6Xl8rz1YXpRrzAG1eXqowh1Zd5MNhphrwosK7OL1cXKrVKbbohLwm0FxfL5Vp9vrIw1ZCXBda12kKdcZnF5emGXClLtJcZ3nUGZLoxVyqy7/J8fYGNeX66QVcEhVXYQi1wXbA6HWnXJOL1+QU24cv1KYctaKy6uFxdXqiXywtTDltRGZvyWr1WXQ4Nu0oPW5J3dbmyWF5cYl3XqVFXyVEvyH3FR11fWGDzvUyNuUqPWXS8MF9jB+4iJ9DKPDXkKjlkyYWWq5XywvLyMl/ocvYRi+liW6o2X15aKNenGrEk0NpSubJQXqpNN2DZ70Jtfn5paXmhMt2I52W/S8t8c8wvTTdisSfrC0vz82y+l6YbsOy4ulivLDB+vzDVkOWmqJQX2Y6q1erTjVgyIdZrvVaplyvTjVjux+pSvcz+b4nviSnGXFW8s8bYSL1SnWrIi5J18o24NL84JVlLFsQ28hLn+AvV0JhrYbrm5FFfWlrkyzxPDblGDllMdrW6WGWbaknw3Qo15lrCVq6w07FcKwu0KwvUoGv0oOcV62S8b3FRBEuvZR+0ZPmLC7XlRXZgLEw16HnJNxerS8uMOqcctDxgK7Xl+YVlwfumGrNkI0wwYDgz3jnlmAVxLywx1BnXnp9qzIpz1hgjKJd522nGLOWo+mJ1fp5tysXpxiwOC8YJ2EmztDzdgJcl52THDNvO5eWpBiz3FNPoGBepzAu2Ow1pi01Vr7GpYgJJeboRy56ry8sL1aWF+XpozPNhQZtJ2QtMlJqvsz21QI15nhyzZEKV6sLScmWeB4U3WY5aTuOwMMJU4AUmUyzzCatTY54nx6yYUG2xXqtV5znXrmQfsxLBmNw5v1SvL1amGrTk+ExCX15iUkF5ykFrwZMNmHGh2nSDlkyoOs/wnp9fXpxu0PKcY/TJRFbG9qcac0VNN9vNdfa/6nSDlgrGYm1+kRPKwpRjFvNdqZXZhFUW5penG7RSquaZLDNf5YrRNIOWeiTjfIv1hWXBhqYYtCCxRTbfS4tVPtvTjFnyoWXGR5ZY73UwZGywysOfszlucxE6zcJidbleCBux8vDnLMMovV0VtxOja2VoV8PtxGK2Q+24UajZbvPg9nlWGxqFusKXmX3UqcHt44bYicA4NuYIaUkjbWvCjZQDffs2V0OoG+8FXfltbuz4Vytj3Oys56OhzXSzqwJjYThbVgiIXoXJhtvGavLr/U2nG4nsYqwf1sT25JbwwP9j9ufCvOczzO2aY+mSyCeZNWE/yNTDsr1pDXOnoZErw2nBcTV2LI7YURxY80yBXRlt9Gs1u63bbnMcIZufu2bePLnjrFSXwHLl3uW4Z5ozdemzVQ7mZ362KRDmWDkPYvkq8+xf7EtrDa5jAinHQQ+MDQ75543th2Nm5+d2cIPJGnVco/IFRfJ250gm+h75FwNGBvLmcMGZQ9Zczp1hNHKnVb8oizR/G8Coie104GaJci8wEPgCSV9sNR4GUfAq5aE56BRlGb/1wRGDeSF/Ycf+QXmIeO0DeUdkWuJERf1+1BpH7e3+SDiewMJh9M/baBQovLnfba8/KNi4iHey/rDDKnhFwsspUHbZHEVqBgyL7vR6DI1Ovx1N9CTl2Yyw3jvsGON/8c7kXww2DwE4FoDGDBDc9Tzdo7osc5H8UwP84hKJyqwHU0ZKGKu5u7jT5qbxf+Xg15kZ/JZBI8jvgWBZLgEJ4UMum60A7jlCaZ+cHYuwe2kBYGzchftTN/nCcdcI2J3ajthURLlws5XnH6rnI4yQCC+a5T3uVFl/2RCK3gB1RY0g74cCxijOhQII3BsnK1uh+Kxdm0BrTW7+rIa606n2/Ndl1AZB7sRmF65SHYJNCiFRvbncTu5mxmCvo7G3mR+5V13Cd+fJLZ+ZEbJNto0QosKkraCpMCPZus7c9HoSA0PwyVYrzossxuovrvrgUYHl/OSsiuouecMjARGcrL5CYZfU0w/E50dx9y4SJMG9ciFJKCJSd33xWEriumZJHBCHV/mZ0gxwK1f13sJ5U9yB2vEcEmJpvO5Lau8pyoYPGYSfBt8Yb5BPZtGtsj+6fpOb6cfy1wwsZ93ddsdvcipWJftpWfEPj768OYDKSs585uoBmxUTYMVIBKXR7SWrxEPUV3j22734PhpuNHmytnDlSiEb2YqppObOm7nUeUueNWfODOm8QNNmN8EoGnaaXcAg+UfeQjN4QDfvIOIy9fldpw2n3E6hbGIlcQGRqKpAz+Yq6Hkcg2yokstwJb4fGJvcZD22orzouABJ8yX7NCVFuj67AdKUXeb+nBEJ1/mAZ3MzX3I8fVvc589ySZqdmQmTqplzBk4P7ER8kw6gVoGRm1PVn1V0C1cnRHOs4Ze/7VYVDjLFXJ8NBEyCfncg3go6Ohxwp+GtvBeR5Dy5gHfb+U4BP2IKHap8+vD7L3ye8jNTi7hyOfA7MGKSM01z+kQnTzWYbDvdpCob3JCVgvcqlR9PF6yM+8r5J5j7klNyYd2GOInse9uhWRvYQiHisgUrZdpGf/nsa6SzLcELArusXAmgdhDnzBT8aTmC5EtX/M0j40yCV2m+ZXfGFzMeh1P9gDIpF0iHnajf7gppICSBcOnEOCCREos9U6xOoyQJ0bhkhs83F1wY74jUTdwT7EaqzgaiHJf7lg4o/uys24/bt91oBp9mV2LEghJ3DXsNcQhZGUlHARbhqX+mnzSgP36NjCB7dSUEzC7gxt5tk5tab2lJa2yGdWUrFECJwHAA0Turvs3Tv1BnPqREoybpJSziPgto+XW6oLHtZTMea6YHO04ckampdDwEjPsD/oMAaEftNuHZbLz6dJ98uM40umwxRKC8zaPI0+sdWSN+odhqZl0f6BgzQqTV7Gvk6NOcFRX50zGPibHfQAFKYGF8BmVlRWGuIoiUOlSTa4O6b3JzBTRJqTN4bR027Y7zqaOzDHk1xJCV8hzWnvHwIRHqZkmiqapDSY1sjmCn9JRhjfWfwe6yrJtsv0KbPZK7/+EeXxaSs/4orV8S0ACNi0e+jhV4cHsJjHHaiHTX7OKYOWEj0su8aWAnjzEN8NXvx4wFGIp/vMhmDJSQcKC5oU2f6dA7HnM4+yY1QABuXVnvQmmHZSls1GuOWzemGa8hRAunvfkudlHg4c+//oXrhTvlA+8MR+Od5rB93xxGu+28I4qh1IhCcucfO8RcaL4JYjDShknW6UE0gX26022fO4wjWUL36F0BiKpcEHs5416IWlgrgUamQgGdWbKYgyRumGx+SH3FtNNoHK3HIvIqfb0k9p68TLns9C/kQwK2GS8Gw/iaTdVo4xJdOV2pk9i0g9EF+duCVQMHlFhguVUHuo/vseQNQZQ5fNZWihyMkSu7NDqQBX6sTD6hsmcxGgvTHU6HXT/dJj+KJHP0y5qjh35rt+28nWm2WtFARqJy6o/j9ehExgh1SkbshD+CngX+TLmwOr0ovh2L3glgjXBxn1E4kVa0xTbHGFjFVEgFiS76qOZcTon64T5XA/cDalXoB212afzr0LS1V0vz9LV/AsYUlagfeEDcy4SJelGzlzieAWM7PPAH/5vvG3bmFXNRvxW3oza+7h3e9plWjAnm4nbcOhk3ewP3e38j7o68j8fxvfdxxEN+cepxC9oqRJH3nQ+MddmNRrs80JQ8cFGVK87IVRamzQCYVty97fW5wsNR+hPd4VtzlkefndFGNx4JlRwcwLps7e6aKpARW1wMmnfXxFcZJsXDttkdPwyIr2z9PPTZ52HznvwcXXmfxSniz0FntBc32+RA+WPl0Ot4+dAeVj49XuNHceYGiiQVXcsfK77bAawrP0I/DXa2suHetDGDFbYKttHiK0jvQj+7ZcrpVacftd07Wg6q0+8wFTnuiT0VjfPkZvHlR7dZaH+piIIg+y7It9ucMHUU/B5dxFdXDArIqis3w1E03Ilvh+CK4bh5D39FV6CHjWa3c+ktut7jCkHpd5fXvypfuDuZcVvxOICuV0WtariV3K66cP4LtYF4YBrhybJQEFfCsg4epwyeDP1d+OrCli/RZbLX2vnwKldb0FE0ibtyBbheqbqAs4BeKFOX1Un8jCPD4yASa2tIAMzjAlArbDmb9qjmatGQ4TpLOAtgv+ZtE3TpBDBz4ZH5+kqAV+uB1aG+BKjEHVUATEIhHCBBmYtfAmyfV2MUsFCv1wDhKX1NfLW4obPpB3EUmimxZlRZ9M71KEgYyTtK6W5nmoRZ3OtcTsSYS1m+YKhWr08JNQvAMKH5coC6CdYsTLFVbcvkjL9zKdvkC+QhKpsa1z5gwpY18Ab3TxTfgLph+9xp9ttdlThbQ7SZnwU7Nyg4F+jwVC+ZUK5lr5id7onF0RVR3IGZApSbJb/tkygRVhuJxoCHEVQT1vkCr4r4KLid1HPEJDviCROozvgpZZekA+4EVYn4B2xWWSQEGd2IA//ilYp/nIZoCsXQOPgCVYFNoqoQXRHDroY5OhIfXeoEV6VeNEKSswFBNbzooM7ARkAFiMzmZrgYOlN4TEMmqT6uIVtut6HWDJLOlmcZcqDfCu1NQnBdR0o3bKAd8ROCrZQRccTbk7z5ufwl93/5W8+FpYISfYrgNsFRCRyw7KOVtxzxy8hfLiytMiTBwkJZpebA+kGGQuSwGBMYRVKTzI84NUOxtdOeWKHyti0U+j9xiATwBVK60i5++y33Eh+xnqET6teeRyRHyNCIz7ZdnTMVqBqDw+HlfH6Kh+1RHikevPDrKO6LrT1SNytikgq+juXRckekNSqnsAHNQlnl2VyNMVGOo4KF/AXNV5xXhgPmTf5kEL4YIYXPvP4q+CchvmioYn8dNA9QsptpC4hIvKYmQbgAN0m64IMlXrpjYqvaCeA7FQ+c2KyZ4Dpozrto1ik0bVRgufqy6sIK5WSrOBvvf9TlTlleAgfy8YQa2N+EUqZY96ct1I8ppxCvQMJ5rnkIsZcDFhPrCR5gN5q53jdVI/p2RIN07gwubodddDvBfsvuboVJeaYbX19HwxLnTP/otFetKyY+n39j+r4oVHfCIKI3sAeIXGgzvzH1LrGuVv8KOKyuQg1iz69f/rIRpCHHPo1ur646kyT0Hj8HwoSf67JVVUcqte7usdu8b3bGjsWrHd/3ORi7hwxhFApwUJZX3ZMGJ6mj3sMf/L9AcE7Rj0wx0JFeuolbNGinYl48oIHAi0j9KCKJvYjE80LCAwA1OjwHnL2073k85Nv+OGEu2v+5kyHJT4taIaYjS3EbTl1sM+1yJx66ndhqfiNjKKJbAatRfrM5jkr9+D5fkDNuM+wFQJ42Nlyo3p40lQlAbHd1TxKAORB8AIRJY3+UihJl8nslbHWZeqCxDFhXMDRhBNrMCpIyGRGTGN8rh2IvQLo8OfkOsU9ggnI+aAIlcsD8INv00+XZphg/qSkGURR6Id7EGCqv8EiEdFMKIaG6EggRym8CdqD243B0AGBMdaoBmjxkqd+qeRcNm9dRQkupVBP9qRwBgf5EKb2LNXkSE5pCcG2UCgUxzgBDMgZuzbvoXcupkUDH0QVX5YvOoBKcuJI/Ai45IxqjPNuq/Pjr/gqshG9YfG+zbqEufC3fXlijC0YXJMPeBfkn6+bLU+ASEyhg/sk6+2Ku1UOQQjeaqH7GW1B7dR+NM93bQ2d9dV0tP972O2P1sx3fXnYjfNNuvirfjRxgMeqlmnFK8i7BE+7HTbfolfVt9xtXZIJ3//ueW4BCyy/QPirEXThxoTkS0+/fbg+G0V0n8u/Ie/Kw8xuMbnu95vBhn7zJ14Xk1b0qbMTjZldebwaLCTeIn3vXvrN2vPlp7XhLZAFIjHZvmmjXuimanB7sNjJX1hOikxkp8YN7edv/Dyzn7gagnlkHPQocnwJbDD0KEqk1gV5J0/bzoII2IJ4BXFFtR80QkgbkcYlX8OrEH6XDP4jaYKvOVUjXanQbQkqgaFywJbrlo5qKCoTaLckr71qy9YntGLDHnR5wvuiM74APBfxxhX6xSbkA73KsBCmh8A8gVPHdNfrNxBz0G71D7l0gdxDFxwz3oEsY2/EK9o3whj8bGQt9XjMCG/osdKf9EfE9HhCfN5Gopd5hMP58YgnRLQo12dKUiOYV4dh0cO45Q1OMxhuD+Y7H4DJqugRNNTo0/M8OPsbGpEZp3VgF9pIPXig/V/9Kxew29PZcwfGvNC47/ap4Hcz3geMHLFswTvrfP4ioGpotjW+YjJQnc+8UczPqbRxTIXtcish1RrlxHOfibhs+UoTmURcIHWTDsYWNIo1wwX1G/5Z8+mB2EzaVhI/h4PntigROshlcSYsGTuoaVElRYgooSZchUNZfvGMdxZUUhKgCbzuczhHOsWr7Z6fzpRQwmVjThYUNfHDSoFnVDYPYAoeNj/AsRNjpEyOkiNppb3QIeAr+9pveTeCkU7qQi9TbVfdQLEByQ2w2ZRasmr3itl/T189J7bHC7cEwxJeIg1G9vfaWLgPsGtVV1EmyaVAREAjF6Yl7I+ACBpF3rlHwnZQ019ONjL3cuetr+lwGW9xZI9SGBg8N+Ig/wZsqIHUkLY41J+DLOv2dvgEHXA8A5/D0WZGnr886veS15sJOdo6RYHPEGzWXmwpuOxNI7fehp+rP8hfH6yqnJDL/LlS2fZer4jmVAhv0ciJvOU21Mnn7G4YvBUCZxCkBvqlGwnclQ1zPkQ7JQnfbh/eys+mT+EPyaUkxLfKYE+O/QLExwQW4LHmbc7aHM8tYoDL0IRp/cXP+qs68/ZUTSgH3NjMKQHDBTF23KowCwjQHzrHYFpwF+oZFRFR4N+XZxcG9TTyu1DaQUw6n5k+5OdCE5HLGKwpVlRTvVDXeSRiqIF6nKh+fQ3zvOO4uogSJGj2NmlQHsiDWt2KqEyArkraqXCpkRdvv1EQGYZs9ADWWdOhyHt+qCQ1DN/MN9Isw9Jed0UHzIC8XtBCECjiF+2VWU8Mrj2ADjMj7NEu0/BHYIfJ0cpdFMwP57yxizS+I2bR9v3O3tCt5ueN9HdC6Q+KNQ3hzDvEWXB9VgnO4KJWTeyyHwqM45k/pG4PMbM7GEqgVnU2BP0pqLmIci5gaC1gYR4rTOwwIPaxwNCzCdIHjv2Jt662DBAFZ7xXC+kFCtmzJXUQPtuVNlLEkAF2xJjTfJGzFnQh7CwiC5Wmu7pdZh7Je0ZYaUj32Ps3SjV1PW2R11OeTV/LOmcbgKxYpdxCmHLdf4lR0vr/F0+t2CY2fhI0IOKW6M0O4FQes3A7tqJ2GVx1/1NvPXdrX3gIVMdUXkh73JNngiSuF7B+pi8tE5cRabwcyFft+LNiUrCNjykM7rhRBV6ay6yZYctnR9rPsutC7AuSnk85xIbOgcE1zf0fu6JBbNr9922ZysW91HTrNWFe7sKWst97pW1ujsTKahPf6S+B6XRfTm5I2Wvp04VnuIbiRfuaM9UTcA3xHJmuELQegPKDFy4497V01pFR270rE+WBElnS9PptOrzxYhbTkadQA0RSDXkjXBxAyKvjpgNI1ehFFRwBCM3Ll6FWAzITmwwoAAxZT4tRNMxO4JoKA+u6aBhzu6poEfiTBcs0ADixX/f+hlssyFeSI7BiG9Tix5yJsDcUOpJViTdfpELwVJyRZBAeA+WHn5w4uQqfzxVUqn1kHFg9QjAp0V/CvO7RLACEsc5DqNBYoqb8R+kp9LoqxuWVSCXa9+n0dx2WbxqHiHfSsA8wUcULP/DENw4T28yRba1ZDox6iOueM0ajkeYfrFmQtVEOegmQl7cuNq+rVlL+sciLeA4QYM3pfQU8xXwvTg/r01nGCcQLBUQvBnz9gS2TgyBL9BaaPE776gfXbKWYrdcbs+vD/zuZmiiKKHJBSwm9evIejWlCZxv4ORZnwy6ymSLih4UPK2oVPsGgKmGr1Fci3HhmgMo00YZjMTBIZ1p0gD/i8gccXU1j+KXH74lCKlv/862NWVL3s9M3F2tBAWPEAeIKUgevSkVwN9UfIiBMmocdoFbKsc9ccR9ZfbxRyBBeFPoAbOmhYL4bB3ny3OuGrFJCbbT14BPRienOIGzwRrhPLm8iJT7brxaL2CEXDNgEgnVnzXysnIOm4mk/t2mPbcl+lwHMB5cWU/UEAeh+DK7o+RaPsTwG0Hu7jomSLNExgNRePMAjvKYGVc14HHhBYwvecfhO1r3KKxvZuNUXKUHAq5TLlWl3h7/sq5lmX1SJf5ZaXuE0UFLo9oIRqxrNLGAbIR1uuXSBtBrK/QfNDxEMKcQPFoJPyt6th3Et6u0ZTpS8sUiau5J7HcZZ+ERXOwreWP5IzymQnEZ9ICKVhOmk1q7xKnRPQwoTBF0PnH2fg1CmVLrSid6bDhwTtPgmtVEHJmPlaPKom050KP7snnzsrww3NUWUhxbeEMZlupQqJFyRKW1sb53tYj5VMgG2l03HL9zNMNRgSnuHJdsRnsxVapO0laok4roAHrtkyTsDSVMcwvnee6ggm49ZqnLPItp0vocxRuoX7glIRg16UxxrlMtvaqI6ebFp7LoPY/zgbV5opK2Rm+on+E89lJaJMX0+zGhEUTLPMwKM7sp11vRVKNkply84D+bwZRHwF55st//3k8KDkAHJPq+FQw7Z09FKB8J55eE+DprSV+28rVE8lHSoZvarQhfZlhffcSVfhn3L/yInBsp2ch995sgKw43SReL/gBYNSr5zI+DTbrOl45ABY8durFMH4g33fmBSYKal7GR4H9E5M7hSPe57tAZdlFzbFkcYSC6ZO0iMrHVDGpatOv20tBoJ1FF24MGIaMOPZqNqtuD/u9G2GTeJNBHWOhQ4WH8yWed7ngp2lwYKHtAgkreEo+zPu6y3hWm1nFaQPddktgmYxfed7WrvQXKO9Xldps5STHg7w4jMOyAIp65F5DhqNp3gLyitnfKJnGmR/omeaZH+iZ5pkeaL3P27A4jHuRtwfxd0OO4GjdtrDXPcJnfvIVobZHkUM4nCvMxrjB7eiGfEO1gujLQH4kbTNZ8wSVQRCiodKovZLeMh2aWf1v0spA33XwY6nn4AVJ1xyXjQVIZLb/HVzylTJ2v588db01FiIgSnVLxUTAjexXsedVm5X4CsaivAJxRwYtxowFIz6J7IToHoaZJL8N2wX4Jv9k82o/KHhm1HCGBJKLzQdJseiQ1cdGi64PzTgcV/olkI8UZJNS9vsrJR/ggmzdzgWK8mvnQs5ZOuXfJsNWssQxAbN+wuBaAmtsJo/K9tyIj9mEs2wLXTDYYQS/owSVwko/NG92nj223U3vsS3SjprDP1VbTcEVIQnSDVLqJaRF1zYEDqndC9Yot0GaN+QYWo1WwlG6DTsJVhDsZnEcjYKohzJ+Ipa7b23HgeyPYhP7sj+hIZDu2RW5pL0K4UjThKSxqAkVLScx4sja+ZIa4Xqg1fRzpWoWfYq6KlKKOYz5RULbhC6KVPk7c2vph7w1tHjDUmzDWjXhoKWv//EfgWopmOzhnexavhouQDpQzuVnnNWt4TVW9sUbjnvvhcTBWCF71atmm9vdRGst9ySjc3MTl8hVO0Nhvviw+nAe4DidABM6Z7rvDdOLsp47OfJ04s97uUp4sycP0eWYNQ9pWogDpUSdWVGbgE7KMQ9KV94lwCdlwDCZGV2grIEmQ/vYB94NGD7ZMLD2aPAYAZ7T7tYC21m/V2xIAlRzR88kB672cHhAlZg1czCL9rS+mhMoJ/QM1lnhiScEIuV9FUO8GdZ6jonuDoq6hBGS/3xYkr+5Cwg+jlLbu0gsaG2aCskdfLaFR2sBYkEu7wM6cGBvLyc4M/hCk8g1ZEMNZAULombqmRcpGEcM3BdqYncD5igJ/984H+OsJoBYrE4CWYEmFN9x6eBYpXD+ld4AZG68XWnxUqlBI3L2BjbDPGkMi8F2MVl1GwRqZKiu3Ox47RSo3pvjsZbIAWVHwvbqecms8Jxl1o3HMh/X0STQUfajt5wO56w574RMvpppz9eWhM+WOUCKxlwWSr+FrXf5P77xw8qspSvkl7ejh68WFDsROj0rz/csrkWTONoGPc6o6ikc3AW3OHw80NmByi7RaFEUWytNprd7mWz9Y3IYsZKd0dH7CPDg0r9xMrRK1W+JQzlcfHBp70ABZlWJViABWZMV7YF+O7J6IDYbAPwnWwgKNCr7kYfMlRpa8pPjiahydRWE7mCbVrM3D8YCefeuBVW3AwdtwOuBvKcS+dHeTCzfogllapVgJH8Qxxizh22inECcrTBBG9FlXltDB6X0TuMTvLmbjA30xu6hxFIT4GP41N0LPlVIHKrLHSanGAPMeru3iFE0HjPUhzd1iFJdCVFNYZxdxnHKQF244hHQHIYRleMFdwkhEsk0FAjOLJbIOSDgPaI3/T/Z+/tu9o4ksXh//MpxjrPTaRYYMDGccA4F4OI2cXAD4GzXi5HR0gDKBaSrkYCs7t896erX6u6q2dGWDjx3t1zNkbT79XV1dX1GrN8I6cFZ0qVZyOSJ9WeGwIpr8kjAYkObnbYkdPIDrsKTNMgYGfQ1o84C40n4x7YZAkEAZrLrJtQa0WunasfJtY+Ox3qqjzS7lwpdJpknSuy8mvjOBF1s8XJ58kvgtgjQzFF/XEcrOE1VZ8J2qfTTlbJWaybEepyDU4tBl0sTq7SQVUhQfVOVKwlG28IQw4fUZrJJ7E808XXmA8hzu6MAfp8htDhz6b9ibLwhkWQ6FVynS4/KMkrr+5d23wRcGrX5KD/n8F/V4hqTkWMWJrfvAElyPgquzxY3AnuCLIgeZNVS+TqK5f2lVpw2aslWq2y6oT0q4yCAXTv5V9SFKv+3B1sDQcT8W6pOnysM5Sd9CegIDkthfDj3nW1tpiN+r0JgBTl+kEK/4gGFjri9a4efcLoVVXrqavmNCGVfVYzpm7B1S/6rFYanyFzLhBHMCNRrwhRINqr0dYq9SQNzSwK0OKe3L3j9LKXTSTJsosw/XtMA2E0TR3HNpovYTx5y//45JHNaW6I9gWYC7TgiZ5BEON6oj6YeMghR+OYZ69pDitN+/TugW3J+EXCmcsyGsQ/64x75ymTlztgY4i+GvPRT2h8UNycY6sJjbOstdeJ6Qb++zSpJFVyAdhWoqhWyXnghhw5dAZ9eVnDY1wuAot4RxGFjj2B4mikl4Du3LvD1vqU3tE6p7IdcQ9R0O+Y9zGudiraI6kO1NSpw0WD04rzGqh4tbrDiSJpUF3x+ECsFyte3CtZrOhjVYYynsischvcVlK6ooFzJ4EjZyNHqQQBf0wl8wSpEZmr7UIBOpRG2ofsqaoKYqFTPG29VLCrrquJIFypnJH5qEGePo2JEKnJrUMPwVnIG9LapdAzzfCImEz+CqSi88kEzn9K2ZaLtrimtqAH8drodXuTu/WwaxABiE69W3odo2kH81T62YepKTErd29VegIl4kJngLWBdZjd0I5sp66QCsUL9sltrHlUC/bdHXt7e02ZB3jsEe61ZF7i/Gucb+ee5Myz3GtC3+bEUscCT8AArsmMA19Am6w1lG60eJf2+8Pbw/ZlmtXi8nCHB47n9mSoCl0GAihdnyf7clyIEv34pvo6mYejBL/8mC7noVv5JL6VUn1MZgwkrHPmESifXg70seSo5WAWAEhueHquTES9GYgf6XjSy9KuFOKHs9ANn9h5ePuC2UpJyAQ/tKNJtdIL5Jx56yQHs6nrSdZiG+RuGkLKNXbC7dHzXeEyf7oo8a9/n0gjTnn/dMKgXXntls8kA8kgbc7tBa1Uo/WgSRxfw4hjSXI+TtufykT6uo+4BOjhfGlpeaGe5CXHw5G8vKrFV+ISc7FZCTZIvu8xc2ZAR/PNmMvuEMuCfXYrigy6pWEACNeoy7gp7HalpFCwDvOZhlTmqg4F6m2Ynhh3Lh+LgB+06Zbd1uatSyk+/CW9bWcpSDQiC5M8pr2LGDigKCKy9hOPkZD9TJTQNszyvOPPguEaEI3oOYMQC+Nz3RQA/bH1drPZOP542Gj6FxQqOjVNzhTQYXasI5upt557hAx4zVpYMD82iHsELj3DRztxACggxT8LC8zN3eue9iBT+ZmoVPnZu7088nLPCGbwIs3I4AozGZ6MRul4S4BRsrtqSppdX64nctCa51iAOyuNxVKm/Gc6mstzOJrq+nwkpAlVId6RVKOXPI8lVrPbfXsn+gbxBMxRXYOhuNnB0dU6i0ybrWupYs6cfv/HcLACT6kq/FVPsMcNTEVqVhd7mdKwQp2a58TwDwF++O4Z8jGNM9JYv8rTC8WNQamxL3kjtXLwBTiRNaQYpaKZU5yY3coBtWwiUbZB2T/kX74M0BhvYNyhsJDFdT1B1gCJifqP/A/EoR1eJOqVChg3PP897UwqPgB6NEgIXt4/75nl6dOK98kBXALxqp0d3A4OBRci+Nm7qmgQhF6F1cPhLFy93AOoWfOi6VKRAcdb5cAnIBwwIusAjiH5jygkS+AaN9Dsm2WxlWLkfDeHHAlP3MVyuRzsS2LRP9iJ/qPcRPMWJV0en4SbopAJ1Gb2Fzr1TIzgEqgKxXFUZYNlz9BvQACKnxVfiPrfMcVOBKd1d5uHu/L2uM6MjKyMovZNXAhX8wQgmTGCf3d8fEj1iEgCh3iWbFGZCIAYjnpgyj+Vvql3cVflXzs1n/3xXKK1ZtRoRZ/BCmAGFZIKyL6c+EFwsEn9Sb/GAWH9b4smw8xR2k8F64Yv3/9NnoqZ/HJxK1Wy6QC8FE+OdreG16PhIAWFWVFn/uLu1OoCMUKuGtdX4ZZQ0FIoQ2UUSYhHqSSh3309c0xgez+b2BZr9mSFGEJF8g35GttanBnxuq/5bwF/90I5lmiMNDyUfHi91x1mEToSrlF16kue1FeEqOQDlSPB9ZVTHDT2sJJpHz0EDhaw6EyqmL2j7oN5nZFk5iJGPDqYHjOvS0wPEPZwLdlbwu4sEunQ4byjZpz9DlqNo6ODo1hdbfOoT3Vy0e71067MHd7vJoPhRGndE9FV8pe/H+xrvb28vZ36j2gkg5soXE75qT5oojIMXsmZ3occmIcoCNf5kjysLIMDBXgaUczPqtWiVDPPnjKyyqhxpRXORxpiIT0X8aAsPjwMaZulkJYwOuYewoyOth1D7/3wjkTsUMGVVP6G5N/Yyj6SNq1TANU9qNYiebM5NSpPKqOuosZAfUefAx3ckjdTH7UnV+ClCBeBuIx6nYmcu9bj1W0mPfnpsnWTjrMeSAOODt63Buctca+Jop29TfcDSiYQ/b2V9f6hC/FvcEOoJ1C3NbzwTN9hNtK0yEgLsGhFen3CH8QYW80YGqm/GMN1mbFA/kWMvk2OwA27SN9N2SxXdWB/4moIDqIW+oUrIfiISuiX35ODk+7MffD7I1XpB98NWwffwZ8N+EWR+dPzM4bL7VASRIUiatvEme1YiirxKHn7cb911PjQ+vBCdPZinStZFSWrbMlLUfISl0BuJli4uNwazdZh46i1s7vXaIKHWVBPrLr5jqkZTOJdY3O71dz9e0NN8ueXguq8yqm0aio9X8mp9dLUehH09X57tXWw00R1zOydieAS8tBNJ82rofQtrxKjSvfekumLIEUUBDA0P6Dfs+T16+SVvZXkV5TDK3gxkVF3B18ypvd5RX5eful/fy6/r7zw5/ii3BxVvECY5nX7cz8dBJNVzvdqLFXFc9GFCm9kBcE0yInBFynLl+bJOFD4wsJ6AIfA/hP6ABG9CvArOpYO3zV/gXQyOavMepdAY+xiqy9wqmkoBM25QKyK90RzwiY12xvdCyCTYUiVm7gmoG6IlSVU7qhorIKlpKjCqxpJK2GoKaqxgtch52BFOgJHl6Kr0TkfYEjc4FVuAzMF3GIlF2CUeKMDSQn2Em1BKK/XKFYmr4/z6YX3xd0vFSSswBTZRQd0lD277UmmTew38n6GJ5qjxWsWqRGp92mh47spJBRl8J0V9arCQgA+7uBNjIrXQvUhFZeayHhyqCeKApntXAimX9gdkYdSAK2WAdAqzg9ItovBcSsokXekjPBPWDAVj1p0A4IgccWe91VCGdNrrXA5/sn+Vjdu9Us27mWZjXtJlSbX3dWr7ljfaB7h1lfaS5yAVpHvZbaXLHQJuEo/w62gymtBo87ksxGYAmOwNSGh7lWFxXZXhXigM6S8RC3s+/xukDsh6Fq8EjvTvnhVVGve3rsViS2zvVExju1Y2q7vDm7gzYQSbF+3L1N5gbXFPqbwYOjLtNud4Xg8HU0qQWAB2SH0tpfepH1JpX3BER0Ttk4AYU0+Fu2UPXELbSIWQprohRU1AexVbRD+Rk2tWMy9/1NRDEodDE/29CnSG9Grjq0SXHohJQnuvscmNnjab+KvgdkojZYNrH0XbUIEE/JI4w3741/TzCMuD4GQXoiiq7SD8EQdxBOtPep9SAnh+TUFUcsH1QNmPrvt7Eo9eVQjZ2G/UCERcVU1EgTADqObZn0wrwPje1WbilHYyvoH8cNarKjY4ojbtN5MBD5vnJuT6gepAyj96FylnU+HovFOL+131xJBT6T+h8AVXCtEP7JA9+db9iCPnu8Y6Aeesnk+sr6DqMLHiHuoE5+EPqW5HqVekx0qfo2kYUASl3jbzWx3EIxtN4T2VAtnbuEenT4R6WC/ZXce+baeoAcvwZ1evqkn/vFGdWc7PjCV9HhjF3UQioqwaxSwILxjlBYgYQgLYheBrJbfhbLIEyneLBk0w9BR+FtRVtD+ZOlkIq5RwbqdD4f9FpFIeeJCGsbCNNTMGAkPwQkGtTAyiIUhY4G0rpXQmy/sBDEjgnA3WuqdZmLdELswHflliitgojvkBAhxklILv5ylGcBGoIShzU3MwR9jhg1a6oL4C1h5cl4HDhophgXytQpNgONAu4wBrR6EKB8IQig2VUnP8bX2xH2lhDYMPyINZe8maebFmLQLEtdOxSCy9ndSwRfTLr7ItMkQB3Hwf5BMYMXlT8M13NV4NxQHYjTtpIud4bW4rd5sBNlcydyWxdy2dV4EEJeZXh3/LZfGWRFkdwL7rlvp4GbRZFYAJr4aTi8neWswmb0vmkiJSXCip5B9PkRWAbiXuppGHaM02sMn9lrJMQbVeh+JSduND7tbjdb+wXFr5+Bkfxu2Q7n2OhWXPpzABIgHEijGuukk7QD66Ky1fi9hLGsC51UxyhbwHTBnrRcVPbf7gqntSjMucUQnAMt0XEEc2dX0nFiqfbHLtrR3NV5NDoom9ZPsr5cdDMB/2rcn6kqpZWhji1wpzDDEJxwMz1UsJNHDoh9whNS8U+bNuoU7ZM/O7xQT9Yx65asGb4hs2A1nurG8qKr+FJlpW+U1rQuxL0GS+6yS0y/A8lkFzx8ykw0uhiGUJCt0pF290y4sXHdiZ6K2OoTuu+l5Vfdbi/q6icYZbd2CT4F7AXKwh/KYf7305O+O3dmHyqcqscdbi6iZ/2iEJnbPCDp4VNGtV3e8XtZE3/n5yPZRT3d78haWZzzgPp//B5IRZEplt8EaTSgGjYAZP1spj1AX76ZUEM7BRN/xSDPD0ivQDOkWyY/JqyXxe3UJ0m4tLy3JGG6qH2tikZNGiN+TdPFa/Nm+TEvC2xg1oJZ1au5QQIJfAVPwG0ARTsPkKjURHSZDUPUAd4ApLwQvGE4nBcYhL1MtmicEtCPeRGNia6T1W08idFbyGHrAUuadwY3c7KfpqLq65GK7BlUUwigkhTDHNKBPqVsAB03QzOeTSDwXAvuf4f47khw0cBoa8KYPLHkkU8ggKGO/39T1Ngdd4BYybwrR1u2b9Hi4I54vV2F6WaWFE2+ri1uU+VC20ymr6dMYXzq2nbNHWIw9qfPhIg6TAExz2gEe2YGBT1oQkrWTQfu8LxFY87ghC3dfjg/EVLLbU7ZA4xR4EikeFjSrf1fhvGNy4p+rF4CUthiwtMZV4BWN4E0mJfVMFZR+ELZPOVYtvKgtToZ7w1vreQX38uL53SBfxSoqXOBcsVIGxPGtFy7ja0keVS1BD2Cmz3GkpXSgnozIMSsIRjYo7pMN/Dk6gBFRebIbsjFbeGMan6tWFip57uveYKxw2NsfHeTnk6cJPReHu6XU2ks0SLm4QaAgeHVx76yZXlYkhJDRvUb3mzyYKleTyWjt2bPb29tFMsqznaNn4p/r4eCZjkNmILQn1rw4uhr9ouAkBYMer2ttiqmZImuUQDRECpyi4WkF/sZu6wiuslxLwVwVPpoRlXgqOz910QlgpzcpUgsJvnJ8rQwhIeNkEsCEBDnSXfM385cPVMF3AXF2ixIz79Dq3adirEWfCmHxPw289apGTzQ9rdx1h7ao4DrQUtJg5/1mSl4Xy3nnjqaXxtMrfG1nVvNBCuPiF1AM5ITUm0b5lMRJeWIExRNE+ls1A10CcVuNnRKoOPp9eKrsqaeKfRm7+d11JsQPVb+h4DN+PYWuirO9pmZ+S9nuf1fd/w7R0Louy0LyO32s2axyUOn097NajisSihSVDy8HpoLtikNaUodaXB4YigHDZGxF8sNyi6nGB8hb+IyYRRCqxEgxlCw+Y2WPFhp91jP6sDzRb2IxRMm+L8UjidIA3tzw79XbL64oMuJo2oVKOKqezPjQp2OUkwUOmPolPofCGHN/s88PaAuZhcZj4kQtxSJQJEDzElgcqOAik72UQckq0th8rZKTsHBhmU+eogXvqNeXdTWXheRljhSYTYYY143EN3O57GZaBZN2cy+pWsIBbDinC9vf4t7Br7tbm3v7m+8bJlUXVlV4sYFI083tD42j491mY1s0O2Gby6D/Jv4iWoMf8Fu6lzSi8WEiGi+xShmki369ug0/MquM5SezbSLLK2yXp7+Se2eC0JNgIThIkFZduThujxBhvmuTLGJXaZ2JU8B7Wz0L2I0KAtPDQ9gEYuh11wTs6zLYIPx1Pws+/JuEB1fUs5cdpe3uwaB/F/IFJHcrtmD2cqpmJFx4XOjnxqqS91VOhnIUBg6rN+H1tTkRJBHiUtUTFOfN2OXSKFfSfLGC0KGyxvmjkcN90+4HD5ZlYg9JwqKtfZcXAa5EZ36EM7/DkMrldEpo9lJ45/aZOOuaHV7n3NQRZF5vlBFjOqGjrCxTxRd5gOUFq7Y8auGd4HPHTnsSuOuFrLNmKTwIqcwwHpwmLQt/KRtCwgnJku2FHeS6rsmWhmBvHv168r6xfyzezcbcU4bSWwPhhOpNyciDFt6lraYpQKANH/VM1mNcuVi6PFgEt+u2I4Z79PDyG0WnXD4hjlLe4ovRyodWEWp9wQ76BIXZRf0QATWzgUQVs2Uky6QSfzmQtWSz8fBa6UMcq6Du2RpJexIq9FAiRzs2bBdpneDxNrvd4yE/mLzhOH4V5XhkFktfePXkgWv3u5kHKNCE5g8K48KrtNYfMMMThCgHOBBKF49GbiR0dprqWUb6l/oplTIbLnf+ITNjR05cRINaxDi54gjr8J5Dh4rTmKlDmUMG9L1QlRWlMS+mQPjI9gY3w090dVUc1ea+8E6PdTFNwzc9D5UwtDyRwuPpsh3oraAZ1B4YkJ8MwIXiJ+iSB5frqYc1eRIjjj5Xmrt74lateBffdPDlPft9wqUGlLt3LrqutsVfOL6wNkJB1t+iwgdzLqfSeqUiQPqsYvO7WwYdhd2rKdMWqKMH0Fpu1Zuffk+rVsBMpRZ7e2ABiu4m+sjIgRH7EgnZjYzLTSSNp9T8rsP3idL+Vrkr8zrygMFyTXhsjN+l/VGYDMliGyQBtCfBu80hH1koctIF5Pigt3cdPbXR9aFbhdERFvn4QVRzCrNs6Xj8oTnSvih9ZwP0hxMyY5MICCZZpe5WE5EC7aUj7PxljE3cbOch0zLOeJjjZVp1mdLZZHiF7uac/2Kq5ebNi5j9RUjFxR+wCJ+via4pnx1COIQZLBNaBC/OQM9vkjteNX8AggJlB0AMlldV8Vd6CPEnDn4UH8BxZXiULWdOZCRxCb2HJQthymqOXzR1YXGWRXUzOUoh3ctwW72LsojGI8pWQV9q1tK+vN3tmvkosmnKjfRphn7yJgJpZrpH6Wg4nsxhOjP0Rkl+kG7G8U5SbvskJ0KtE56Kexalg5EiU8gDg3KEQWdhDL2vc1+YRzEwupSwQw3U10OXOR3obruVqBqhHLDo9EKOwCWVeciG/Rk2gVWsuTcHCuI4r2nNPDFWZBW0d0yCi7nkrpZ3m0fbv20eNXa3jXilQKGdu+2EqWWiMxfsu6zxn43/Khu/c7K/dbx7sF+w8dJUwx5mlVbLQwEcvMdVZfJF6UmjOlqJOkJuAsiR7t8MnR5xz/7AvUKHf9xLB93+HafA4EEOzB9q9Gc7yQ+f3h9zoo92G/vbex+x+uWhxFy9sHWcPT5g8hM//B6TwNUPtVg+DqQfA5Jqkb1+WZW/P7Yyg+91OUMAv67TSTMGAn5leHzxCSJ8CDEm4VZrKpoEEQ1xcO4gIqInBLG0U+N3S25kVTHV6B3rHQKVvBZQjXipQLOqfCgqEeLYpgi7ry1K+WEV5Ic5LYj8184OBFd6ZtdZSyrRenfmNebPUkq5XLWycyUnbLZJW/GUPXI2Nsy9L4O61DodUOmDiC0STPyPUasVReoI/HHlXE/NWmQAuMpU3AoXAku6gakUskf+0Dhqiiup9X63+X7zeOtdPansD5Ns2rmS8kspOJVOWqZv5aDlcrVUVEDuuGGTN7VwG3Z6n9PujHuxEdjy/gfmxTAHkiUe4u1RasFNlaW6E1UHl4tbZtRvd9Lqs9OnZ8/EvVX5r5W3FfT5v1aW5Oen9OOy/PiEfnwhP/5/9ONP8uMP9OMr+bFKP/4sP9box9POlppX3ft+saO+PyPfn5+2N9X3Ne/7+Vv1fd37bvr5hXxftfVPve/dbfX9zNdJWG2y2R5lVkQ3QkYWtF9RKsAic4cWY+5wYpBSaYHA4yBLlWcfj28Mehn1iM4+yIT/t4eX6lOQTi+Ofq5J+nkyBgM0p1AZaGHGL/6HDfPhRrmNfr9YKbKMeBKGG2DMlKJUfr1kbGyvy7J5D+B4e3knOCa1roD0R0d3zvFp04huVV0mIAd+VQA/1/XSRaOoSaqUvg5NEwU4TPGNOqoWNZ67D7tmzDkDUEUiqsyUw0IOWNdJPMwxUzbkM6ey+IKtrLAuiUxaCmYHD6aTg4u37cF/trJgK5f/tFs5HcFG/tabXB0a3wQagKgDCiZweRc0xlqjb51/Qxudk8YH3WfKBwjnAeCeDUFdZTZMq1r3iuJEPuBDqZP5HB40Bfao/Vi8mlz3K8SpQkco0tsR+EdoFhRVIX6h//oXKeoNskl70IEWytbNQYv0EMs5gipRsyIZBYQfSJ6v2DjeKWT6j5hEhKdQg7TudvvtsHtXEqsN1Q1OCDjRcT3kJ2WY4XghVHxcKhF7IpShE/8nYGCbGRDAWrR4w1ivQb4PqXj/QjpISJ6WhJhESxtvcDQFSgl1VVlJ9pE7xyClWOgrMitR7VgjRjWG4kTLjiNp2rDzqSAakpwKjq2Z9tt3aXdLvDGCQP65EzLR59WQi61ROoBwXf9vKoAqb4ZIiQIzGraO51CUmkRnFs2GA6n3+JQqwgYfzqcXF+qBJ5MEorAAKjV6qTRfuLNaGJLN5HXXo8iU5Kwkwvgme/WLc6aalWnPbzIfKjp4yGKCYdr2bvBHmQfk8nyUVSJ5PQIGnPYa9rIoGUhC7tAaR2eQwbrRislVAk2UxBF+uVCQeJk6PRhao6mPExiIRhkKebiYjfq9SbXyL8Mhcu7XslHc/3pyPdLJanCwKT0dmXRS1DjDmhKdRjSQUcSjEgQo42BqV2jTy6cga1Bw0whoIeGJS1w+0xDrWTf9GHRtBuPeQAYwVy5z0s5FxoNPJ2rTxBnDewaKA+UBqGstsrrQpyB20q8H0YMvtUA+ekqFwF1/fiWHE7fDcTcLqa0C429QWDVTdyPLRia0/etk+UVcfrnIyC91kKKL3vj2WsavyJLJcJgM+10qq4xKV5V93q2DteHiEfSVkJ/sgZx2LeLgaNKdkn7XvVDXtMQxQjIslSvUAaqI5yHnS4ktdG3AqiJpdl4Uq7xo1V8sSAKHzUdLIubnW9sgUdzenjQ/5qrGtPay3PSYcNLeg47zgCeuo0G7XOd57E4a2pxXQ53r3PYLdf3nye8WUzivlxMV4hhwlM+OQEzCQzCPJW0NVEflAYRXqdsGqmg+T2beIf9y0fM99cTQz4mAvmglOm9cM6dAqEi0ga3fnfM6Mh1xoIG6xFxF3DVEqfHoVlkbMbWfXgZndOPW2h1OVP76YCEI2VQdGt5jRuDL7l3kC9VlLboND1KAbsTPwCPtArU0KQHyPym4Z+y9ovpoDS9aziCXGOq2qKEuY53lnXVMx7EvDm/PuS2tr0cQL2RO5ryRM1/iiM/ZiK+sqdbXPebOpogiTMuYAG43mltHu4fHB0fYLZrungnHwTMgpjT0h7btZOg8wrGiCB8u84HgW3NjAMQinxR6escaVi+sc7LpQudKcr8X45CKR2JBzUPD6FLNQhPNcs0Y271Yw/uaWzaI66s4yM8/70GMIEP/vDeRy1XgH0FU0oF417nafiggRWywh0E2Bdsy9J3JImsiA2ladnh0sH2ydRyLC0Qzr9tWzcbRrkCak/dvG0dcMz2WtL/zRnKQZhrYHO1+q6PGXmOzyU4xyO/u6PTu0XvAiZzGI4gYmYGQuukSRtix4d3bPG7sHzcbx8diM5tcF/3pdW8wzMQVi5runbzf3T9o7h5/5JrY3Nam+tvG5pZ4YDNVpyPwwUFVTw6Pd/m9mmbnWyqkKK7efLt1cnQk1sA1UVFsJcsJql/U7qjx9uDgeOvgZP94++A3fmoZ+L2PyWCNow+bR4URoiyq+2GH+sNLU4cLSjQcXGxdtQeXaU4lBdt4BQbhC0M9cehe2CjAd7/Fye7+cVjfQ9aCRhEUL55ciNp7B5vbjW0vJBdTr7n5QVZbzq/2/mB7d2dX1lzJr+nmvID7DI9QASz0ITrY2fEWYQr2vVnTU+ePTw+aP/beAYFneMwKJhs5X34r2sg7X/mVaRAydeQq6xGdFn3GWXZIVirgh1x2CdOlahWw12Tsstoh/Zr3X9LWbBwlzWiyMbS8EHLXGA6epXjsBUzf4v8Gccuo46iKFqoQhHh5arKu3yK+5yjOt5XeVOP60j81bj1hkKtUIotTmV9TzkqgypnJYTGUMuAcg92uivbtWHgZT1l1epReiPfJlQ9LbE9poE1XAHzlE5JThBFvBUK1nXBkJk3N15RwmYeCcSyZEQxcbix/B9e9zZDdeeOus5Pa7dqHjMzA+KXTMwqqyFyC4fhZSWn315wXMyA/s7eCG//qs4sMys9Qur59zdkxA/IzU/FtvubUuBHLBz0snBBUQIGhYhbV5Xxu0BIgEQGeky/ZkVrkmyAqzyUXo49qL1xLPe1f3OuOEZqs2QYPCIRoZydf8IuRNusPAjexzeSVGHkmDBf99kS8j/8iFteUkgcXWggW3Blej/o+coLiuVvKXgN34TkSsAYbBj9b0imgNzCDUd8gWkuaS6ZjuOYylLEMzIl6AxdpjHRvJqC7PyU9ngXB6KG6nRLtxM8cJqve6PCjtOqp7eaMpg7DbQw2ihtfmwN5pRXB8KWdSYUmFPNXi1N8y5WLbcYTMk4X1i2jFbhhqDFRfiFYgzKbgd7yfFkj1qeeZYiCHxfAanqu2BYmEj/NqeeFsZqO+15kLE0uTb45n8ScngWScCbpoPimhjM0lrPC8dPP8QY5tiu/OiRF0JnuFm0Qs4TJzieYYtWJzYuzsaG/YJQIMuq1gmxzJNecn2jjCXQAbKffdR7kmubZBrnaFJf59u5j9/Pp0tk6zl3XtApNmiivcIyInZd+0/Xow0nQw8xTVAyHk2kAfqh3qro4i2ZolGoJ1Rw9T8rshDU28zLm5GeoQMH/2yDzezc9f+zDQC2quMPwcLwnx+hbwP1y0JkR4TcKEJ61abPNGZUS2eJ5enbkRi5/oMdOCMEZTYnl3ug25WBnzIO5U41dOCFBRnMyHIlBBbuJUoSg/N5SPCJrPpQzZjlcpSdVYWb3nHy8GkjMa3OL8o5URUEMdapGKhGUHSNI0JunXyrRnVUtxWYmRXnlO9Jqo1hvTqtUoktPFRX0GaqqyswzUFGFc+W0WGWC71vVVRh7H2u1SnSl1C5BN1bTVaILpeoKurAasDJdWBVY2A3WjpXoylONBf2FqrNS85MqM2ZyRpVWNiGBeijGzjibIcgcWz68vKZV6zMFYsglbiZ4s6ykCRxjK47I7yGepJ+U9LHi1xcpwuOR6xFM1wu5tGjQ3T/VDvA6lK+0BXGrgvgeYLAWb4K9Iv70ZwCm+MecAN9AoxD/jbVYCcDbzL+zJbh4hOgvhWBgjUYKYaEXWAyQIIfyt5Tyo4x9TRxU3tJLIE/A3nyT4CoyJ8pBrgAAxVlSGKA9YqIUhknNzXjj2Mtvcitj5l05iZPsgkvkTXLAecQtQ8x/7lYpFv6LLsxyezbni/StnvdXvkU5U744WijgFqOE3oRHRAf9gMtFBfUU+yZPLGc2Gd8WtdDim8k9Kr9NoESMQ3MAYxdcDBzvhfxNQijXDDYOJm/pxefbh9UjHnRfsJF/4pVg4hvFbsYaOQ+15VKL98rA5BH3yMiJ8vPNqXXGs83BD/C0HLyzHj0yy8+wOxrqLbTFWverEwDJGvoTMtGjvlGwfbrmE11V+5MvJD8hkbI3BG9ZWZwbT1uw1l2HM+SE06BSyfH8DqJp4cIhZ0yS53uJFaTI+3fasCCh3zz2zyTDedT9+7+Y2c85H/0nr58Hk4dm9dMo+4fl9NPuYIs56y+X6BiJuTcH3aP0ppf56cKgysCKwc2XcYpsZC4EDF0V0yDUJ49CHYDuK1rXytAc0pomb5LlGgofrqYA0W7M+BBpeSwejTIerrqmFy+Ahl21xxAKqvryhSjQ3fHnkemWASxeP+In2jfp8XCn30ZW33zuQ0ae42d1EOsQRw0o8AM7XAo6BFaxmqWdt+nFECR28Du/W5+T9RvTEQTALy/T8Y4WCSpK9mUDLuSP6Ovyq0Z9TzT3HHMWtQEgHfC3CFbcc3cItsCYJUe8DIRkbUfKGFnkGMXfRz3x6K2QAxULjOAeXC9Op24hxEdgcRV4GAt+46J3SR0EA2CXuqP1AyLuGVPyii7ZT+yGZv0d6VbkXnksQJjoROEwM9x5YesqCRj4wLuuw8ydvfJywGAQ4y1xCf2mUSLwbp0BHTwwqK6a4rHCMELeODPgA22pl4PH+kLEoP3PihL6vsk9GeUVHJWVSi5dE4+Qzidzt1VVXNThoH8nnjQx4q/ECEgxpiP0tYjUxeskMU1CQ7n2ZNir+rmMfd0jj7GuzyWMiLNcT3ritvJHetEvbhEAmbtDAUoPj73QVG/ufSvDf6xVap6CuESOBN0VG4PYARslq5bzNTNtfNabKX338rYyI/q6WUCXOUsur7bAV6cHxWyA+mbe9EUwOWg1jo4OjmS+iPZ5X6aJuNSmoZ3Ujl+xpwvNKGK/rzekVH/3Xlw+HzdIRB2KGaYrA/+8rariMJshVxfbV0t+KZNCQE+2HW+z8Tta5xVmWTpC+aTJq6k3Sa/RsW9NrHOwila6zucxv+j105YJ8OJ9Alcb1GUqsDv8DEmJwzVAH31B9JBFvenD+8wjq0sIAVnVFwEkldIIa+zcyKwU0uDZihF/ECgsM2RklbXTHzThcXOMJnLPqpVjUS0dt8VIVkgmdod15OhJ7wHdLZVhP4jkiqfpz+lzfPV5CejNWKe93pn0xMnSQaa8xyvORFDhSHgkbTb5WCr6GnUxMv2ICRw1mq394y0ZW977vLe739g88lyLlCE5mq3xf1hertPvVtq4vIyGVxMIDc5R75XlCq5/j/4mGB3FP4kfEgN/GbUvU+nD1OsGkyCdmem+oSFuZV1REZzzBa48TX74Z+Wi162sVX4Id+0H4BIk4q/9YEN+BZtEhpVhyO7/Z0BWHCA9+fkUEQ7zP43H9Qjg7hmWKX+IH87qYlJAE9A581Q4V+3MxvLSVZFkT4cU5ndI1lY71N7o9sbfX2xUan7QYZ5UEJdNX92PiJg1LfACT6MYy/75DyiA6Q6ProU/YfcQGDxyVZp+AE9qAkcGyAHVpqAX3xASguD1SdW5NMLLezoCVlaTVoql5AaIgZ3L0yQ9AsjRsF3xdOYq/QxYTAakR8s7LnKx6rxoIZw8J9BWf3YjQpk4DT/g/mY7C8xJuC/QBQbb9cM/JWHOPcVmCnCAvSlVzu69l0LAYcJ2HF+l42uBFMNxA+iV1OyBzgK2V37x1A5T4u0WsAWd6XhMf8F9574MLzBX0vuHZjW8e0hNQiqB5OnsDK+v24Puxt8roTSI3DCq2E4zdvoiEHdr1h2J2bqnCMxWWcuLzknOlNsrgTrihXQh894mr2VVpNwSULANT0Ut6/Nl4ENKoQ9boyRgrqFQjmPiflPQF4LMrFWNvzJTEi6QiMrLzvKpLPIofslDHscaIesuy1XaJl+6kR5FVf3WSJJPNQvPGgxF0ldtgHbWE3n5WsjxrZmQ8q6ibYspXMGYmJfNvQXRMBEVV+zgq1Z1Oas8CUc+LqAXy+aguwOXLCJUyE3NmqmErxcJA7Gt3hd5Y3vfJJAwRo3kk9B9uewPz9t9+x4yFdzJ1kxCEY11lWFm8V1T+RYk7UZPD9eOjYPqaRjwq8+bwL2bhslkmD8R/VDBDotV3NxThnozCU92C+cGDMJ0+7PPOaIADpxrpDRXZ16KmJp4r17/qeuTliTRLlQlWENBPa7bkwpO2BUHegSLoGtgusZpFu2IIRlOYGR2TraBkAufKrWC7OC+0EWtI7loi8VB0gRSHhitugNXiGF6g9YR//tAqq0GdKwgwwpneXwwnZ6srsmnz+36LRngS67Utcin1XgsyVXmtGTGIiTX8eLcAxURMPvnU+f2FwhV/etfp98aoGjHdi8UXy23Q86ols/AWtJKD9IX0IAnVbc8eHGVyEbrEFwGsUu6U4CoxJVErTWC6+ROI7eEu9D8i3W3i6+wDqiAkbQMC7I0RyOrUPAwob8SHb4A85MQyUC2RoyK7w6PInf1CKG4UMINOmU2ywcyU4cQgQ6VqC0BiCfj4b9BtCX+lvkbysGHyhlpEI35wkxLq5jOZNQuD25G+OSthkTNiG0AUjR5JzBnEjZ8WM87/3lTmWUy/tHN3+iiWExcCCZ8NGcI4ORprtr93vkH0HmJo9YZtcft64zoS9UnSRGX6iEH9dwPBKEbON0NNHoT+PUF1RKoxgp7nkf31/e9vufnosg5SDnJasLFLMcWY9MnraBeaCx8Nlz8UkTfJgtXuMCIcj+a4r9pdTroTVrqvnASYbw3toJcj8oR6n1rT7OM+f4bs/Y02EraZqtCd9DNKbwuTZ8vOZ8cToqOF/g6eZXfVwwNlpZiiEBXcs1ApJteMjBZYo7qMnOADi4uxO3rhonv0n8lR++Y4a/P22Pmc/9zJYpTeE7PV356+RMzr63hACzFqhJh61I8kQ4mcLVKK8F6kotjKg+daPkhHRPhgf9b4iv5ogCyTrvxqslvfkWT4+zUz3sG/Iv3XS5RZz3A33tbUMBVPqZqNmR53f7ctHIxeTWCfwPS3h0OBTHN6Jw+GAWwARK9aghplVWMXERCMKeyv0+unQQh0zKPYtjGCtZM6wB90bLMiHSb0d6pMryPOjIfrPF18jyI2CfXvpGs4ENeIrVdBCgkz93p0hl0vfz85UsQoqtvy+rbyurSks/SW3gur9PvdmlLuQw+6sGMFevIzI/hD/x+KZyWPSUcXEseKNwFx9HWAHBgLBtoutBSlsprkuwRtAob09qeN/dJ2uuaoxJghjtEs+MGPl1fgBAE4QlKUHzPRwrSC4cWtLM4YjAJHAWX8dwtZOUs1FlqSpZAxaeCX/nRQEJU/i/Yd18Vahq8SfBIPnq4bnGtmK4WWN3nuBA9FHRP/gAOkyR/rebcO6tRZafHQ0dRlDtSGMG8Q4VvGFnNpFutV6h+jApGbDN/MQpGciHcibTtpFKwFoWimbQ73xapuSNMEG8pr1eKU0rjiLpeiu/+MkWqJQapZkGrMohFp69wYJlWKEavsggWQTE6h/u84++jWgBMyVooRMvSnf6wPQnol40zKasyGxIsZylYx6wV3kOW4bF4xXerL1dXn68mz9RMa0UNZe1aKWgxL2KLp1iW4N0qNe4kK0QPYGPbir2FFOPk9wKmvTWxQp8vjeyp12l4E/Wu2/3j4fZwei7YMARJ3JCTDTDoxnr4WJaWvQQlEvm3IL6A0YxUT3Bwn8Gbj4hhXBO4ZwhgcW/u7wVRi5NnLTObqgZmdtRDJz3Bnj/BOKh8phMm70kbAjbFO5eazEoZR/SdaSpVny+BrtdAobY4GWq/X2+yiAaXxG41XVHte7iimINv5qD+lXpnQuhD3GXaJFEjK79qBJXFBSC2Rm8Qu3yWjt5/F51SvZKP/2R3ye2tn2YGL/EuPxNX1Zs3eBvMuLrRjDsHF59uGW6aY6AZmq+fi8wBliRDkA5FQ8rQjsguuyG8nbITe+o/1Ir3X+wLxQI9ygM2neXJuIP5gmHKKQ0D3PsRk/bnQNrdz+UzoO3u9wotXjrjp38f173LSXjOFpPxXeNz2pH2HNGYOcOBjS6SJRuBDj+RNVC6KuRuUWA8wrlV6M6Wgui88ju1EyeOHTL9e7OfpqMqvIrWWY8P1oKF9+4IlFNe0u5ZQl9HNfNeQIbhON1rB0bMw35XqfxAPE4/dzPG6FnWB91i7HtLYCpTdtPug6LVK2l3JtN2vxlYXA/SW354KOCGt9+Z4aGMH75jwwlIW6D/JT/hxLHCMBSkIJueE3wmPwZyQqgd/SmIDU30sE5N2iLGbBNsuQZLkwcXW9UbyRbqwEiuSMsb7KAh9sj/7fectjtX8CrDx1f7b6FVAQXKP9ITaVtWzrAF1WWsGq5HoUnLk6ps49mPFPtsiFZEA6sAgkxgFcTQB3J08CxD9ZS3KnK6YgYJpHveZMz141ZqdontWev1IyBw3dGHN5wEMC/VPXtvUHlscLHV+3iGy6ria/GcFi911afHCpRwWKrsDm4gBg7jl0MtwfymgSWJpiJ22i5ZgZxoLVif/Bfd3SZ5id+DrFhXK1zwOrNkUjHz8s+wEIgYqmAYYVxPEzRVK4xiQC5KQmRLu6ZwN1fkHnzoCN+xjXPOEa1bswez+DSxLb3j5Dqay3Fy3f3nOD3ScbLXPnecCE+Qc5wQfxA7TrxNhxvdf6kODDhsFZRUQ+//ADe1UgkFHF1mt/4Z3fpO0c77WY7unVWw693tUAfDVE+h420PcChB2w7eGtKLZQ3g4IxpvBs5C5KMCk0dN7T2Pb6O3FWCIDxyZhth2oE5dYuC6c+rRxXhf069MS7Zc+q53b3uDQ7bWQbP2vmBMx3Pu08/lt/c1k9iNs1tw4bpnBFqnLa7vUGazW3ne6PNbnc8xw4FwRikk/ft7NPc1jycTtLxvHrr9waf/p/gECAM8LyWnPXmhuCdq/ZgkPbnNrW0Mx3PcanXAlPal3M7IFnvctDuz/XMaS3/Y/R51L59lG6nKvvo3KjOVFSHe2d+Z6adTaDDQyAUaXfe3eprvDs/9qCfZvKOmFuP4zRtjtqduW39RCz75HhrbiRy0pknozEd9D7Psz/4MM/+xnM+iICI77PLuS037bfv0u7h3M/h+PNcsXoy3+6us8u59jf+/H7OPU7m0WOplkiKiF6dJOHi71S9JuWpYTf6Ffq7eAU6kZLWEYF7vGwWKuHIk1gq6zeo1On09zNoj5+tpI4oDyzj9AzxK8/KqdRakcBKdBDacTypGrBs6Ea10KIj9qLMs6hQ4Pw9onEr2kaTcljdyiAMV2G9D0Hb5fk/WXk5CZogvaWdybJXgk3EvSIr2FeYQrKhBTgSxZIH4cnjYUoerlAI5iEMtXZi9teLiyI1CCBygNgxsBmVLwalL/jJB6XWRzhIzQoZjEGYbMwVMmxUnW8DPuQczRFAllb7BuHGb8CibN0j5zHPAUIXgigKLoSCSS1u84yz8UlwFH0T6fg8UC0TRbxv3aodd7GSDjZL95OTY8Ap+LAOtIT93xcvW18Q/kqQLCQb9qdApyvMhI0aXEl6fZCwliMzAXUOYI0DdhbDwcCVzlN2IFggNWneUlELqdAgGb8fumBuqfe8Ez8Erx+riPYFMWTaXRnh4Xj47vj40Ma1hPcf9j5SvqCDiU3ion9E9Vf//XHr7dOKjsqDHEGkSF61zY3hJmEAsYabJ4eHB0fHje2ZQpqAxumqPe6CiNvL3PjQsMk2uJxs4uU3cCNbEAB5xiBkwkOHdcNV9AS0VrrVMr1UVN3F0eCywuVPE8i4N/SiEM60qX3RenHyeeLFJYqYJ+jean7MossqpHjIWZD2b3fD1aOGCNARs1RxRlSq7ywHcLSil9beC2ffBinTu+l5QXe2Xm5v03G/oB+ag930MBCr1RkCPIOlYf+GieenC6z7uw6+LPAg20exA2RqEXc6datFa2JlSNKiIUn0pEKQX2wr81mcvFuUKB7nX98Xpe/csQwmZMYW/077EzQp1K0OKxybhJ9vksmogqOE2o7DZDnjjIM2XqCEil6arI/WZhKJzHcR1TLzpWlUYpOHsq87eT+9i7+W+/XvcjIrJ2yseteEywRc1CZIX+s3ONkF9X1+mtf8NpGEp4UzCxN/7h1sbje21Rsjp1pz84OstZxb6/3B9u7Orqy4klvRzXcB9Rgms8yHgs5weLCzQ+dvvu/TCdOEiN7YNC2fP+7eAQZjmK0uf56R3G1+I9LGyxnG1r1pj5OPTfm4AXsBoHgQxCwddDOXlUceVHFrZtKAZziuKhKFUz/J9Cz4+zoK9A7vKBhdjbN4sr/r5ejT9Bapd1B1DSdR/aTBNesPbwVT67faO/it0Yw3uupdXjGt3u3++i6vmactCmd5tPlbzkQvd8bp/07TQeeOzPTXnaPG/ztp7G995JqN09EQMqGELY8awIHmNm53bwQ24Ilubn8QZ4xfnScew8sTdd8ebR7vHuwfbh5tvucnah5tZI7Ng70TaMc1Uc9qGUsftWk29psHR83jzWN2miR1kMVdR+f1i6d3nXaPJOwK647G6c2xq+/EJTpvk1yZ/3XoucrqFVHfRM2ppp3088j/KmpO7rivgltDRs7287h9y35OL/zPcHuKkqtuP1wsPn0xYm8rc2fPb7R9cPJ2r4EaMUevsA138AobRc5ciQmGJ64QFJHDVtjOnrf37xvbuwKlvQ035eKK2z3Ybm1++BW5SjAVxP2m7sZohc2/OddkOgVybTkwRs52CZD4Z7sQ9MzRZu8lhOGGCweJkzrBFRxHSLqY2li/MjuZvZRue9L4Fb92wRcvS6UedFJZ88ws9UVFJPV+AB7VnJgi+N14Fxny6gFR5LPk5eri6vOXNeVbVjQSut6CgejV92Xj4BsxGMi7Lr9sJN/kIgI+dMl+KQTdvcuAkFzKJbbeu4+DHsP7ukSn+p4OOnP3dxmk9NVbAWTDC77Ugq0wNlwruvK/bJcQKxAMQ9mEnCkTKZxKGRijEYz4Q5z+bys5cJShzskMLBZZnO4aU7BvEiTxRwMHGizka49G/bstd1CqLFGicikpNs8ZGUuR3VZgIK8Hc4L//kgYUOyRhc4aRHIVR4yrGXc2RDfHA3I/o9G1fu3HBEIkvKyVyAeNL7TcfN14jt8iDkafoPHTiS/0x9t8fJt/7d0nbEbu9pNZfov7HxcmxBGAMFqPgwGIvhtq9i2TeF7iEoewt/RiWGEO8RulQzEBUx4hcosuc5sgEM1OUIgRRP7VgTj5XOLhMeHf5L7livfiW+ctvXj3fFg94gb6b6fcPdRvn29y71gpa3zP9FKL98rA5BH3yDxFc/fGf0l+mzdIrlA75wrxFl+8bQG4HnH/AilAdCPV4Tcv+K/NCSKxQgEptzP8Nqk4rwDJI+BmwcXMCZKMfJPQiap64uBBS47Bx5oeDLpqnCrWVcrQKOc6Aoz4AwTQRtW52IJGO+PhtTJSMxJnotWUWYuhnZ9JWnUmE8DqcQEMpG2Cx9rsdo+H3EB16IpLJqHnzS7SN2N44Jr9br4UBGgy8wYBTY3+AesFg8zoOibPevk06W6SKosv6X+WPOllO4olSucVnjRbOrci6SDjzm4vOxj0e4MUH+8bFLDN85Sm2YG0Z0elEkv9pROz003ARr7FCc1jXUyZpO4cTGbI7M4015twQwJvPzCxO+mezetOEUWJqnPWv14MPCnkHr9L+2CJQeLbD7Oeu010KHgSJouNJt8TT2T8K71AEaJI2YUt8xTbRM1oVeP0q9J3B7G1sdY7pzC9CAodjiDtxJswf7jV6uOoe1aS4tryR9vrYzl9sf5dVDOynC688OPVxTQyNMw5W47TevCmBHwmhfiwualMysRl5butrfOz9AK0kgCWZJJQ3YsQGpS/Tj4ebB0ftCQ33zr+eNhoHex4BvkRvORARa3yQ3OK0HgUKQvetQfdfjomE/Ritj+p+n0asjWXKd8TiA+DcO70KCK9nKIJdnO8mDa5ZzWxJIaJi2uLXushQkKqu8WhcU0rHLsaDWL/DCLlFlCOAtpRbiUqF2u4GqCKDrvtEtb9CvIfTykKNDRsS1K22kryH689WbWEJIxS4yqIdesK6UUheFe+IGazSlxQQBpkvnSMchCElsWR8CD4x2BG5KefrZHWMoMLlmLFcOINF7bLdkl+/miT7sTAvhBidQgmP4dE7CYoApNPlVfOCFzmRPxCsr3hhfe3BAhXW8+LrOv3txLmiQh7BODmJ7ewzVbj5NXWMRkoMEtlswNAlTfxqOD5JPe+HOmdG7l7Piu56xWRu14ZmsZcARHChSoQwhWSvoLg9XKAXNJY2IGYwMykM4d572XqDXKUtrtOWSHZhYIHnJ9FEfN6mtWg5jNs7suguZfMkQqdIIHn3vDy0ntn9OUn9MoYdqfrrHsb/Ab/CvUL6oWubtfaxYV1iIPCqEOcytym6rMmjMHynYmsWr32REEudW7J2rNaLRbEKNu2SLqUuJ9V60JiB3IgQlLYSXs82eZBasV4oZ0KCcn5zM3v2VjcveNub3D5i/1rY5lG1x2nODPKbKlQp4O2OALJZKgmLlPQqmWVSYaak+B7Mhw9MhSWHgcKw9HcgKDk3TDfVCJSVcIYTNPrSTrowh8YMCAn63VJOGpj3aWKwmOFMnm6rGm9SVhRWcMR7JVSPZhWM7UiKzlMXXVST5jp8rK649A6n5XYKdJlaICWfMHQXyDHY8aWQjjV/wPkeUUdxuR6eS4KVLqXKy/jYBmRmsVHnEF2Fu1knhI0ZpBCOVreDWveHynIuVV+i6qJNZWB/ulC/RlXf/mUyOjCMGjSAbx7EE+cN1KMppXW5MVVQ0ASS87C+PuasoBJtFVzJG0ZkxXksTRHULzd+LC71ZB++DsHJ/vbsWw5nqAokAEi4k58+gWFR+BTqTFSQbayRKe6v+5l14DWi8mhDHCXTEeX43Y3Te6G03EiW4rzI86ViWe76KL/losk8ID98KJDYL4YXW62Y8TpqkooIsR9foeC/UW35QXfYXoRdFh4Ac52gmIpSQYjnBu8+1nHGB/BNecDFnkSi/InGwF8c3AmJxZ3h0efagaJ4Az21Hik4Bxu7sk02dAUlaUKL+392qeTm3/x2XRCbzXfP9lx9aCryHZoB8HKog3b2f0cxiAX314Davo24vBfk5woHMZi8anoQOeq0o4WtbxmBreZZlZ2IWcJ/y3M467PbGAyb2aHGZCxdecpbytf0qQ/glPsIRkTu88yN8UDplFGxj9jt/hN4vq1UK0TGVedCE3q5CaoUzLubaUS3CKOsgqMmGDrIU1Ld6r2F0gwlGH6i3LrnN9JFTfKgj28RdrC696AaA/bN5fk93X7M/mdgcgFKS+7Pap9tG8OlOVGvT3ImGRGYkzyW4z5AdsGmJVSsa4dCd4gBizJgoUL+2YgjThvY7zLeuK4/3w/ZbJSKfhww23E5k4a3SNHFujUSuE3klXXHLYQi8bVpmFJot51/CmWJpEMhC8R14eqQoJq2iH1H0/VpH6k+IYmq4tXVl8W5lfUOQnN+N8nyyuv5HVHJMr+DBYQZrueFG65WkRRE5AafwxbgSEeREpth/FJgir4IoIQkXnLQ6QWhuCtzo73ObBvOFc5vSC3rkY0yFH9feLunQej2IqHYnownfP3z4ZwCBj6j4XHxMYY5N+8SVZywa/ILJO9dl7gtQPoP74ieNUVhEGHL5VcoL34vws0eS/j40CBlkv3LO3QoH/mmR7oQjXEN0sx0Tr9MVTBfMYw4ArGkAVzp/z3gQz4vXhDTccpI52uJ2ahBqhqUjUcskExmeJr9Za1zlRytdv170rsf8ndv2EBdjMHaDEw0guhy928uax289bb/bdYMMRO09Lg/8QCLIpEp99+nAl3+ViADLRLxwLUFtfzXUS1zHznEAvwUSZfJhYgE3YhGjYv53kfC5aT4z9e1GSWMEoFfrTFsysfRKnAo7GoWSSEkl/sR1CKlNsASrFyEz8p4stnov4VOJEVw6Js8KQcX5l4TD99Rdugfn4Ivwuw223JC7yeqB/iCjd/mktc/TJXuS5TF7o+sVpiK00BPPvsVAZ7J58se0S+WsaM1jVsDo2vpkdC8w/HtOthx8ZLZKeBV83OCAPCkDiVS1TzQyfHW34kXTR93ETzTdEGehGmupo18tgnld2aTP32TTpuX6Y5bdwy7RhyXdExclfdamfb2BcNcY3yO5JF4/1UgugaD5iZ+wQkID3e60Ph7EseL9ill/nLsxAyxFbcHfvbjb9x4Q11/iivIYQWBViwcRe1gYvX5KixdXC0LYgOGxhyOhk29VnCjTZPjg8EiTliI3Sep20Bme1x70a+FXE7FRl1+2j3Q4ON9DiF3HJem5Pm5q98IEqIEv+uB6Hq73wA7jU2j97tNo8Pjj4WBock++3FQYzsBB+G1bbytoEP8ooC5JkdsAFmubJ9L+KfKzps7MO/XsC/YGN9pxq3ieG4qMwfN9h7v1+yyWHXtNjvncMQfwCCEQVbQTBhZ3Ov6UdWJBXERje8CXGoFLon4fCD29QK8AtDEPo5AmNx8BwlKRGszWSf8ztzVKVUxDdNUZiAb47WlAlrZ6hMGNgO0Z8SHWHKE/TlkaUS3UlqFIZ/1DSqTKg9RKHCjaPk67Hi1Xn48W35f5e9E4sD+ejlF/vKTzw+61uDE8sCxOGjl1scnMLA5RFjUhiqVBDoQdOWb3aHIhxXXqgHveQyUXoMdB41Po8h/PmReQzx/mZ3KsLm5kToMUsuEaPHQucxo/TYmzV3p/DV+M1uVvxtEd8vvPDiLSNgesRdI2xM7sZJXuSb3THmZZcTkhaWWiJmIeKqvl1eJ/p8zWF00MJLhJrCYHrMMFOYA2ZQGYWnQW49D47Dg55eMweiQeOXj8cTDDhjTB7X/rHi8swJJOXj8zwIJP8XY/RQOeN/4vQwcHlorB6EuN92vJ6L4Vjcapv9vnSom4zT9nVeUsCAtC/XeMfcZjrJ60eKFlzFaD5FuKwgn2vFT2PodQB18PHtZn0xQS+UENQWCyB+VKiKbWPNFaDXlnxpjMftOzWIvbGK/F5Ud27/9eiY9BkHRrvLCg665qISwFRVRyRP6ti4ueiqtXwDedAex51a/2MREejjo87UD7GMiEC+tHUEuu8eZ1HVsvOfg7XEoy+mjOVEsdQvkgYvLgaL5NljpTIuzR9fbLL9saVEF5Mr9TEWAqy8gZ1DqJTJFVYwA/CqmXgNZpgcBU30bVe8XTE1TbSO09QUPZz05FQOwzvBXl43BjdRiwdisdDL9ofd9C9NUOa72Bey6KqdNZvbh7gEDuZ08GkgLkg7TgMILaeT/jgUw6nSyskgG6Wd3kUv7SZj8doE/4t0cNMbDwfX6WBSV/5no/Hw97QzSbKr4bTfFVdYpz/tpkl7koCzmnggDDqiWW9yJfimO+i9JYhfayAW8HsGTmvu29Xkuu9SLF8Nh59OBlcyLE/3KIUx4EJRH8YOHuPhrVp6ZI1ILf9bet4cdj6lMuew4PI1HZ6O+7uDi+GDunw3mYzm15udoGHI2K7ryW324Mninr1exdYNr8Uz+n2agVCjDiFEBLN+lGYjgYnpg4YEZHzfHrThvjALmb0j5xcOic9lHvWHdmL4RNmRWPqs/WhrjBY6HPj0qtix5gM0kgf813SQjnsdAfToCY9gj8xnIM5Rw7JGG4EHclDvfQYqzspgmEiOqoIqDYaT3oWylsfqZmh6KPa+Kb3CaBkc/OF0stsN7RCAEon+fhuOPym1qk+PuukNvD+lNEuyzbhjFaLm7d1H6bRJkkAKkjS+2077bdBBLq/6CziUkaeIslt+3xIs993BjXy6VvCyQd+mGuEJXPeyTM37n/d40r1M7MwAKA67KDHU+d3gYJQOjhVoQsCoKsdiMiMJaz9pJ+gq1AhD2QmX2PMCuKDN8bgnXmXm2AKLO56m1DSMXURrfLvZ6YijzPR8NT3f7HbTLrM2eUKBHRP/oM8aL0WB/ouYGbilKAS1r0Xt9NwbTFoCE6EUwqyM4YfAUSmBEaCYBCZ5PsajDnIQ3vW8Hpp+yTfBDPPBNhLirbRF1lgVEJyIf+msAzjoWrgr8dzrpEpKQy/14KREZb64O/HYlfkoskn1Op1cDbv1RHR0Mu6rtZwPu3eY4b5WhOFINVlLwNFatQO/a/lTNSfCONJNIjt5KnpJJCHegEam0uIF6Pyhr1olFDMRGYboxSPNEzEluJauM01x6kC+oB5awZ1YLg05YtZf+bVxXKknlWcQTEkF4FJCgLrE/3qyhJ4O0E343Azl4GoCiwpurpFFMYtktMPAp5qeO18SqKhh73LQ7gsAaFRLbZCjskGomA4whuWTLaR/oGj8hIRqxDIXuZ/pAEx1FUZvpze9TgpoLK6Fo+lgIPXh67GmrXa3CxtOhBkBhXL07h4hvkaWzct2b7AnhmZY5AddTFEwbIBD3fffJ7GdxOsSIAY9tJhfdorJJ/x7RmJABUdDSdaKocLGzIvcLWFwsHEkhgC6dl+Lazd9XsPjo9IfrVGfbRuglxtWvvWHt0VEzb7rRdU3G0lRr1wAQOqFCh09Deb+pkTPIRMSOUILsDBO+hy/57N0oltXBdJuvPFQKJ81CACueYxg8qS06kuE6/4KqdIsDJ0oUM8/40QuJcpFCSuBUy2q/kEwhsdIdK46UVErx8OR0tzYqSvB46SjUsoqaqJbjNMLcYqvKBqZujlKztzT7jlg+tRr6oGjJV7CwG9p0b6aWV2wtXXBmNVy43M7hnNfcCe1wOAOB5DRqzIDUCaobgBU849DcHdayMnbU8CnUFuMYVv2/vxmQMzd3xR6t1e9SXooXrKZYQUUtwhiY3jKwCSzRVcLo+1d2u8Pbwsbo2pEMeY6DY75rOjjx4JUwJWcHz59adYZ986BRQW+sJcJKjdJ2lAlEiPSwco/orPvp1tuHUNu1sP9IPjga5y8QuoJWyQPXbRRjbuVGAYlmHb514C54PTwXQtcc27fZ9E41LMPtbq0xOw3x5fy6sx8ZWZ3CmYciVpDkg6m4vaTNjDipYLVmqVpCtXLzpPC2LWRMOZsIoMcFCSBx/SBoryuvn3b2ZF+zldDNbV76ft66ZlfTM9wTGL5fPoFf9kY3x6LlsGTipE5eDfEBie2CqND2R58C4z8N644gp1R56o98JSURiL37vj4UD96qxJCTh+b+oI1JqqhracFa0icl03PjS/WSL65KjErJ80NvQVfrzayAjMh2v7+DyDC0h/soj8cjrVrWHvQHUKGwh+T5Zc//fTTyvJqbRGsJ6XB0/JLSaD/8feKJ2O4bshQhG8FbKoOSCDqONfjE+atOw45N1F55bw3qP4gNWODycJ2LzMBwtdkbLoF0COvJ/Dk36j8wIkBfqisJyAkUFVEz5X/Gf/PwHQIUF9LIABbryOP+bOhgOBkIZMGBaSmAEN2kY4X5LLEytcSMTWxCqgE//+hhkJ46RXGl0TggDX92VW8UWVhoYIqd8b9i5zKMClcfdQeT6TZAAxSt3Osy37qsAMOm2XAblPi11e/oQynO6onRKYrjQp68reM1yJHNzEjk97Tp5hEDECaI2uc9s5IYMl75iyd9AaTV5vSskFUtSt82OBwsMRzqGpGl8tADH/R1HJMLt8OhxMQ9KfjrDqjAOlCHOgrRfzaG2BFYend8gNESAyTQZvWqWAJbpuaD385JR0EP/lL82Bf2cJUrQmAQLoVgXyqa/FD85ZeLkvXzWlFLuzMs+vRESS1gFKR/rr9DCqhCQjFxdUoLspLMQaJYzrN0laW9i9achwqpZAns52lgm4j4byyAki7YrrnYsOIuAfKFMDEZykvxI/lCG+76HjbawlL8V8LTvWPmXl1FUJvXqWdT8m5RZYEBLb44H5lgaNell5RBa4YzX2PpR5O+jcE6AHDUsTw6FIBekhLzttB0yQqgP4W8cWP5MGm2mLWh2f9Uj35qSat9j7sHh2/O3mL8nvl4YNmRmm+A9t5Th9IeEX52RI7dX6nun8GV63LkEBPPFixpAyLw2zjRvz1kTNvGSjLHQVuVpxESd1tlqoFUe8JxUN3Q9bKrnpp3yWFCHbuo9i25rs9dCZ7PClHw8duEzFHWBWqiWKAAQjP5U5n3jYnHhmgMj2HK3Y1vozhPL4sKmXwTtjBoH+XDAepMn0Q522hqaAljl0b3p4pGDUk6qEAuTvSSkGwKflk97b/++/x+qjVfghUkH6+YASdZs7Hw2Fy3R7c6ZdSFp0gnlbh8TAoWfJAfAFV22oPgKJ1JO2VvSfDC3vLiKUAOCiV+1IKB7OFPk4rajVnEkPUSEBSIYBzWC7BICluwVJUJAi0AtgMwaROs7ukCsea9i0VZGR99lJaXlJZa7uuN+CgCS+p626BNYHJiVEFFbd4Bw0n+FjBx+TNmw2UNkrW8L6h0SFo4Mor8dyQTZ/Z6mLf2YkpJaKsLFb117eiCXxQzeSXCr1+c/Dw8KDpI6LaoUVpG1R3jzn5sKmYiVQci2KFzpCApFZHsKrNBXV3KJIKOiVg0FVAIGwc2d3/nD2K/2KyFRlqPn6wThR88dwMrHs6TL0pKHXA3CQMSuh5LC8tPXAWneH1SJxHHmgwHr0E6C1pOGnxkg+fkQagphLRgZiPm4PujphKRrcG9cu2kvfdRtDJqXydn5EWQNOmo01pD2JsS5DB+qf0Di4e3LF/KUMVgLGRcHtXsRvhVNQ8Q9OCzuS3eERfNMWt4SDnLS6Bk0mBSe/iruoGdVnQLP17/gqIXPsmTbSHvp2Ru1TnSMDQ/M3TAX1Sp75WwIMW+/BZ2iUxV+Z9ghWalQnuRwr2A2G1g8rPXxUq5qgBDP5MECk+2BZiL+AW35Gsn72kOEOInGsACWUV1yil8GC/+Iv3e2NB0LDnzIslEHc3+2k6qv5kEyb4GVGlUT3DpiYPelXNsoIVZvr4pE+syYp85QeKiRWXw5q41WrxCYjP/FcF3azfYH1A27T2QeDEeQr0zbHnbge7QxzzeLY32YPeVSXeVkXvKzWuggN9i8pFjNP2J/zpntGmypeN7KNAcavwbHVpiXsqmbDSqid4GnFb+tpseUikX6zmHC653bcyU81GhCs0r6ynyeryCrC2jhGWkl1gjaTlRfB1R7/lqd1G8iUs3XJtcXKVDqpVWeco/V+vawV1U1hO9oDFQkZoGEgKbZeIYVsPuhAFK5TBsJ16tbUj18piZnJ1cs+noLbZVcicvBTWI9uuAprjRs+S5/Zt0hi3pSEsJJroDaeZ3X3FnVc1Vvzo97GQqDQyr1RP5Bmj25B3DDojYf7dGee8oyEkr8DS8wVAPUt+ejn7hL+L/cJ/uwNArZXcEagn3tmuLUp9aBV0vR76llL5Ou4auvfUvQ+dk71HbPirEp3gbEKz6grkj++zDXcPhpea9IMlAysbvbnwMwWPOzm/Si2iwX/w+47GWNemakYZKR5J18PBttV/h/pr619Q40DkVSnnl+Bb8If2bCo9AfB/EAv+Wrm8qKkhZ5Fw1i4oebAuvOpetjMcC5h3kRGub61oQ6xT2wA7B9WPcaennUDs0MWBrL7AeXC8Fnj8gsYPxd5PYQRRpNIu5ZmCw4iaImyav93Y2TzZO24dbx22jiDLYev4aPewBf6PEKB4KVb3/ebfWr/t7m8f/NZq7v4d6r4QFPDl6urzl7jJx90D0gz6PTg5Bv9Gwwi6issQNvnkuOHVfMnUXNJVm0Fd7IPSOmm+bb1vHG+2To63oJKZK19pe29n76T5zlRaZittbv21tb3yrnUo/mgcm7orbN3fmq3N/X0B1S078ivggZeitU+O3zX2j3e3ZKhn2/mrWH2pQTPVXkbne3K4d7C5nV9P9KZjSL/bXI6uXtQ6+s1b7216nkmEjbnXgGXr4Xh43cvSvCqakhyoACK01qQz2rpqD3z3I3D/3QQSIInLi1ezuu7QGn4Y6HF6PZykHwT7rtKuM4VWE0e8mHThvvSp9IN9DtivmaBsYpSWvE2YmaLywZApB7KihGCbnU9v7yYq9sHSWbSOXnC0ypGgXIX9HOnExGGdqS0Pyi5uuzwQoCAHmaC4M0676WAiYJ75uCCL+8MsRT5Y8f027DY5uALLjuCtczzujUg2tRwq6bV/3/78W28g3spN9bIppJz+CoIZLuM7SN539oZQHo/IQIHcjzxL91vTuBPJqtJuVGB3xdgn+pbfM/j9WE6BXOtUiUZbBK47ld1nB8QZkrdfDG3wCnfYufcERMkze+T8b+yak19y7S5dvTXiDBCnhuI9oX9VTXwNsA4HP2qPRYcV2P5rIe8eoaRRNwZr2gNjVv9p0WhNwVhfqvXEaEoE3hiACISxSJg4kFfuvZdMARfGVIzaAEtnCLf8qBG579FZZd/peWhaABdnuIIA49CWgoB9edrF3hoYSt8P//jB0RSrWRTLqXDgKnY8JfIgeleHL/j5LDj62KbDL0JsgkyHQq6mNxMGM91CLZzE2FXPuE20lXZ4teARzdsfN43U4wUnxIiTkdV1pnLcqUqcPb5/7tnEtl5nG5fjmfKkCagfzhMxLiCY7bQikYOSm+X0F0U9/ZImmBcgnC9GCFAxFw2W+G1Cia0xZxbbU/5qo/8jFx3TN7/h9/Ed8G92S5Fld2vuTvfWUBZHWBgA9ykOz9JyrQg5imh+4e6f7MN76OBIcEnbBAVOBu3p5Go4FixWN2lLO/QYVsQkf/OkeAWnrNRB8VvfrxfRT8nr5lNPt4Ha52V4uZfepP3AbqksYrnzk8jhu5USS4nT1OV1vir/CGBXRjxhl3LWVBYjI7M3vo6b/f6h8hp2kQaqeVdPLpOBOdsyU3EXecS3OjbA/BB9dkQ1T9oCRIWL3PAE338v1vksaQAPug2SnWeLsFhcpwaWYHHkfgh2G7IpoHEzqZXdj6+PhkW0ZBbc4yCyTaSy7QuBWRohWML374W+jLibmVSx6Ds+ZCAUL3ihhZAjUusZMF08/REFzybizSAuUK3aGQp2kt/gL7jF6iC99R8IvPZ6vZxffI1xeWkpGThVAQWvbScH8Dk1wpm5/rwYIvdl5ZrO24V0dOyFmAGztOkk3RSsDBiqjOvJqJ1ldaeRAhkZcf9qL0OHENxH1IHn4Rq15JA/oZN13IY3W7tKP4OqyCu5e7+9WtXj1MCBbW94m4632lmKTdXlzF6FjkanVSXX+z5ZWV2tJW9A7VlP7MeXqyuvltTnV+jz8suflpdfmpLll3rl8tfKizM0bgYzG8v80LCupznrUlNkVxCGG5IrB7l31YxA25VVGcWleOL9aIOSUDHnk40NoovT0Y/Jk7c9Hrcg97YLJ4f8ZUmu3ihlYKOHOe2Ud/jIFBczwfCgOfh+2ZwZ0DjtT5QAtRoXly2wUvgaTc0tfXuUpyGcbzOL06UziSCkHgQGRbJ4raQ1jTeSVxgiLqCv5ESlfY/tPm7dI8d4akLZL15A5PSr9nhr2E0djE5RNF9M5AIDHKnGbdykg4lxZYb+S4H41vqA250isFCOtj7Mvk9+igBnGRgq9HvF+/1zEC1Cj/AG7DICaWRMWu0HNjgZGI/c5GIM3qiwL0bdI1+wehgQVEsLYjMnbDvMcyIO8BoiOnVnsM2knrYmwHqnUz0JZMQlb2So+gVr3xYPCrRq9aSa/+K9jf7Zm7ECy8LCumfDNu7c7BJoneqqgSlbjA1frXGST48rkYBagLWpAWGp6m07Tjtp78Z/ZN57g0tjh7ZRAjICnRlfwQ+bozaWA9T5b+tjAOqq9kTWvm1niQ43Vcnhh2ZEIKn7vBoPB2BGRSck+AhtP9G/M375/sgh544kZgSuTzbUyv8Y2PYG2SRV5v2uNpmfbTRH4O4OOsPxGGLmqkHVpKTMdAJZjwULzRzVYhBHyNOw3xVclInI4Kx3KHESHJeq5bFeqrWzmDTEbsH6QivfPWgtXblVA2zxRIodicym5ypA/nLd9FqrJ2Q81IU3eTVRUXM9Ro1yr5mEp8IGSKD+92kR7prDVh+tl3ibx5nEZhxaN6Mn80vQOfKaLIvSzRxyoRhPUCHZEBnB4NxT3xey56iYLPwnw7dpE/wTBE8sPwCLCXFfXyek3OBXSZjDAxdwRK5MEF4LV9M9wPW1++wPs/6FQhfVaZ7cwJMceA3KylAKrzx0FoO4KVR3HmuhI6gcbx0atkSLCbQPVUwbpqbWAbPRuLbED/cTTMF0ILuLqA34LCxFEvn7EiDmBVr33z1kw6WZ+1il9vVI9jKzMFkV+HTxcFpJXr8G1tpeLUXScvVQk1080KK4eE3l0ZcWOvOpcFTpKzvMwqtvsQdJVw8uqsvPaz6dH0lqEWD+LDgfYPtbQZTHOox6cpVKX5JCbb6Ussi6cf9Af132Tl2qw8prjEH/7XDcBZCorhezUb83ES+ACmPNL6tKpBFrOPgrY8XPQ4XEeKKjw81atCVy6mDOGCCbdhwxnbyxFTkT/KGKWCOrhhj+ZRPhzqzpMSKndwMy87nn4Eq4nehOm37DaaILlOzkUvmdjNH0AMPRa3sEdo0ZhG3CFjylbDm0S+dkKsEEIozdwURPfvmstl40Z9NW6pGTX0Jtb7I247rAKVFJ/VWIRH1oZKAJA1THHC/XsNmb7AyH0y5NJR/66lwt9zLSrzb+QdkdDmRQdIDkBvVqJxENc59Bki9Sr1ITdo1/xpS42gsv7vsiSjqbS8VDn8vmMYytJLiIAAXqigIJXYHJVbwRer8QNJFh4VOx3eoIOaHMMhLHZLc9yRKZihReMqv8i7UA5r44DLwSrHA9aszOWZAxrwNG/uPbVbu1rJytRw4RbfM6WX7I8BKG7c8CxaXwFMlrn58Bs/UC6AL6+kJ+XV5hDoPt5g13jUTNgU2zskAyJuRuTqtndI4v5RxfeTP/Sc38pff5lfy84mvkiCj8ZyUK/1k5KoQC8ABrTntn0UcIaysfYZIYkcPP9aTHGfYFXrD5LC7SWoVs+IuYKeplOjmSUR1l7sVMqZRYQ0zbM/wL1/dTrd0Sh9PtjvqygndGfXrO70rERaEwNHu+zc3zkNWMvU94GhC6qDDc64093PzxXbF21LRkzZhrk/n125eZ/4Agb6VV+VTiipfPQttNVbICJXqeEapjjHFBpSrjYzAMmZlcnjsNx2FnSDPra4OpJbBUDQfzqTNnqx7SjuDwkLOu3dphLnGNFwYaUIWeDAAimnhO7UVnUPXwHForoEk1Mbc1L1wdqSzm6qyeWaAjpTNX86VfU/YZr/8TV3/5ZbzBK67ByguuQdkHe0Dg5N29uvZdOfNmgavPH3JBzsYNMJTgwTxB1PWmvOIYGPsY+xBcxeDF/uKVSxQSjP8aotNF73V/rj8VsR3EHyoypx9B7w2hvPhRwJpifd7al6Pj4w1nJxyMKV4a14LU/Naklei8n4LJnFugrIrWK9X58s3y17fPshIKmj+WQewNDEkn7CHDGL5i+MKqaf496zpZi6gcgrDcoRNHnl8Fbklip8QOee403cUVm64y8QCAt/Q9xjNvKz/XvvbdN5jrrSfDnqqrTupA3ZrBxCPH8s7313yxtLxeprK0lK0AJMDNUYXb1qHMKuszuKssfYmlJqtjYgZ5UQpDeXZqg2enSg+WY9s/ww4Ec5OWdTC3dve6N6jABfGEHrGSu85uZDtLZL/xHc1xWIgMcSigCSIuGXwYUpAPBxpPZWysL7HPZ5CojG7kvgQr83Ltu+ItewgBnsVh5QtOXy41Dno8svthtGnIDve2J5gsJ7tkFlB8YxbuHb8LP3m7wNiMRW9cXynP3xLljKlc/bbzXi/effp1lZd5vORf13a42Z7VGMkCf3pnoADXJtAOu5w3UT/9HAAmxY0ATvrbepnWdJobBgDrrOKym/YnbbsdZikL8VgB0a1F/Wl4G8gvRIMK5HQGe+A6ey0jCjEUkxUTha2BPRV7hVb7WkUymaHPYpDMtFMBDPK2ysrNUcBhY1hhTBxyLARcq6qZYL2sfcQ9u8+D9Fa/dBBMzevGQj4GBfd0wKtfWoRgx/EaT0WN56KGGTt8LT1AKxN7Ne2nt8lYRo52FJubFH36CA4UMq3LoGEIMKoSDhGWgVJO269U8YJqXo+1Mv53BXzSH0Fc/nNaHqyJm4nZKtJSzWipnU1HEI1LsC/aCQ/jP+eF4ZwGarPlGjsZiJV3wTsptSHoBNtM3CLWUPA5nHLW1mlSvwU/SgmjmOPEc77jw/2XZbzKo0DPvZmUzRztu0RdTSajB4QYkU/z6fmR5NjYdNPyp8nlVFkv743Qy5TuldcHvFHMkhpDa+0XVlRyiO8XyTianwyzhVHdxVKNSUJXQPKxhn0jqaLQbf8FccVQOi/fXWYGvX1OLu8g3h/RqCvPNNg7HPVQ2y3ImxYbMBCrR/QY4DOF8/m4gkRo6171LqkazWbmZfCSemqDZeoPlxEEdl1AhWYeu572Jz3ILvXMZjNzvUppo526aBugZ0LJc6jo0pOw5iEytxdv2WxpPNhI62RtuLVfn6SAsHnD3NdoysdZphwgDivtwi0CeRcZ7lRpeFSDjnZu2pxUe3yaTN4NqKyhEmOi5K4Zxr5+PZo0MtcAhbcWLWXFIUibcTWn8SqtAzqjflnlc+sWyulntgNS0ol64jwKe1kCsborrAfag7fFucnLyKUmYEzlq++HvkoCXLPGWEFowKdP18OtwKEDIcfKyk9cSC02viCeEfbIE7s0TYuEHTABWREPpw0m5Xc5KJ2L6diVc1vrSrUdYn4+2YhTRZRFLORQ76l/LWJCsPtsTjdh9r8cSGqQUQ88xurqP2e3zNktsO8LDfYLrP1ixvn3kWXxHj1ipmKzpmya75GJwjKV9+NykPbkzvhSrYv/qo7NN3XE7DC4K0crrIMn+yosYQP6pZ6ReFqI95SYAyDT5XUet9ROq8Q3OR6Uca/Rh22LY/QDRyvMxsvvWyAKb6ZBGjnPH0CzsbhUufFyr27y6KgrAw28o9DyTbKyvIR0/95jBHzSoMwIw72NNc4H4YarWUHf69/NJmVZKmjgCzeY+rzUbB6WBkEUtbypsafAbuOxH0I85lRCK6/7XAUpLo6gMquU5b4egUy+w3UoZ5PvJNjsg8HxVbrZGyu3AkboHWCF743NGJAwW+63Av8bNHaxSU18b4Ou3eNkRSAUmt/TZHlp5YXoki6dGIX8SKfmZKCBb7kZ5qnX3Zvi2LoBkXVTLo5o7k0/zwXd9vs6efmCS/ABYR+03gPW+WNSXV55BTC3N8szDBze0sd28jpZ8TUTaICViOV+zvmb7QQ+7Aw+RNYpzqFZ2Axu1ZjQK4+bmFiX7N0b8QbgjKYczri6z6Culsj/CH/naWjVtUBnku8Qbv7VPK7yVkppNh9ruKtyeoOJnvL3Jm5LMieNqQUrXMU7j9uvrFLxDkhZVJGttYDt69BTDG5LtTzbiL+coaLt7bWcDYF3xBDZNnmaUJ9JZAEMyqGfeVdJVct0cuaxJrimz5VQIyyGvhdMOG+yy9xkHSrI2lLK5MmdjHWVAHidQr1WJ+CRZRum0JNYhnJyaoVKkvcp7Ff3FseRecJGhICE+JTz72bJZaYOXZzToRQzj1rylLKYSpankLNTx9koI08VCwUm0pSJYDiJhsRjMnZ9KXPakNE9f8hmwr5ACIpigXoriz5e5yCVigcbMDETtIje6qqCxEicuMjFiieMWWuQTm6H408aXd6Hh0mrC7jXqFahGN/YyjMIstg5X5x8nlRq8LTxuPNwDrFELOx7gB9TgOcyHatEmV9t0PFnCOH3tccE6gruvl9vzPbk624m5I7OvjJccdbRGQZlkwLNslSbI+xrjvrx5vbFrhh1nmOydDRyGwEBBwsGLlWiNA04H44n5jaylS2pRkkZrK5bGUSQ9Gxg0TgorVctLTqLiFx5kZicQXVZpj/NEa7VpNmNuVt+EQ3jUXrqVhhWSSTRh5tZJsoT14GMvVWpsVqzJ4wag7/CeTkcNnggO0S3ABkdPPGidXwXDhrgibtwC+SdpcKceAzESshAlOIOSkvk88TEDxIUx0TFjyC+7WVg76L3IkwFWPYA+5Gdx8PRCNATx40zKgoV6FkPafziFz3bhIQo/MFFNocyrKbPeZpw/93M1kco9YwXtEEFRzTiWi9qoraQM0eFzpk9KyU1eVaPZx67nu1OmZhlhUqEB2t8HgytP4NK6AGqR5ymMRql37fA4iL1PgFRChup19vfnGRdpI6zJpOW/+6OK0h5poBgiZQzzV9atz9eE1Szth26GFt4IGKXo1i1VJDeOLWSqmNPTVQUTKpsKKm8QFL381LIvSgTqhRQiyfXVbeJoL+txRVu5QP4BIda4z57omFqo7QbTmT9uxmiuHCB2YrjukQDsd2XOObUnNLO/i/D3qB6m9WlFwjK+ldXDjStjs53FZpV5iv0Z7pzIMsqaOSt5QAo6zsqd+/vwx5S0/s5Y8kV5x9yE/4jktXQW3FBikMKjsJsglrmdZvlZ+DKpZEbUROJoppRDs9m8coVt8bEMPJcjtoSvBCQOxGzTsReJlWZWxn5LvsT9MMo33/H6zwjYHhe415MynRZjA+OZIefJuHqeIucmVYGM/JWx02SLlAfOYQD0SxCD7vkGCEdj7kB4IIaVX7WONS+4Q0A1OJQTgedFMBd8+2N/HL8Ksq76GOnevagKSRwkpdIIR6SplQomkgYFCSJfYG/yLAnK/jL8xxDgTdvEhLHAsXniLdYXiFNGGPUF54Bqg7pYYKLqLA4JrrIfbSb0AscKZp6MsYDO5CNYsJ0wNi73vO5a20ckqdax0ZiMdlYIs4n0UYLwf6IOefseSw3bhg3xJwKlD+dpURetlYQmc4e5QOM50RLwLknBuny3TnO290F8QGyti3/D7o2cxa/tM4IKO7xzAG55fh6OgKz3+AYkwUTWfnyifDRKtRc3CE34STgu/Jkhb+oB7OMyVAuIgPlawsW+Xw+0H5S+BzypjAYLojaC7fZl48PIAR2aLf7ue4FnQD0ZcNNmDaOqeJ4LUSf9ACKtJgfr3Ef9nWlSzFVgeF+r8uAEiuxuBaoq1PdxZmOb8EWFcS5sISoRgwff1cr+F2Ht1ixs/6d2vubuBYrp78HgS1+P8MSL+JRhiWYv8OzCQ/iWqE2DocMVEWrEKylEfoFRijY/4tevw+eI89zHtaKXl6j0I4PQ0V9gv+1wcZ2iaQ4h0ar9tjjKwJ+kwsCPnjXQ1G4lEdGq9nipsD8+Qhh99+V25mcfVmlGZK6KH0ektxpkUTrfJrdOQiyitYgefdzk3WoO3ToiPrz7VSLhDMvWFFMTggFOInAPgcJWvAU/MhAEZdPxkVH9oD7DtIRta57nfGw2U/TUUuwo+l40O4HfLgxSyLzApGZBvKbOJB9vjaWCTEv7L6V89EikvI++mbJc/6UlifoIcN7M+YmKKXyk6joj5OY4P1yDcUWXPcGYgl42/JtSQIRToke/fnaStXcGL6FAt062O/4+OPtcG5SVZd07WDQ7w3S6qzyntgTTn/PpqN0vEhHUOOK5+ZNe5x8/DUdCALZaTa3D9+3B+1LGea904cQRjCGGF3l+BuOpcsjID3FRfFIl75shHjoqTsxjsMiVQTjbbU7V4C7/7zHJZOrMSQPCZp8hCatw4OjY0D3n5eWgrL3W5vN49bm9vZRq3l8BBLFlec/L4qHmv7/UiVocnK03/p4sHV8cHiy1YAWAmhrd0Ox3NG0ky6I87vWTW96nXTtanq+thx2sL3b3Dr40Dj62Hrf/BU6eL/QbGwebb1LfkzAf/fZ8uIyeGu+O2ger1lJBjtfk+DQX+3T5Afo4f3m/loly7qjNUkZbtKxdAV9/7e1VfhXdP8DbUzXFnqOOiqmfTfhTy9NX29wM/zkRBYCFVomfSP83e52pac2/A237U2KDHcQCgdCEXqKMZ3uzDZWHsnhma0GdriHiEUGnHeJGXuNWDfdByqY6bTXPR4qxkLOEz7gWzqTWfog4WUX5euzfEY9mTpGTN6yWGwApU9Jdp8slpDPxqY3k4DnAgQmmIrHAthLvqyRN/7U6HTRoC//iEFfPfagsqPKgob8VAbl1w2tacrC1sHOzkKjUUGP1CnNm6DJqK+2ktN+RRz1bPcgYNmcVKfwkoUsBxXzbrBwkI8TM3+BDK901Q+7R8fvTt4uobBxGoGW7P8qJs4EEbDiapUADKLUjGZnqaUiC8lUL17WDIBLxS8ZpQ53QGZORl1xK0lSbntXh3QKp1VwWeJIi8IP7X6v25vcYeoQFCavyeM/LBeU/5Wh/PrpFdT5ccPl11RCyNvi+FfSlsJWs7fTqVkS0oqP0PYsdtOJ1Jtok1sx1rotu25/3pTqh2COWH6sQSUTpY4gTl+Mg/Vo8WgRU0cJbNUcmUjDb4P6LnhCIJ2fbRTJwfs8M+lRWVXjaOhxqklAIctCAs5sB7ANiCfTk0RfxFTX7JzRd7xha7BfuFDt2Fq4YVwa5xyolYJZeJYOgci9V1orCSEkzgSYymtdpgLRKUGAu0hWlpaSg7+iO0ZW2z843t35CBX1X44fQVWBI8w0hkhpk0rDI7kEdDJupFgesWqwW7KtSuaygab2r38lYYmaA6OvR8lpZatYAAd5PgWjCZNQ3ffOzGzXSNYgeUShpqFxG2GqPLWeU1kNMqeIC+e6WjtT2V4mkHNCf8p/d+puKnsHSnpcOYN3ovl60vQ+bG1uvWuIS2f/+Ohgj6lrb6YYE1fzszFIxzlxHCDSO+nJQKZSI/kz5JYPVdzHFdTILcC0fCZarngtzYnASXEia6uxxyS4MNRlYWdUt0MUn5Wtq7TzqfF51Bu3ifVLaYqPgmfLF4eDKzHcIFXII5l7qXi6HLk3vYFPxuibnLt20JWjJdSjWtQ/WWZ9Ekte8O+jN/YSwkiDLqal9dnuAFiof80Er14Hl+hD3mFDsI0ajnWQVtUYfqMJz83qxXTQybGR0G/SgI8DA4hFkhbsnn+ukv5VTR+PD0bpQGn4MyLWkYXb+k1BStBT2Qm5/G5ZgAQwGI4YScHc8TiYm3SsoWv+A3CdQ+pA1HcyGKeXkP9r/G56Xg05o0c+A3H5BiMv8bbXIY9eoIXxOB0pISz8Aapw+ANflGoFCs1BylldXgJxu6hl5+pvKtinHEoLjGpMrlH3ZRL1uBiDWCwaIZOYjwx5JUO38MKl7E7s1XUrHdxQ8ZIiaMaWrLXdOG5sHQt+Yr+BgSre8cAZnJ4RSGfdkZNp+RIobZ/8TrWke9RNb8KP2eDtnYpFFn7fV8YStOBCFOiJ0wJwQm/kZiv06mkDucFQxVEmApypvE+305s9ge1Ni1xLzFoNNoegsqaC1nbCft+KC/Ha43FPMAA5NQYCLp2rvD6kKCe3D7G35kTc5VQTh+S2Pe5+MKzqkieJ7J2/k9YC43D1so3pGsAY1AAq2j1KIWxXbr3ztA1IHex4L9sfdtO/NDkpqe8PJ+oYv/39xvFvB0d/NR4w4ix6WNrrpDAP80whjbcbH3a3Gq29XXE6pYJ99/gj7aGbXrSn/YmMagdW8wLFznuD9vgOI5h1+svELrTP+6yoVyOvB3bB9bd293ePd8XokPVwI1lYRsW7+0rvv3n068n7xj7IdRdWvObNk0MgOKoxNhjRq4M6Owcn+7L8BSoXtKsJBh3vd5vvN4+33kH5atj+7UkTHkkLL1GRhjZ8/glPVxtOwvdXZJqt9wdHjdb25vEmlP2Myhp/e7d50tTTX8aw2T44ebvXaG0C3GQhhgzJFQmFGCxHx1ty2UeNzW0592UMl53dPQ8qyxgszeaeW8XyaogMW568ZZXZsF25V8qa1H1iKp4wNU/4qnsH+7/6VeEbU1WBzq+svqLq73f3varuC662+Te/mv3CDC6uuN1wpuorqv5us/lOINeOMigSteEN1yJfCTLaWy3nltNfT5pvcSXxk+mpcUw6ahyHdTb39nAd8RPVcdcx8PHuh3jdw8Lh7Sq5DFrUOhlko7TTu+il3aYsaQxuInTQG2bRFJG7bdD732m6C2jMCYXftydXi2NpOFiFQBU/gXL+xat6MmuBr5Y9SuHpMtxWRyKjurqgMM6v+JtbyLL8gUyJKVh8P+xO+8Zq8+OOeAnJDFSiSDKI9aSialRq/+Fp/kie5vG5lhjXxEjvNkJbVHVZ6UfYFnSlnrS6w2pPvyL2egPxTg0rhNapOZ0p+roliPHb1vHHw0brYKdZrv8STA5MAV7Jw1upshD4CkiuxLvih8BkFax6nAInRumBfy5QBznHwvW87hkphjOlL2xRbo4uqLGV44frzj4DRT3iphPMC2YmVgwVGcMCt1xqjD6xZL/qP+XIlZJG7wX/LjB9g/L2GiC9uLh4PRynm+PLLBT6wcK3kWGHCvVzp1Qzi5fpZEccsY8CH6o1z2lV+j9XK0sqKYGq/F48Wq9k8XKthgJ3e9V1bTUuqkcNtMALgdR/N5yOMzIPb4y1cIz3vcF0kmZlqjZTcai7WWRGo3F60QODUICOCdQ90TnxklOU98HcweL7WYJV2VlD5/9BrwFpu6x3xwjgidAaVwDRO5IBAFPxTPb5rLc4kRHh+YqLQIJrxOTMzgWbj917JpoB/Y8ZJBSugluJdjfy7Y4EzoJqlam5XpQwnGnKxWjnw44Gi63qLX+aYEtR3nACgD3sp4pCuIbUeKIzzSbD60QM4Swn/MAwpiNpeiFOrlaXC3DDg3MyhNZrvvpG76bnTslPKSAJuR5WeDqlushTc0amOutEg2nONklOQ2Iuyr3hpeHfqqK3i+nAu5wIK6RqEI2/z8Uh06B2twuSVUFwBTNDjF9oHmzNoZ6qii4R3biPdOpPfNWvTrMjeF5zm21LaYdmQcPOjGCWaFqVrFP1syggOU6zq2qYTmJ6vgNRMCklizvkAOfO6ymlHHzs1g41QVGJ5kmUNsEqwPvBMwFAs6OmsYzlOvJoMM18y3M5+dFUwEHv3DpLJNFDhNs512s3hQi8SalWoTM73IICiYCb0BUxJvXQTsy4Cz3R1UpsH0iMLai4eDUEtliZwZkZy2/gaCVrABPt15DfbA3xpmz3Bn4d9TUMg0Jnxm2jZ3vkjl46yKbj9MS8kbQMcH84OZoOBoqf+Sc2Tcp5U5lIAJFoqWyb18nzJRVh19c7KAmT1DusrLLpZFyPetbODPt8OOzDg6eTqjqQAkN8UXoYc7+EWW4ed116D9zmWZZ5jdDGOq0A2XvQ0/Y7Yjty/2Dy4hZtELp10Rtnk03vzSpWz8HORYT2HrkYO/1tmI3s+K0jFh8l15t4x1dHOOlo3K/y+jfEyeVKExgEwdG1PfnMQ1egu/JJEbWsGA+HEyXF8Ujmut/PtrwQseOsvhd1Fx4n9UQ1CTgpolP1w0zAHLoKWlIRDQkDWXDRbqFZ67qXZUqV8M/7dVqorx1353BmNRbImouwCmWQfvlwhTXj6xbqnKqGZ9avWMEF88vcRuZtoQX+1GxR7FI3ENQTQzaeqrX1BtvY0F/814I92BqQZjmMY8x9bvRFhfStkcpQUYzJRTgMHaHFi3/9CwiD2Btd7Tz8CiI9qZtDJ9JYFASp6rUlFoJ5V4JlG88bN+lgYr0iA0mhF0qfh4fpJYIN6c0k2j853kmS3fbUA+tmspjeMGGaZaraytPKWjwTK59EjQk7ocJgyT2RL3oYVB8leNeP+tPLSz9fApe6z42dc1fkhVVxewtTuJYS40UIe1iNaptq69E+2KlUXc9cMsJo2BYOZORhqxSriR4u4haQk5Dyu8KUqmrLn+VsuSdlnh3sbDePDTJwmLtMHw9iC1/jkEwHDzgmnsz/ofvldfPY+6WHm/+GxSVSjN4mQqaV1NIQ4sDk/KInng39kszeEiPDNg0LePooR39Pn2XB00bcYJ00y4DjqWverQ5vskl62L6UaVXTfn94K3/gZ68WVCAeiohVnJLI3lvSpAqOOmwt06vqQfp4jcZpR6aecbVObfMzzABfTJAS06oHmcoyCL+qvJHcDHtdKik1/cTUibbDIO0kMybIaCZIR5GXEtCtN4+xkTWMB5ysHbDnV7fSxFqWLl61x93b9jjFUb9lHhRBoPRKVUX4gNUpCFDyUI5Tae9tBXQwSl21Pf3/2Xv3/jZyW2H4//0UE50+e6SNrUiyc7OT7HFsJ/HZ+PL4kl03df0bS2N7NpJGnZF8aev3s78EeANvMyPH2e22T3tOIw9JkARBEABBoMF2bMo2JVzhNk7U13hwleRTJhXxK0Eokd1awriiFoBK5dBr+gKqTaK38o2BlBcUOu88+pYP85rIwxYa4EBMfIZ4Yao2wbyagKgnGPTObHSW5KsmnFuMbCEr4uxoDa0myCrC5UpnY4XUnEuGpClFePGcq8OztT5paNdUDZbvbUfjYIeJpQh0DQ2zP8vzgdbnDPWFDkXWC6nvUIDKl88YYJP7SN7uH/Nb/PY7hi/+c2ssnDTFxtRHojiCGs4OdXg2Cvr/QDF3BWRaCWVBdHznKAAwcl7n7e3x4OYzX0+MsIBfDc9ggQo6Kdc4LJC+IJfbZLSeXInlMu5DYu0B8OYN4ibwIknwo+YejAwfKcK3+IrrQC3hWLbyOUTT3wFbT+bFls3m/vnPyEKg3sMQPEZsdLfaW3ScsFDMvSnmwi7dCx7N33ndH6TcmqwgWMXXGTJ4bY6hYzRNk97RK6ZFuZs/umKpCP070NViLbpyIkYTXmTNusTKH75ow6dWXATmkiQ4c+ATOIkgwDt4TEzT85/ZqcbNb/rghmJwL9ljBUwgHsETAh2kXt/BQT1PKFvjFYlZh1KJUVL29keaJUVUinfcxSkZmOZEU3WBUJEQYwRDe0/ZcjGZXsfFoEsrAXsCqxDML0TPEhqBKM8wvztObwx4XGf76naXCVuMgjS+1fNI43HkWLSGfwzTkno5SZ59S1hSIljsIvNAkMb2tIbBwX9eXMTeTryvwL3NGsZ7cGy9uGjfcMrIYClGBcNK+Icts6GwggNhhYaMwriaem7JxP/g+x1ULIDxgAMnePtcaQnLDw+0eUyspVqxL/w9Kfi17v10eLq+u/Nu/cP7441fzIqv7Irg2b32CSpaN6yMJTPtfCMZoqtQ9+mqYxBHxEKKpzfG/AjW93hCKj3yxzQcvyGqilmLOIxduJh6ZuUnO5+NfXV7UJcmakadgtdlI7PT84mSRShZNV5B40geQ2K0Fz6eZmicARHNHISoXcnv1fT6qFTJeQLWIRkF8BDINRGw6J8LbWlr8PaWaU5sNGL2LdsGL3qAzdXw5SxkoE07B25VjnCuFCxZhhBpyFUE5lpd0Epl0ty7o531T2sfGc2tOGYV9YhYDNNjw5Gjwn8VA+o0Wp87J66dhpiSCvB148hCZbFJjkQwenH8LHDAHpOPxwbnnd/G5qePu++906tSbkxEQG1vgDACDmlgmqeQgIkJuXusbrOGuar+bDQrWalALpM3ztfR3CnjFtwfh8CX/DQSqMyZWM3Kn3re6Yg0xBiCHK6HCFtmxHjTYLuxwzai+fnv8LnLPvc8q4gHCs9szA4TntaR0620AoikfT3/ArOBiJsi43m5PCtxsGawl/JFn4/+JEt6LZiQf4zEm5MNF2K0Po56T59FP+CfPfjz2dOnS/IDBkTtPnv+/HmvK78tn6wGAI9EfHQIqPhDtByqNphxR2ZfOcwE8KhPz+f+iYB7IawFdPcMMww+W/VWoz2eqhE+P/HXpjUZ9KYA/z1j7/DggqHK306MW9R9Fhqz7gDMObovP1CvV2UVKJ6sNwDwuzk7IV10fCDvSvicEKH3k/OmcMyVg1tQcL23AsHxmByMPA8IHQ7UpsBUCDmcllOyMZPv1ZGfPChPxhM0zMPy+PrKjDQzSPqMX+3wA5Adfp96zdAph+YADqD07OESA4AdeDvbm52xjgQodjQviGExZsWUjaqbzbpntR7BwyL449HBBy+GxTXtSh3QFdkwtPmFyPbRUxAYQeJSFuplbmk93ul0G7+LlM6qcTO+HtaymXpWBaMxByAbstH/T8P1jVHdk/ApStZ82ip3XJayp2rJO2t5fQk69nrJyDmkOylKLriXnE4EnTf+A5v7WU7F8yE6LR5Fp3fSqpJQuQFNiFEyHM8CgVpxA4vT7a2435Y9317YaPE4OnnYdOgy+ulvg2WpAEicUh1gPgVA4lexFRnsSCgBrKjywrvGRa9DvVVotjbHYtdnFgXbaXjv2mZR8+Gc8XSDYIg/BBO2NbxHkE+wmi1f5i33WJnQe9vJaXZOpoZXPHCLO6EKPFZq0QQSGJQpGZsNz3kXIJcznmj/H/Gc70Nqg6UeGqeBhpYg7WC397wyhiGrvfiaVRe2IN4fz7MBQL9HWwI7EztM4BfHxafe6bP9tZ/fHh9uHjAVQH+FF3cb8P59VYL+/nX0bMkIkMhzovN3entHb5m6w7OF6GB6gBmddBD3B2L0DaCwJAa7ei2wXgPbyvN+HU1V5kF4cLi7ZzjDhoLD8/YS8fwvH+492NeAeDOyCBGnF1zTVyC3P+Z1lN+eWCSRKx6WCtb8DRyji0hDxkTZB4lOw9YswKw6pC2EGOC+cLh86vH0VFAfRRkoYPjkP8TXZEy3wNns/NwwO6LVcDyYrBpBHzl0gn+DshhGQ5UUoVmpOfmM6G17ra4MNwUNg41fUKiqGXysYzYj6PossPX48YmT3VIaknRb4wERnC5iAB8336+tH6+E46HTyl0x2hVvaU/OxV+8VF68XF78tLz4mVvs9xygK+l6XgqmWolo4pUBewS3iKVNC0plx8mZflTXtSV13vx7Q9as2/rOcKzAnceb+RdvHcNd+NHHuea7j7trh6ebSyuWLXU8G/GjohopourjUF1M3jBvg+6zeVv0ln3WWrWNXps4sWlAIFNgnYd0gKdOTd51q1X5sFKxqRAM+Q4EtG2bJoCdsaYchuNLTE48rMhkD3yPgbU/46dFZN08NrAj8C0uanbpF8JQhaoC3a4JmuBCTEhrYlC7VTaSAFXTaiaFIwXb5HtVi3Kv5iDaq3no9WoeUhWZ0frCpNO8Yryh2cV6S3Az08U8J+rDD1ADmM9SN/qnoULKx/oTDgXq9Jb48Y1wes+dbodZPOX7XI3gBx7QZJJdN9lZDdAWoV8jfUaY1BXEH5DKPcReRer3J3SXFu+++2oS9xH4HORdg2F77CGiZuPHxqrnGYYh2EeufFQlHsPseZFX5iKWU0W/rPjEuoV1pAZ9fvni6tjQDNPHWIvoHj8GjTAiWjKtD2UxRqdy4PiaX948CHDdZPHZgv79lPxeJr+X5O9Ou9PVv9VP/aOjf+mfyZL+ScCS3sggnuufL/TPl/jrxHgpDbZrMccTa/rpiB1s2UY2OxsmYIg0olYkF/yRHXG74T7Ahf5jFI+nacEvAYFHdJafk2gLopAsuBhSR1eChqCfPH9GlBPVN3Xy5NZNfoWxCH8ZrgYSlhEkvwTOogbwHTGjcr5HTahAIjhIyK/YJV4pojbTAbtUpcWEc3zmPwiIXp8Io+aTiHC/LvuTN2x5dCQxpx+jRYCwItdDrSouJgSBwtWtu6qQ2WoBR7NK0TGRUeONlZe4NhPimWt7Z9S876rAsAR1sTPg5UsRwY6PTLMvwamw9htn9XjtFjAs0fAV3vnoh+Lw0VRIAROq4wBAgxRwPOgqwLrB1m9wO9ik0exi2sYunsd6v3iJQ8JV9QmRQBf3II+LZOqJUYThlKiyZ7wEN4ItfVZ1T1w1/ecsHxRNTLhLaG4GH0JBmoR2BVXUXaypQvcxFMw0Ji7Ywn+Jnl9occLT9wfj9E3JoUC8UrHmL0ZNzV+o+b6k+bGnOTKy6uaMaTTihu0BXeR9fkc9I+gAsYL9P2LVyJEKKuhi9PK55QkrgLxxkrDzASLoz7zSyWq1iRStFZCijdEzGZUJWpALwvb57PCuAzOgPkNXXD8L1oStYLkjgQNhn7ts+ZqZyNGVwb+oR+UQAudlzxmRKpWj6HZsoYovGnoJ6GswY28q/Ji75h1Iu+62Sa1tI6NUd2j8qGnM5Ti6fyhLnIi9ZUhmnu2D5JdejGmSaXEG2NXYp62x81Xt0glRjyRfRieixQawRvbHKxC70SzMaKrxstGyZUY8VJ1RE0SmIULzjuLOYRGLjYfrUmBtEf5drTcQhZY3qIEAWvrgEshwwdHiKhF67LZyoZaj61zTiaMpemW/OuSLf8UVrA4ohn26bzp8s7VMv7w+7kzsLfQ+30ttQXT44yCBCvKXTqM8v4VnVvKzrV/gLF+bjhMGdoAV+Bp0OmYDXxWHxDQPQLr4IQqwgtRmBfE0S9EJ12YD49mIXmCqKsRuXezEO2AeapULY+IbChFMw85ybEMHcZaOe6CDsn+dcXA+I0scd2IusUjl0XfEsxbwA5ysOiYvYpqv4HUKvEounIrQqKN0jOdQj+nHQF6tVSIq+bXFdjyZDG+bPPoS5nfH4qboruVbF0tcYsjosTF5F4YjRJYEEGLll4eRV2GImpZzfHlGuwlmSfdPAFb0Mrn5xotqe2NToBCTwWeIFus21mnQe+Bly+MEMsF17J8cg3U0mUCkzSIxo9/yac63XFyr+1aL5mxaaePpMcaQKo/B6lXUbzcQEv6kcxPByNRNnvaRNh38eUtiaXrOXVoup9PJypMnePp46z3l9a6L0lovNLTyis8kOKxGkuz5A7RpGCduUi6QLcTT3u/quVd6guXRqrozery4IN1BOceZZz7wvs3XNpRnrI6v6F3Y6iV8yUmcKx4cxQnRi5HOwLQmolvFAyNvJD5dVcNwWquHuxIKOZ5scNLRQVZtmwlg9RUp9PjK1GJC3eOJa/VtxUbUME3VKAQSnFnYhsMm2snqzofMQDTjuVAagPHbIjY0iK9GbwhwOZLps4p1eGiPTIy7HBrsL5tyvVkXGy/JiaGG16Q+eLqNCUBwK9HisRqcimqgDxTRwqN+ufBU00Xwv+y2hNzfUm/aeLF8CWXGUPANsANQzFNRPA0z63UXItq3k2vMG9LAZq1l0Q/qRlEQnEl9pgediDwgDjugOPKm2oxHJgoD0bSMV0JW1QPyXp/WHwocW9WNJ8t22HvyFlY088TA/yxGbT8dR4sEdmo8srEOi6FEMG1qLYQMfH/ijd/gPjld4JP1hCZFzsQWDeKoWbhQW5GGpLNDYGJDj0iotpgP4tZACbPlT6QkJM9KSVi4TqnlE0u3kH4Ua7AWwVZqRPqowjH1i5aD9QaBdfM3G+90/2XJ34is6ookRrG9BWy245C5pPNAIFervpsrL7AnOGZLtsQfhv4fnpbDuNGkXEK0TFnJhleJbs/OHuxhBwlfHkU0QOrx6du1g03wmTv4bFQ/8UXq8RxSwUahKdsNgseVUZFoq+RCJAC0TZChTn4nprMMvoMZbkJY8Fy68WAHtJYOQSkHNAfKcLAjCNL1VgyoKUfWMr1ECzfSUv15q5csTHMnSR3MLCwt19yqpu3VakLxsezUW55AWTsZBlYzEakSC8jR85QC5xjdupkNB/DWcASxlX5sWRG2BJd8l6fJeDBE1vT/NoIHKf9xG6Ji/v8RG6Ogp4p/MywoddUNoF2byB+SxKtX1p6VNQ2bM8zBDX7Hac+1r+3ZW6mA3UeDrB4PIge/JrMzyyulhkgjQdTRW+1VKhmEKaTlST9Jr3hKqYBdqCxSsWpeFtWPTQtClciqRkg/jEDDKrTZQLcGrdLI2EJM5FVRbJYYMqyH3CSEFXl0YmNGTYKKMnuisbbG61yFVPTZPIXnwAWE8pEf5HNg/mAjx1Zft/T+hQpYmMJ2+4rFKl+q0EL5kkJXLpK24Huip2NrJ4yDiErhRi8pknHBMx/NxrafLkc++DQjTfCqbeGEQBd1nqVcdWhNwuXk5lmXptO0guBoQAuGP1M/nDf8lgLgUf74BERIaJlom3WeXvDu1Qxchme8F9WdGC9GHU4v0tt91vWBy0s2D9cn4XqPXntARyUNaH0rTKWf9AiuV78L0h3osvqhrdsF9Tl+qHXyr5RYArlGzlPdO//BbJ4OX8eb/KeodTKF+w6IDkog/W0Hqbp1xgWBVz6oaLOmZPOfo91YWPhPUmz8Uyc6zdyaC00mJHrZYdwgRGULzkk6P73Ns9iesZAdde81n+TJFX6fU/rxrJQCVXPM1kLZizQ/Eeq5OGZL6X+gYbEqqn65nEtR1GisBkWtu3/f/cCFDHbQ7id/m0H2Se0/wPdBzr9zJfQsG9wKbxAufUz7E8h+EJF7WbT3Q7RHcaUoAPjDSGqnmOMPh4d7chDWpdEw63/x+aEAbo/yP5gjihi0dBjCZka2F14u05eKUJk0BreGIH89hgoUCC4ApM4kN7k9Dun95mH0ZJxN22e3Y9dN3O8lI/qp4VGil2oOrxLTt8UCEXRSMhQm0cjaZEayX6+1atWtLnJ0i1QZykQlkkegkYqhL8rQ/6Gx+l3V3jNXBIkC1yCepO1fi8xcBAFETKctNg8beY0MMncOhUkw/ps8fbRcw+MKqK/Ihm/WiDo4YCXiUmd4pbmY3tr5tPZxa+N0bf/90fbmzuHqd348b42vYCKRYjSA3GSczS4u+bhW4Y1n0oeUFnE0SqaX2SBCoTQew5ej/Y+N1cBJQxxIjNG/+Xajn2YZvNG5lWMfxV+SCFIXMmpOYLBRWrB/thaTMYa1Co+dpur0Z8CYMz0kpK+qn6fT5EM8m9eRk83ryMnbGU76Vpm7U8dRpTk1vV5ztKNA5VVPDxWrHuIO9qrvZDgAbquG5YB1BUZhnEhlayro+DUnExXWVCjNfJl4UfeEPga7OjIyrHXtDA2qsVmV+uSohaV52igVWEtMi+jN+ZVxBklwfljylThv5fWVFJE5CUTlZwXnp0RpqEpjgcfZjPRLcHeISMqsmjMUB8MqzTig9/s2PqR4xC0DMMPLuNi/XutjpptWBVEd7awdHX7Y3d/682aQoDgoNqZxmgxWongwglTTecI+TNnRWSB/SfNa7GIAoeKSgYg1LSV++VmKWI6uwkPN8UJOnQsCR1r2M4S+VhsTMTUhERMJda4Eu16FZCfw0PMw393Tzf393X1fPY6wxE0nrhGinljJyPV3xCdKCBeYwJbIr4ZjoYisJPLzkXNUspr/O2MSDTiMXybjJsH3AkW+Tnvib83RIzpZNV5nqhTORqn3ISevSrptVjh9c4k/LfaTeLA7Ht4G/L7nk8L8MpjUgtVb3DtbdK+UUf6zzj+mS9RhMl6syjhX8vE19XJly6ZzDldcFlpqGdi3AmqZ8MugJFLXX8ewE0ALwgQeWRfVQe7qNA1wV6Me++TdTeoWWtdn/zJZ27Bn297AHl9gneiJev2S05YDMWo7TsJBF+EKuzp2a5vUgVTtIK8PqBzxqSq9CIWiRvDdAkCC44QjF9K9nSYQHxGvf1aixe6CSNO3Av/KP9LBCu9nQR1o8Em6QoLtaUUh767E9uEwQrk/6m8Lw5hWa2cZ1F7ikmFvcZ8e44dgr5yWpAlLdIIqWKrMiJFakZ4NmaqSoQ0s7k8jUGWE6nuW9OMZG8aYS7+MPbFPCQzzIi0YCmpJJ7MJE0H0wWXlL3QSpAOXW+BMjaCRA7kPz7BbBlgGraY4Rmha1Ng7N11oSjwnnDbo0QK/kptpHnNRbFRIK4BtgoPqTJz7SnoVUOpgWndIV7Zqd9meqTU7M8I6sja+HS8YJR+ThK1ZDzUvxiK+tZYxpDURcY1KQMMUJm7pXHk3bWEDJEYbc42M2SIAT/htWRZGA4oJt+Zs3Ov66jPcv0PMvr01+R7RFckO8RvCjCQrCtvWFD4LLGoGf7JaZic0kY4xD/JsgqYxUwYWwil2a94r2CusX9fpgqjBrXT0/AXrL19/Zcp7Io5CcwbCdoigVkPUIyx7ygRvTAyPN96ddPTvOHRUsmXsDXNLdovw3Bjevp2dn8sFgce1puTDjx1RjZ4lmHiNj00LQj+yjWJHCHF3n7HZqvaznUVYk9D/HuzutPEtbFOxOfnSXA1ZP+jWuYPzXI/vrpJWXM4U0FSNiuJcFcvKDrF0mAzQ/384QFEJBx4xOCLeNSg2Sl8n9ATijVdoVZrQl+RWJDhm9Vsuqj6zCifcKsQq4F9OMlnfGonmgXi6YqH0EUY1/cBFEj2jSndB8CLK3AQ1toD/VnZ6mWfXVtMFk6kZb2qM2Xt2isbCuyzvC2FmXyQ9LHtbXVu/Bt3anEmJ1G4+6Qkr2F+hTIc0XUPXtuyBdrZZxxBpqtg+HVuA3wghT7QwQq3LTLXOCaHZoIzQo/TvjXBKUFm7RD7xUptoJxNjt08h9s+mojZR3ArlJjP2ixrhHDdE820Xm949QoE1Pp1x1nO8N4okhwUqGiefG6Rq42T1OzsLDFcI3uXZ6Hiv6UtkS3n2ILS4lWkmDyTRgNIhsaXl44FTJpGjLjet8u1CJFw2P/PIumbf78v79oZL83aIyXEglVHHmdwOT/ksclJq4CIV9HYhSsxpjY1W21yMNBs4Uwn15J2G3YEJbW0wOIJzYDZMNJxz4KkWsAYS5Eq0k0Gclwk4fiYDOAaBRg/6eTqZNmqsd8kyyzCX+oCan2JqrHoz3F8VlQRR58UYAVyC5QoyClKPF1u1SbCCpMpxFCQ/Zy4GY2z26V/bhbEPfJwUIqObTZxhmx346N8H2AHDeNanJC8wu5QHBvA7qxY1+pYCaHTb3U77aa/7omPtj61xiifJCA8ptr1GxYXN8qZJfypEYKhmvZkobotpMjpNxldgvj442NgzNS4EHQnj1Mbm4eb6IeShANcUS2cgC3zIcx9+YCceZLi9SvLbZqtEN6yZZPhdniQwW9mrEoV03mftxGJKP3XcXOreIlkpOmR9j2nA1IKiwDWRqejQ9r5gLgTNP6XDIeLDRJP67PiYF8Vgsh2P2cGce1PN0ArtWyCGg2k20UvnVDK0wrt7y6d0CPKWR+dGNo0DajftJ/D+JNvgm7OwscAoLz4bJps3/WQC+lnRNDZGor6LigMShFZD2RzPDcS40OFQPmYXR+NLjJo6EEu/n/zK80JbIOl+zLIvqpmq32RCaVzAy4sJh2Rc5poZqVXrSDWP4ulKJEm2oYAsMPWVw12Br/ynxLvBqVAH3lcWZNBMQPshvgbcmTWbZpHyztMqzqxwMq9MTIdO7leAj1May+w/5PNlVtCYxNnIajZDDUZ+QR2MExUkHh8k/3sABpDrdDzIrvWv9ji+Si/iKaNbz7c2DHjtIhlPofRJM92LB/9M9y6zccL+yQatJxftKai/4YbkKlChRTo32mYvgUp9iWk5Q1aC4qawmfJX1MBkcFhyN+H0ZrhUtoy7Nh/IpzVA2v6XgRkUdabwokZ/ITdOQpG1+jJjsbm1wFoVs3oN5Zu5ABZJSsMFqU4cX4iJAAMQ0WOU07Q5EvtCkQcvGmnfOLTrwZewCyrAffyaep2G5t1Bvxxj8rwaIlBPL55NLwNT/B86RVnvjeOxASW+7kUL4wIVeATvDUp1VysNAy2ymm3PFFwH2+pp8spE2RaciFSTAB8beTEAIQybCPVxxAaBaeoKqMYmH7xKJaMIwvofJ0FDaKEkYh8bsbKiEN2t2HRnRP0CzqpbeW2XZhUftUSSb5fRr+Z1HCAjyr54ptWwHxHgjuX8yHC6FXwe2ZRsvAJnxZMS5PM2gluGWvkmLlYIh6tWGyaKXtxg9c1GHpPjP3D8C7iynNgWEMYCNga3glGcsuOW/bsAfdyZwa/4ActEaK0cCbOcGcP/mglM5KJVWO6wb71GS4qvo/97oNayZp0NGqL/mtgOiXxykUx/Ts4OmJCcTNk4xWMqOUgvDZXB+sBWJgjGDGsv52yGSoLGxGVUCaK/ckH0V0bxYNzkUv/b2+PBjZJGf7Wtpcqv3mrx+Vdf2El1eU/VCvuOkNfIk1F2FQ/ly0T3GnCed5HhN5FaWhe6i+yw4AH8/pFAPskVCH8t4SyIru+85kxbldGX1DRMlQcL99FxpPpA9AbJx2CBSbhjb4RBbCDDCYbiNe7rHQa7xtaexWZCk3ZjnEwbnld2ZbqzR//+52tbi3Zu02poz65/jmO1Rg0arhcOjvb2dvcPNzeYaCIsLtFAwgS/drzUkk4kTH2OozMGgC0dowoXSivkC6cQNSvOGqXXN96hHRXc2f5Tmk9n8ZBNPGKKSrf3vN1h/+2Cd0vM/W2PDt4Ka21RNsI7qhEAG6EXDx4FZpZTNzmTSYm7CkEmhCcJ9V+4Abqe7eQS5cTBiW3kkGN2+y49CYiiw1veA/ljbYqFrvFM6GfDFbzQNE6KSoyXI4F7N6jjSkT7PuX7Tro+6Ny21G/RvOvhUFDtkgeGa6NeIMANh66KmyDM6mWwAhEch31p84FqwPDBltfKrpHMlvYF0l3JRevcLld1L41qzNfrOHJ37ztas9h3wodNgHt5kpcz7j/irtfiwX84AxE7W8TsWef2P/lYv2tEZarJZSxe0VHkwt8CAOnjDqRGNLElqm6M51k1J3ZlqEnwzWXdK1Ii14BETUJg9LMR63Gbv8NAqY+JAfsJ02/HRXL/beRVqRr/kuepq3BI9DiKB7hrliLsIbYOuN9Ecgh4OyOFsvgqToexkMoATsQGnebZeMTE9nqizz1PzflPTAGYR/J5x8Y9y5OmPkD8ATWsg/Hf5FCsj4zf5/gkzEGp7opDXKvVFza4ayO4DHwqptKAxQohRQdaFB6rL2jAilZso/wcXERCg54ea9PQH4apOGj1cJbr4v8xj3/85zCF32erK0L83ywd496GSG3kiSpE48+KxLZEaamm7CWK+XTN97CCX+R2TtrXyVkx10DMeRyNLYH/awX9umzD2JSWuUuaGs0QZLBDPNfWnmfTg4vQe3ifLIjGcGxiBlubS5zkQ+RgPKP0B9w7FPsd9axRMeU7/XdTuRwKJPqCTnDCziXj9cWKz/X76xQvH6wH17xcNl1bVepR8GKxvqP8qtzcUoT4vksCNFiiqOwSV+gt35HFqZt6cMSTZm42j3xpAb05yth8DT4/B5f/bbk7cFdlHZackzwUExZ9RmyHmdyC4k/NUL0s34EKtxsGHMIVjUsBy4vHAVR3VO7jD8esrjxclGcOiDqw/bR5W4mOTOJJgqbrpmOm/z46Pi1xdBP2bh86SKGLZAdHzsHmRQK9gyGNXTsYxai1tctZvOe2wbsNiTuN14/M5xzmEZDhmkRUQNybYaFc+P6LDuWHT93bKzzZ4nzaVDTIUMQjZQwH+FzBCIgRpmF3i1mAnFAW5ulfOkTZW3M+XsDTcW/ChV7hX7pqv/phkkwYdydxfYOsmB2UcmXfQwDo/heRBIXpawTCqu2t6Blmy0iQ5QP5CrrzOwqO0n6e4cAt9+Ha/Vbi19+HiVTYa8KfrinfgskgCaC2gN8dzWo4lf7Rqs6S42d3oGtJLgbi16k6fOP8wvR9PtWA9Uh12+BqmRArTYwV3bC1AoDm+FSIGwgDwytEiwjdGhENmwTVDQcV2YmRyJUM2khzzFt3O/bNMCdzLJf2X+/On2eWFRues3pbzinrnQ/yZSdQ52vGqEdJxiuW1qIOg8Y32OjbYybRGJ6g65dJ/wtNCTW2Qv7ySMT0oa4TCoXLv9AuqFpKSNrfrfsyXFt8efLXz2uLf44X/95ZfHn6l8WTH/70hLtpquRzmvmVzsP24fdX9lvZ+IKv5XlKPD6asfm3uY2tQhB5zS9lPVmByfvGn9aTITbq/uUF6cesXdbNvunC0gy4tHj9XTBai/ElaKB05UffgexKJ2VeGbVta4YkKcxqxpOl+c1qJRI2uhk5n90I3UHPEBeBDEh6xk9ifgDmwB3kJ66P9J065tphuSgpPlvNT/BpjQ1ADuYj08Rj3yB4+oA8vsZw5zwoBoLhQ0LTEPy5F+fxqCAf9kUT41tyzr8ZLnET4iN+w3eQBcII3xcPfjUqSZgQ+3Mxulk1PJI6xPeIjpwdN8e764e7p+trH7fenkKk59Pdd/SSZAKOkTp9udH4/7CzyjdVwfJ8M5Zvbv1udthZsBGlSiF7mcvCeKwHaekJqIKPH8OLDtaD6TB3A9HjbqjLLsMrfGP/yK+BxdAPkYNLkZKlELFHzAG/YsDZ4G7YyG96xqskDhLG8jhqwl+L+Fcr+sEBsohtn0TNG/6zJCyR1fKxnKY8G2+3N542wVXPCM8/vZF2l1NWvj69kUIPK2nHgwE7Z2MdF0FmMEcwVsJUVp+hqD8bspPZPJXTcTotLuNrnrKBb7DsXPyYxAP+4waqLTB5jtU0EhGnmt4BcYskIfoXTf8ysTv2YVAVz4Eo3/4AqTxbhh+2g2UqEkSwoTHsyW4FnnRH0s2PURxd1b7qmx1bOUTRW5uStIlGHmKcNVj1O7amrgq/j7q9Fy2njuwcwnHRoN28f9GY+jdarnm0PQa6rIYRkZHLdstuOzbckKMA7/RLZD/P+/XxY90E1/3zrycU0REu8FLPvrb4Ei2+jlR3quU/GfuPXr2Kvtj2VD/Gacnr1xzf5mqMIf2xJomnT82l4B13n8KYX7DNO/YgwF4Au03z2TKDzHEaMgip3WFNAJnc4FosGq/Bpt99Fv1TfzEyQhG/4+4zy8eYIPKvrwFuOKVmyk5zvqE9+zVeiM7YQb4QsX0NJs8FuR4QCEefc2f4l4xMi7vnc0+maMW/lsRfmFj68/IJ2c1AFjCBL2wiL9iEvtCJwEHDp8LoJFpi0yF/vjD/7C5bfz87McnqCywURyvD6jR68+ZNtNR1XhdyRoTj6fnG04wBxFMGIkYQveeg7QKXVt08jrpPuy+edjq95ZdwMJwxHtBnDf4/+KED8gE21O4ERPXlH4DDM+hmqcOanfF+ZCGgW4UPinFO30fLvZfLL58977186p1QT8xo+f4zevH05fPnT5deLvEZ/ZUN8q+/z2SWxWSe3XsyveVO5yWbT+cFXR5cHfZv//dapWedkn1Qa2JLSy+fLj97+fxF7/daJT6YzongECC8eOoK3nkiOAfEyg7W6p0IjsJq9YO1lk4Ep4EnM8FayyeCAyHq7FpKvjr4sNZ1BCwGYMZaf+4+X+o9fbHcfbm0wEixt9RbWlruPl+Iek+f9ZZeLHU7Pfb7Oau19OL5iwV25r14usR2To+qBelCBAeRI/JAn4bEAwU4dCHbHbHTYKnHtP74tvlCRj0aZO5VspLUACT2Bkkf2Hg6ktGvOk3UWcBmatey008/dXIOQiuQpSXLTp2gUnj2vgaZTegVQj8YM8Eayhajl95sIDDpF3zOvU4gHTZwOGNAOZfsX4txcYI+4f8sw/EBR3bKaGCpxf6n9/RpnUDJ69loMpsmewc/NYsCgrHByyuLSLqI+wejlPEYLzs+n7BFZF3L35IaTxYEoj7TRnhRM8nYmn8RC0l2QRkpufTD35Z18P+6fKCUMrzUw1FgVrQP16ecx0kJDqbJj2jJzh5kxL2lZ8vL32TEuBi+EfMnkp06MJA0vxBB+R6z5XQIi+Psbb5HOM3A9oBf7HTpvuytRh7vE4UPXAybAfBJorTb6y4/X37BMPvC4A54hPFpdp9aJ5ghhHVsxuAXpXudEh6F6LfHiPjsoNQrzyGjqEuKumZRjxT1zKIlUrRkFi2TomXtUsOGphUirgwC7tl5w8SOlqM9OUQC1gb+ipZpTDYiOWtjxY8fK/b2RTE2wsoqKjPlon7lFzXrWrXuDCWMkyIIcC+fmTMq3yaBzUJop2zLhA5GtXF6nkMx/HTwMrkhYSDsgTvrBdXZmddsdMD5dGc2OksgGGXBZtJqT7ODaZ6OL5rdZ62WTjPhOYkYGH4S3a1+B6Zg8VazLd2QECm0AEzFWztbh1trHyHVhLC20Bp2Uhuo0nOBKHszlC+Z5U6gaVZl2azyaXP/YGt353R762B77XD9A1R56oXy9ujgGEqfmaWHW9ubu0c4uufWBISfFBS9sAd+ur27v3m6sXa4BsUvzeLNXz6sHR2IOXUtzG3sHr39uHm6BojFcgtvNIMHlltI2z9cR4zsb65t4IS6FtbebX20cNa1kHZw8FFPjfHS767iHG8ApIVP1wX73HdPnkBSjif5IBsPb5+sTdInt1l/mp3Gk/T0cjoatn8tOIgDvL7YHF99YF9B/Md8dwxMMh4UpBjJFxK7TvMZA5SrO7tiNmH022634/xiBlcThXEwyUgor+mtGRaJ2xI7hE0gDM2leWMgwp/EgwHetMMtZ8KOqGYjG89k41w2bixETXyAbNxtirgxRnQcBAYXx/Cv3Pmi66a3ctsKj2OVyqA59pW7/Zgd4iDessXRL9Hda/9j3YKtlb8VgS8fuNcCjZXrQPU6nDst0Onc7EbWoRdhbfsiTEG/n6e5CsdKUFAxzqpnN/eYxP095e3xU+cl2fW9RuS7X5xrMBDo9zyFsIHsf0pcUlxXFGvHse0y4IG8WKt3DNg+fmiSZzvwdzsbo6siyVDEtvDUjPAOHcDX9jQGL2nu3KgtrQ5EmEQpQBx601IwSQcilnqwC/hnrcBmEFga7h8BXfbmZ5xrrBBKXMzvg094xyIjSHOk/rL98YP+qBFLarazSTJuQmzyBm4Fw3nVqslIJk8HyXY64glLG3DGPJkM43S8Crf4eZFMX98sQtiRxUFyno6TQcMPaQzoYedJPE347T/YsCx3E/SEJ42wyQE0QTHRvS6hlQH0DHPA9joq+LhbuNSx4IQg2bUUzQGa0R2wyTc7J1UQ5zxADKHTe23jh3yEseB4ro3RBJ3vsTMd6FqGWGDk9GPD6ee7ij4luSPHoBeAJv45Hzwkl4I2/Dt7NxhIYHJEUwWqknvgjgswp3DkaBFDiDKGSAL0q0fIWKIsbJqNW0IkIgeZK828Bxkh7UOZLc54T0gu27hnoZBgGBc9ux2T3adiE5LiXbbVdIzHYBXhXLV79qtbK2X9/m+BSe6tErY9hjQqnQA67ifej+htJdUladuEFfrlw37zhiFNL9xCJJO8zfKUZnjTO5L7/whPiwW+CSzHDkzlxZMC0zB55qxkOBv5QczK+YxT8MRF4dUfvfZCkc/wOFKcShZMC60egKtmTYlrD1RfTWMB6N7hlsIsZwcAmDDZ/5rhyBiXPdrf4iVtzCDdfNIUPmcnj1f+8uQvT1rNz3/9y5P/OXn8P60f8efJ41bzL0/aP7SeWEHLODAzwhX0Kku4/V39tWT8tUwe+ZARe8rp3CBFxltOCLrXxs3iLTy+bKwYrEkQHvnCulhRnYX5jqII9aIGopxJClChAYiBVrkAyHVEj5nzYcY4Av7MGT1noya4bygb13NTTWd/fMyuwQWqcMLGY76w5uPHFgXUBwB2SP4K1p2YDA5GSNb4RCdsQ+0JqCLPqGwncWxWX+uqt2MoasosGpfJDQTmt0rQF0WMu1U6ubXeXHDxDkYMvRxwkV6M2dmbw4qywRtY4SstP7EFkj/7ugSIEr+t9ew0APw4nH/cakjhkcs98lnti5PPDVhp8J5snPhooKIxnxI27Vs8yVtfV9eoqmrSx/rjfkW9v2UTrNjADxWVJZqxhfzDlzVbHkv2fmarQXaNuUqwRLJdexBPY+8SQCl2bxglmcAOi7GizsP2OfxNedXZs2XIjYbhzs6mWdzkY9GWyzsnHzfni5irpkCukJ7fNuVQjLiUf+NXCXAI0IQ6lAH+zQnyKdk7tFLB9/5G4yjKkZgigNAS9nYPuJqQcjUB4o6S2KNOKyakiZ8fuGrXWOf4WAT9AZrW1yAswbV0yYfZmZAg37Kfzc/GGp8sRP+Ysu5XGAFOIFQbeok+yfrTZLrIVijObxs0Ep1YE1RSs3yEnnJWMTwNAOHWIgUcSC3MGgKWB7O8rd3yK/QxG5RPIQuIdwEAUkensp+3KqoBZ5Kc9fVp+KWn/VhQP/NkG2SuV/KNrSe7fISNwBt5VDBCD3YfGbKd2fMj9RK1nsYu/Lou8wpdndxOKPH8ksnYQmU3z4EcYzLCAHkmMpkCyX3KAUNmcMq1al1NqMyvUZ92lWFbNyHJtngnRHVcddRdrnwadgdXcdUVaRQFRwH1zTXUkD5JcR966tn848534JhyPn+Ux69wbH70ZczUcnjfbZ5CGKdg1bzos8LXq5b+6PUksMAB9g89qDYQy54EEF21zSW6EdhH1F/on2OrMaHphfedb/eBtq2kLy9sIF+wSsZDJExfwlA/aZDNa11dVVgqrBs8eLUEQ/2RIfw1kRSn6Tn7ooX1lqXCYo09JwA0goPw19/HZ4UFj9V24PnecJ2ep3kxXXPe59hpnTWHcswN1oW+Y2sA8V+y3ehHSqSep3uy3oqRly9s56jPEWEGCn7LfXoWsJGQp43u5tfb/x/qxTuPyyBvD4W9Yru4YCKBRAjb+Ghi66vwBoZQoFO/eOJZCEakZ+INa6sndJjfwpw8NlBxSBgHaOV5ETBJmVC8198h+0/JWSND0IMvH6P18IFTfX6bm7lsu+OpZEoV5BxjO3DJhSot5AfiJHPEEv5dJseq3x0cm9LCfOAzOx+UmZupyflAHbLLnS4YK8yPPX/rEgKnt9EGlR+NQb/K8vTvyUBEuHXIO7wY7oJYAhIjJSHNrV0wYfQjQ1PebM05eCmEGQPX8tvXDTdgejdiAbAjcW0wSAb+cVPO7zAlf5Mo6g+TOJe8Ktx61du4npm4aplkthcwQoBpXMRvSQbN4LPf6sWSr7WNtQoske+rn5pK99xS9bLgkY1vPlqB2dSlbREzCMFFzrC0cGu459rDEgDe8AXoz/KcSQD+WZADGKVoEUOAR3Mr658r9bSDBTHw1sOgHVldmHV6XjIFyNd3EeJpIGZhO3YZddwQqzUYQPiGLHx6zcneHoq1GaOjwsRqiTTR9L63V7bLU37dZUY2clZHC7m2gG8I9hqeFZzoru4VmPapNgDJGCvaSiCuPJXFZJBc8SAo6lZq2p+ACeNrbtIneXKe3jhWVpp7ZLHbWr3X3bsjbF36btrECB575vdV9+SOFOTeUq9a1UUALO4bRLI2O+nhLTFmDiHo1s6YXU8aEuHWTKc7scU80cvc3kTabRT0N0su7lErFYm2rZVZrbpbt/I/u4boyrt2vwKr2Qv04PNNdUlljuW89SUxb9tJzD3IBDbGcVmFMO/47xwXGb7vqZ5FQwUABvvZaJSNNxxNzBLR9s204j41qR2fZbmR9k85KDgud65PAXXjw05gcNfyIzJlT8I6EaVSrImCoaqKSEW8VpsbqMWaNGLwLzpD/yJ6w68CX7I64je95ofU3niZyd+4Q1wQi1sKn8p+fjuZZm1ffeW8EfQvFT4pyr1UpgFx0PZO5rH3O2KAj5bPCwO/rxoBP+JBOk4wkZbsrQ2Otls7TDQ9FXYh2mIU95mEn1tNttfW1zY29gNt0omnydZeSYtidsZwsR0XX2iTg6O3O5uH22sHP/na5PI5j57I7tHh5r6vLohITDzc2Dmg9deP9vc3dw7ZV/8smNx/nl6Yk1jf3Xm39d5Xf5KnI0Z3Vh97+1vba/vHgT6KhC3mwG11sMn62Qi3GzM2j56XtNHO4d7B5v4nPwbghmOP0RSrOaCNjliTvbWDg5939zd87eLBKB37Gq5tbG/tlLUEZr3HU46pRsBN4bzx1ReJfCEzOW2ysflu7ejj4d7a+01vK+Goid5ftNnWwfouw8Ua+KJ72l1fX/8MjiGD7GJDxL9SbX9m/wFf+43d9xubH9eOvRQljIxHmLlMk9Tax49v19Z/Otr/WNZqmzsSeBpub7JjeqOs7ea4n0E0VF/rzZ31XbaX35e1X9fBfX0g1vc3N9im2Fr7eFAGBZIbMxAO7iQY8XaiEn8H/ctE5tSyYRysf9jcOPKvn8JkOg6OgRFoZf/b8U24/dovwfaTLFnnTMXY7bubgqn42lzB2SCt05rXW15qmh1v7P68o7U6q3Dzl62DQ2AaXW/xx62dn/B9Rc9fvLZzuvsThJTwFrMNwIuXvcVibiQECVZwTwUlFIkLh4PDfUadpIlzKlS2cA+FyibmuVBZ3T0WakzDPBcqG7jHQvXEPWdCZSPnTKhs4TsQKht5D4PKVvZpYDc42pJXUyI1m3MSVHZhHAPvGE/btDaUUeFw/2jT2lG+c8Sm+9B5UTEfz1lRTZvmMQHeJtaErBrvNw+tGdkg8G1YL1whMGnnyHm3u78dGIuqA5fegeEYdU7X9vfXjgPjUjXXDz5ZHMypwuN+8Zdfy5W97hzBDJ6W1dvc3t1Z3z7Ap7ol1db+fLQPpPS8rNLWzruPR79svI1UCB9/ve3/ewhr9LLWRE//988cx6ULsbd/+B4qdeuM7/RTD8MaldctpRKPVFGb1n2iRM2tZUsQ9feXJTrU7M+WGCqaueJCRYNT1At3MHSnyhrZcDLAr02neZP7VzGZQ2mG1ylG7KYRNCF2K+SaV4phY8UKt0pVRgbMyYrZXTUAaX3RgWSokjVAKTXSgUQVzBqAtHbpQDIUzxqguNLpIknqojVAaF3UAWOoqbUwxFVUD4KU7loDjNZcHUCGUlsH1UShdZFtars1wCk914FFNeAagKj668CydOMa4Ayt2IFn68w1AEpl2YFFtOgaYIgO7UAy9es6wIhq7UIz9e4a4GyN2wHpUcnrbCetiLv7yVDS5wDG9fMgPKW+zwFSqu1BoESvnwMs0eaDkE2Nfw7gVMkPQrcsAXOAl7p/EDQxDsyzeMIkEF4+bTOYB6ywFITBalNCHaarDAgu06W2hRJQRoQLtPu2QyKAeVNwkUz1ud6klnYRsYmmHenHbBU2byYpjxUMgSCDzm+mvy+5NoUHvPSph2BG6wD7UzxMB+n0tqUenPE6nqye0omxwnRtR4XVXqVq1uW5bwBBWlyZF0NuTpJvj4mQRT6MCj2/alwogeuPTCyBG4gwhtSsqxGk5cg/MoZCFy5hFOl5V+OIC8l/aHbjuWAq4TU432q8aKn/j4yb0GVaGD963nUYEFdo/tj8x3d5WMZ++JzLsVNQ7IyTa6LwCxxNT5UMIf9ifQinetHC6MPIg5RMUZTQuuaCguKRKrS++EdeqdClbXit9LyrV4vg6BuuF1HqS1eMKuV/6LMreGVecnqRuVevm4Gpb7hyhg2ldO2UEeSPvHABt4XwqqlZVy+ZRtA3XC9tpCpdLGpl+iOvV9hjJLxkdO7Vq2ZgqmrhhNs4+1vnoEIT+oe1gw+nb4/enR5s/XmzMsuQ8yZuIWooE940y6JhNr6IeBQE7G3B/5TOCj55b6IyDJaldGVYG//IhFXiURSmLGP21aRlIus/lLZM63UpcUnz8x+ZrvxOZ2GSknOupiaFnW94uqibgdJ1Isb9P/JSBZ39wqtFZl69YBRN33DN6DVM+bKRW5Q/9LoFvS1LFo7MvcbKUUx9y6Wjl16la2dfV/2R16/c4zW8hjYOqtfRwdo3XEvnxrF0Pcll4R/aDhfyQC4xxOmZVy8gRdM3XDt6rVtr2fid7L/DyvlcwKsXj8+//voJfP0GSygu02utorwE/3dYR78zfvVKShzUX0uFtd9gNZUfQ631JK4H/w5LGnwcUb2qBBP1F5ai7zdYW+pMElxeWRnybI+bMuIiT+UECmWtEcpmKp7kxKfCf/1gKS1SR5V/B2IMP7GppkaKi/rkaGDwN6BHw/+o1hpLj6F/h/X1P3+qXluJg/rrqrD2G6ypcvqqJ9UJV61/C7nO+xythmQncDCHbCex9ltId9Lbrt56Ch+5f4v19D4PrLGeAgdzrKfE2m+xntLNsfyeX7ko/qHv+QPPNUvu+dW8Q6sH4TDSfvQuHQ9EN036PB+wlJ39yltnGJhKve5vn0Krd3k2wok11QMP4yW/COuLCcghIIWaH4eGUStkz3CNYDSOaG9rg8Fh5u0Kg6n48qiJofsnujWWSbVu+9MbMyzBHPO2wXw9GshwHhwNMuYOD8L5iT7xbco9RZFgXC7JCkC65iw48ZNRHk0G8TQx4EMeLxHwikSGtUKszAmIBoC9q367LCcQnhJEtyE7OS12x8N0nNDNzhmWvM+7SvJpWiQDHCGN1f2oiRUhOYYRSYqys3R8lX0xJ9fU/M/e17iWHXMlQyBmiRNk2Y8UZymn+W1gtL72Yh14j2rYDNH4dsvNvqGj5Ayzi2Zj86afTJDRpuPIgL/CiDqxEWHSCvchL8HAaiX6mGK38WF9DwIJcxEefWiRrrj4pxxGPyZj/XkffSWtECsEVYaXWwN6QK3R7AWUySfwWZx9PCcFO1oGTW/3rZZqYY3DO6d4Ns2a8w3RBXSAXHNrr6mcixeiwsRJPhcuDg7XDrfWERv6WVwYEUUAAblv4hNofJkVRh5vEa+fk4L4w4yRdipTdjUbAKE9vZn+CFAwuC+CMw7PQNYBAdoOgZ6nFxeQDULQZTmaLGMnKfWZjlseX70kT7NB2l+3NaWUDS7Hq/rs/JzVrDcO1byRYHI5XDUBCZbisX/RRBd6gGN2Okp+YclfEC/KjaAlCuQp0LReky7IMMrm+SpakSBXj8T7VClcmY4POpIFjwZ5Mz29vE4H7nAY9ndY6Yc4H1zHebI1cAck+xZZ5KhDhgIrOG1oELa45xVV9MgW9IhbjpCTF16E0zmqxFtsdtiATE8JFg89kWatMZsiVWgCUPabT8CW9uz5QMJe97mPDo3iKaShUTzFNDSKr5iERvEU09Ao4XdIMl9w+HlO6Cl6+LlKZYv6oVECLxoqq9cPjRL0eq9sUD80Sqnvb2Wj2qFRSj0fKxvNFRol6LPkjwtQ5jdT2UUoNIq/gg6NUur0YdP9fKFRyi6xq2kzFBolVEOFRgmCkKFRKq5o7UmXhEYJ19GhUcrr0NAo4ZoqNEq4ihUapaJXFRolXM8IjRKuRkKjlF2Z0tAo4Xo6NEqNidLQKOHqJDRK9fh0aJTK698QlcwRGqXWFVDNrVU3NEqlGbtmf/VCo5SY5vwNrNiaGBszHk8LGVNTfVBBNf+hRaQLyIQ1S4eDT0legFhsSfGNbrvbaT/tdV90GpZ0BU0HyVXaTw76eZKMf04H00u7fYFF7Wsoi36QIUN5s730Jhnug020AvKHJL24nAZAX2LhXLDTYu8yGye7+SH4uDmANQZ59xuMQbyJXj4DOw6qJKP4pqkrOThYiPyFfBqt6Im3h1civJA11n48gSyAB+nfk71smPZvw6M9VTZhq4kFtvCCNQw8NYDyh/mzxLd2DKvrrM6Xt6DGFUcTId9uJ+NZ5fA3Shp7JlLaV/mcynoqmR1b/b2MqazFXpK/z+PJJaRESqqXZdvbzjOlQAeOBQ4/8FRCMq5CzU7l7FQik5IpQiq7YQYWh3vM02pcMVm7q/CMF7v1pmxBrDFvaLGf9LN8AO0PknGR5bXm7Gvon6+3i/uurg9Y1TTF5vcy7ODOx9phTsKBhWZRNgkKv2TbiX78Z0EQKq8eHrYA9xXj5hCqB854fO1Rs7rhIQOgrxjvBoq7FYPFTJF1R0vzL7jDRVD1DhcRsDw0tgvIxh4P3zEu/S4epcOSo1DXKYcDx1k5FKgRhgGl61lyXg2Dnfre872QAkANKcQ3jlnKCt7FGAo9CIFVOccqFRB+jotdkS90XAOaqlsBdssDFS8CUSRVcFmz9Sz7whi/0ReH8VNyS+xuV0XA4IaXd9oAeyUzjb8bZjHb5gWFQbeLNMSrbHk2vJLpycnhddG3nmBgUe833avV+ehFJpN9T6lOfpQ3doQrySKQnCGbbnYuDqZHcIc5G6t8szoWoxpDUYEs0R1JjrgQLT172vHfAc8DF9Jag3MWheZSwP5sPGbd7o7XxoM8Swfh/ZIWooqHjn5GpeVt3P9ygRcd69nQ3ciN/zrvwH8bYQDs/E/cdt3JTVQwaX0Q/deLDvw3DGEvHhhe5wJEL9hga8w4IO/XP+jov9Y68N9GBYjKua/Bfxt1BlKCAMzYrpbEP4VgFzwxdeVIO53nvX7cqADjb3x9mU6TqqbVy1xvCH4hqtepaBY6MV8w7dt74j2rAfCrjvLRrJiuXyb9L++ynHt1lEgtfaOiTzZ3oRGWRiozrjWgRzbwXi5Xibh0bDWHSdR8NAKfhe1kkMbNRpOJ/ot4pzeDC8gVJEnWinAwuAAdTNJWo9XGlgnJ/Mbho6XglRn+DjPSijIm8Xf1eXDGvxpjOosWWW1WrWVms0qvMpBizyBHJwEj8q1WzQOb15xJhOPCFtq7w0qKFDs1XL+LM0Z2TQ+bjX4M2YKilahrXxKCh7WQP/fiPB4VzXE2SIwLQvY3HOTwL781Z5gcFG9v4ZpWpgFSiZmhFoYnTse8pYln+NQTwIrPsvIJTRN2Rd1+VMhiUZOikYdRPIxzNigSQpEvWQPBNOQwem1wckzPZtPESSdI94iQxBEm2Bu5fslO6jzJ2+u0tH2eZyOx3iXVFpzuP4uhnQSTVp3lSfxl1Z4nEyAeaJZetcM/B1ZWPVFW6cGmCazzm0zTMN1558HYHtusReV8Rb0Hm/K+YiYPM/E+1XRRHt4aT5sPNFi0UzzoOA3LxzcYMT/tH3TIyujx0GN9lw0HRqzrB2BmHKbgud4x1hrinU8TgNPjaOtf4OCoPic+gVdpPx5u5PHFn7Ns9DVIPkZbcvvKArk5hguVQRmqmYxwNJmA+1oBshrogXCx3piLSpTlnljsH4ZmBuV3At9mWkHKMoXRPwSVmUL2Q21kA+g3J6/0YpzlyVu4Fn2gCRCItZimOY3W11HRdjLK8tujIr74Y5CQ//7ra1ZCSdXzn1h0GUell2lmK5CbsLhN76PwS+FrUUmUgYuj3w0t1h2Vk9faQFvZLZWdhnudaeHZ6JhXaptXXP42d3PiMXQ9+C9GYoHLS7Opg62P2KIEX5UY4lozvIiRD8v+FYisnMZO3UGH6It7byfTDaeFsPa0p5c0M/ocNBZkwc2U/Q+sp4/ryrIH4bxfw3iPiuTo4G3VYtc78WYIS54p3+qkFgqpMWQ9iIBpZ7UK6tFWCUBT2q+GhSJLUTbCoJBXCZyc7CUdBM7/6qEXyac0n85iSGT9YFShQX5r4mBdmHgvkEkW2/GYoSJH3LA6+PSvHCN3oUug9f31QyNyHb7/I4Jr3sdy9SQudJmnaq7aV+QKxOvo84k27fb5T3Twc2sgx4CyMTrdsn9eRb2nz9iPx4/JZRusgJyjavKFN/nCmrxg/9AGvEk/+j7qRj9GSy9fvOi97C29WI7+yj6+AaNxtCJ/mbjzTunz+ATAeZ7UBRBDsM8+L/Ug/bkcnYUJDUGukYEwmCMbtczUpyaf8smnbPIMtoh5yv420IbN4X9hoi9g8nJCTfj6V2zav4zzdUZVa4z5t1oMZb2nT088UxVNFrstBNdx7yXkdSUPMtPHLbIQJTeD+Lag58lAPPrdwGsQ3tUA7jsPU3aWDOB4wV9gnOetox+i3jL7n2cd+T/dZKmliSyBR+t4RjXET3zANoDtebgubf2ip6w/GyXjabuPwwUMyfA22IiPG/5cbeAAOGj4exJPL18/8Vxa0ZkbJydP/0c60GMeMMlnkAzW5Sj430f7W+vZaJKN4b2+NVQy4X6sWggI7WIyZOc3G7R9GBNS6cd+SkGQ+Eb4c6rOYXEP00cKYdTR4fwtajj7rF0wDsaR3G3Z+wk5TTsdD5Kb3XOR0fC1JYnL3UQAQUUxWEZL4lfZ42D5hAnfIfmvzIE+jjP2x6e0YKw9/TvGOVj+OTlTtRq0rb6pYQQbX6UXMavRhoBIaxewLNPsY3Ytmb+aYiPmjRie3uBLAp8XLd346paOVtXXiTDqtTyFB4wfkuFVApashaiIx8UiG0l63rCmyz0iOFV8EgLtXL4dZR40BixvZ49kmmxPPX9rDfz776lbSHlHLRC1GXefo8GK4exg+FYzQOQVZ7dj3BTrZXsSNV8+A/bT7rXAQZpVXIEjxHOrDG8NDCjEWeX+Vzx74Ohf6ZvY7fSWS6opq3hFPU6ozzslVepf1vyUJBMfoKDnb6eqtqt3hpoE1Hpf9Qpna+Fn5VMguE9WiRDptp3nFvMwe5cOvc3VvUGjYRbb1khnhKa5z0aHR1FdetYxaxFJhu9665UHF2WlJCteenB06DceCC+foZfW5eyMX1NO8mya9TPG9YDh6qB17DQYJrGKuL8QxRi1YJLlU6gEx0XOFImrBIYlDxmRjiKZihO50aCpekeZSF2on8HyAkZdad/bZJIz9GSz4mj/Y7AsOzufFX2G+oGvlpiolTn7VE7bqQ9YcLvSqUvNAkCKW5tnJzU/IrLEEmq3Qgke2YnZAMSeRKcPF2LCk7/+5cmTNtONpk1oRcJ+CCDwT7tgOytRQsKdAeAvT/5UF0BnAeRQN/SJxqn4FcCs/OnBL/zjwdlERZl3EG+QIx5I4ucjwBz7wMi9vTnu57cTmJokW/gK9DVev51c6gwScEqxVitWmEVjVeEfzzLBP8GV5V6NemcwGcxwbWTjhNVnHes6lqC7kfA5MG7CBBDv2LVyCZVEBBhTl5TEJCvJfA3/J1oO1EQPodn5Ob8bZYrDETsAus/W8jy+NUAwtaRXIv1yGH4JmJcx6Zda/xA2p7iUHeXLCxH+wyT55dZC1H3Wsr2bkOMWsxH4J3GAnRPPeLqe8USL+NnQ3yS0v77W46NdomgtKz1SlRy4JyWIFWpToybaGLieNUzUjmQUM/TJWBcqZVOOmmGse8JVS6ZCeijH0EIZKfiqCBWAAVC4hZgcCqzbW2f5RQtdxLrgi9Z0KnSfv+xhhRctX/ul3vNnAsBTP4Dei2fPOYRur+ULueNGG5OM4GE2kbE1EHAGEv4+U0GyEUq9GI02uGMeR2rcvqUnVQP7hWPidWRj5tnT3otO9E8OwTAx/PsSAF3/4FZ8GNYQBh/iFffY6/593mx0Oh2wjKhutDslY4ktwTAXl1umcbTW7kj47lBpf4yz1faYNc7d1+KwxbOTnriWtBg6duVAQBAXwoPtomvIGGrgpL7xrsCWSIzXQtCLFEL83VARRfajWng6ItKN0xPINP5epLQje8CaHuhCOHIgi/VKBk5WK3MyRJaRXblNfbPSYpbTt7Gw5f261CFlGbNeNXkUTsc1Ru12b9O5jtkmZwcynn9SUvqTw8GanlEIYdGlO5okykSXEHIVvUFN3/y4TOxAVgKnH7wqpn3oNp6OqATrziN2X4VqediYR2w/+TTkZgcyU/nHCUbfghhwgdmgGuRvtZEU/TzF2H6qrbzVJI2JpAf3QN0V2x7akCCZXNVuGEnpe07lpq2ySvXD/r5iasPoAh/t/mTCXwoPJoPXZim4z6kmwtLittnJMAodtEsGcgrW/RTbDxBQ9JfREEPeWS4/jpo8JIwQTrPrwpBmfcosXgPKNngTKDqil4FS2dSg3UqfNRRyxWVp5tgbfKvoSTTz9YKtSQ8eNZ/PSWaGq5iTbu6dk4RCezRNBbw3yG1W0RNv5u0FWhtzMmwLYj7Ty8q5YDP/PFhr0oNlA8Ee4FtFD6KZrwdsfULAKXqrgEnp0gdYw6m4UpaXHUymZ/umjrUMrY5BKxkaycxgimKfG4+GkjwfFRcyWO8mBBncLtSVmmkXku96sgsw/bYx1ukkT2TcXcbMInyKo4I7GnYy5UWIOytX4Wah4vlsOMScT3oFRMxccJXZ030AaljbBTHulgyGeOpEmjZG+fnRSTTPSJFzCl7YxMtC7K4NqGJFrYa6rzIxtGR+9tsS61oTrSdJPpAzmS2qCmZooibf5mSyAenXTErR4XaN/l391UMhR2M/2v1jFSMiq6/bw+I7o2g9rPHWsIEiTvI8ZXJEM51AXMQpvwLndmWu5Rt3wyYQw/6rbdTil9dQzX+ETNXq92qoNyplJkVRLWiiy1c2LrJhYmddg11JNqrWRCBhzJMneiW12ZIQChwYjyiFaHDyl0w8Ywqp+uk7ryZHSt72uXOyp0Gnp7iLd270FLHmGRi+Hxs2FJQCOAS1h30oMPU1aySGxbmlpLAwKu+rAgWh/k+D6vfhCTw0DQDvK220zP4jDR6+Cu6K4O1DjbVASYRAuCshSkF34+SGic8BIntI+vKihYnKusYfcIlM1JreFxTR9in9772d/wv+0/iX3JzmnqoBhRwW+jLLt6PuVr8LsClY28dvfvjl84+n6eWfdp5frz26Y9OHa2dwKhvwy3/lF+O9gwbHNKhsRQrhA5OF8GRd/Fy1sy/4jAqysv+spaBkiysjTotRnUC/45NbG8b56CCZgrGgCM4MfZQWoux6DErCzWg4IL7ePOsD1NC3u/iNaQSDFBV/8/tBNsv7ifVRopZ+wzQ1oBo8NaCORvF4ACkmbPmKjX2KE6Kegh0qw8lh4r/k+yTOeZB7nCIhQ37/KWYcjuuCWh2fF6p0ooFHpbNxoG4N3SafJUT9bAD7UXit1xVdhtLeNFyrw0/KFbqys0/0KQR3r/J19cl6DsHnNRrUnRElAe9URgP97BWB85RHtcBLsitFFod34g+gs3mT9Fk1Mc5mgcsIcTPxbxJvA7zqBNLBDY3/MjYWXT1Vg2x33d6349ftFqxHTlRiUEZfiih5GelFtPF1cWDUZfB5nCiXBX4KsLhPQX71yYiUBk9aIEVWIDjcKx3+aXqZZ9fw0AfWEaKeRGdJFEeTrGC4uEr4CBoeRmMPzcxkRoem8nupZVQk6Zm6SbB2L7StfxFVuWyF1/fNERVSYsH4rBBheRIXSDz07rfI+/oPcrStujbnA4NMXJtzgd7ije2tHfJ6wTwtR6g/jdKxWGldz3iFYBuoJeS1X6ogxzflkB07swC99ul9BegYEsVfJGXg71ycrds7OWjqXg1a8uWqvSEjBGKno3xDtkmLPO6QpKBN2ZXIJh2+Luvx9Vd2ueTrsqzH11/b47Kvx1dlXb762i6ferss6/G+Hd6R13bXnvcRmFULofgsaZjiI7smLycWLUGKFL2CxxPRD4T9eY1zwF3kMdJY+7i2v41GuSYRvx5H3RaJpeRa9QQAMJNmY23T40Ia7stLnbekZWoApNJ5niaMbYq3hggOza0E82ZIJ7FYj8lqWDGflG0W5ilOeankWWw6IuXiVztPJsOYnaONPx1s7hzs7n9a+3i0+afGQmBIrWo4H37e2NoACGUYqgFnZ2170wfGxGENQEc7W4c+QDN4JloHACT62Drc2t35EyaohBWp0Wpj7XDt8HgP58C4e40Wh/tb799v7qux3gP5O7s/Q3NJuuAufSjbs30lQdD0cCo/k4DWUlZyTwI4w9Id3ktI2fCmh5O3HDGQKwM6K5JBFI+jROWNQ6U7aY+SAt5Muv6whhqVXRv6Inia8yfYb+HJQ5zfBpVGJgvDrVExzSaOARuv+zqmnTmbuN94RfzXUxn+oZov1gteu2snBV43m4SqSqhizttJfpFwOWg/Hl8kc8+YADjwzN0odrDgaWzjwwXgzMF4Rx+ewELEryB4vY9ZPx7yNHTGfGAvO3cb53nyt1kyxhcdRomOpadv+aSfBrytgIsbQ2zlhdlYiMt2ySRPIPXcRuYtLSkaKNp9l8TwAsJTp39+sX55sZNN0/O0j++8ioPZBGxTGPfHrg7KxT4Oh6PJNxHGw/BRg69sMvz7ejzuJ0P9KOUjAxZACZv5APray7M+27xbxdtZ4QVbpxLs8veoP/Jxd4wlg4VJBny3I6wLTDsYruY+g4BBvOO3nP5l4jP3Fp9DcrKPTFcD0CCAMNIf2TsDK2nEharBRMvAyHKl/RrUC9sD+Ckby9t4EIJxMczO4mEFupgGJDAl3zHzHma577MIK2J/xovG5HrbD0uUrvtByrZ+yKfI968upAa0MxudJXl7J96xK20LVa68ktDKQpX0bkS2tp9w7Fo4w3OosIcKp2JxmOE2vbULC8njCvLx8nqwI+5HrQtOKeGM7WKQjgNhqnUFh1G62WHRV9Y0j0q3f4iFAZm8bSBGqIwtaKuVT+8DXazq978V6gHwfKxFnuoKDaDNMQPyOmC7YQY44DQK9gYs5aPB+RgBBchqfcbSE6GOGBZmaUnmKXDHBgQsevxYf7rzhifgGW6AXHbHw9uQy6Bguf/8Z/SIHieeGLvmOz8bnhl/5tSs7Imxa0EzTEGlsEoSA9hRb6rHaFT3j9KEWDHOYNAdeXdGWYfHr4Mj3w5G7zAd4+LGZBq0o21l75m3I9mybkfKZDV3R6JlRUfKc4rt+Q9xsX4J4qV2Sq4jkVhv7zwCif06TwlWuoAks81J42bLKWbcp5/IUNSGNdLhDmIS4p0e4Q/y4cGriOgwhiOSqDeZFZdNl4e4oDhDaVnGeLaMWGudaSp+tcAAQqy5opm0rAum5TfQl7FGlym2Ayb/VWfMRue1e3RnJzs27wrsyQoDv5ip525g/mma9wz2BGmHDzM7eUdhT41vYTEz1zY//8ToBYc9LdLZw8yKmJ7ppPjNxANOit6t2JMinT3MpMS9irvj9EXIA07NvZtxd5vV8UPtN3KxQ/pkapehJ/h9zrwqheF55lWSvMD8VR1gHmUqDM5T2T5Aqwfm1LLy0/Pj6HQj+xlSYcf5hf18ya8R66ON2tAMTQC8TyR80Lfxgh+eoaKNjfXURjOLZQCOphkpzyZWcXOQDKfxa26mk3UgI4EEB4bvd+kNO+SXTIOyT6E2csyjMAaIpZWaCvCCGpLH6lil1Bvnv66FWvp2lid1jZQuggFCNGIgvJbIsCHSp+W4qp9f41FSmlEXHmmnGICiDy4dFxAz5Od0wDBK9R1vO45hwMgepxcE740qVG4NKF0HfbEwSuJixl9dhlYGCEGo84Y7/TcxDwylbXXLVGOFiz/KV+bXUXyD3v6yqEvKYMsfily5crnKVSOI2PP99wot6t1+uUYlhXNj5DaMxWoNzyJGDY5TpQXREyJrSvoFaoK1S8Zo7Tg6XG8aTjBTuGJVmxoTS8F9pNrbNqma660lZttprckYhD0GfSNPQzB7CGU+sOadeQi0wPOcI1aaHwXL8fZKEBZDmaLJVyYhmoaNMsZFD4brOIdMWCts/GyIBVr/LjIoOYv7X8CjCL7za0po+wp+8bGwQyA0Fnh2LZ92Nhai81k+vUzyqEhHKRMjYApZXkTX2RidV/CcHbQbZqxsCdswmvB3HRwnr19/c6QMZpMh6KUJwY7CxW8/e230ElzGm2FHnRAWnSvGYmUPiiXvNut/7py0TWdOnZfIV72kS3iE78KqI7uwM9USXQIiy5n9XQgrKKtg2qSgcBJi0qZdSLBpzb3seH3I/dNiWnmupVcME2iTn+YJRHQlC0/NqQCMRjswKk0zJp9qm1VHlwqTBIciRm3UflVlA7NMpLTtYzk5GBxRBk7z7FpYIhy7adgW7geF6HXOD2VEXVz07ghhBnYRMZbClXWaCMwCdtzSz2NNsLJ9YB4mtsb+DYumaHPrhU45iFnJwzmNYdldfFp7rG59eSaF69+FRD6pqEAUToZotoVAV5HKDIRqxEtacWmeJkXTnBP15AtfFzul9LZYMbWRuXxGaHGx4k4XryJfUwisaC464XjS/Uy0+WzD1DXpitq1NDFI3LoTtNuslkyGNag7Fz+1G5xYObx5J5lNaswxm9hTvLOf5NoOBs7yLNggFWX56c42V9taQfhOq/T8X8GThuv8VBjoy865A0oJKwEojA8WkTpaAmMMHsXoeSCMEO6m8kBqrRr3cEWilYF02g6RFg+1C5OSKoxdGfX6EgjWla9BkiocHRlPC66amSDlm8OCrzmdy2M62Jb5fljfL9M/649BcNEFX/O6Y9CX2fTPOfDAGyz4mtcYw9dYE77OnhCyKHDBYie5hom8HWb9L01+J+qhKO/H8n3GmNhCxPAKdrCK4wtvogWNGyusb0Vk3HeoZJwmCjOizee+FO7dY8Kx9Dm6rM9Rowr6qh+E9uWAL5JXaRWl4ePIFbyPy7SEAwr212jdx0fHNmuSrBzKJCs9qvyX3KrYNJnO8HLuHRRCU1XrMDvQpKljIFDrYlrsjrmx2rqPM5y7TIgSkS60Am2VcFH5Tk3Egmbw5iF8Dlo9YXE0PhRzIUZOPisOBd4M7r571zCcqb0jNOCGhieMWsHB8Xf1VBLn9UbtIr5KDrN3jAovdbHPjGp5e4rwEEx16+OlsPaCpkTJqurlELEkpDnVUuDuwlEffJ52d/pqhtBhmJiMW3ETfjlBGtloyM2tdg4MuXiIYnKJRNqoXxCKaVaY7os4oHBdayvSbVXZATrc+70NQy5E8+xD6jFpjcC/JWoTvYb8o7PnV8RmsraDjCpRd0+gGTmBkPSqEa/EdVos4T4SdqvBUEa55hhtv4PY9+rPpoDKKJ6gveFsx8GwbVKJO3Xayf7m+u7+xtbO+9PdHYaDQNG7d6F+4hkYXMAlubyftaPD3YPDtf1Dtx9S5OlHYO/b8hg96m/BX/gBYXq/qmvRifihH0zyvRi4EtR8yDmAfXsv7Cpb7/ZQnv/RKE7HxAanJQRHxwnZeQyh6p43gWUdMFnQCTr89Rc38pvr7kp9foLXjq8YcJ8sWeIU7YiMwZu2bqdji4baMdx8TlXqrBxyWC55AnbnZcQPdQVLdvamvEd1JWk6G3Oo5rvDOxv5AYQ+qri7rL8wNa5ACbpKmENJN63g9IILsGhS8pvXUc/gmyaZzzMJZFayTHn4rQY0sZpXv7Lat7/79anOv9uV57e46ft/13yVGPnD3PFVmhPhRgqcwqfSKmGZhMtNKn5r7ze7if+md/Hf7DZe2ZhMUdCTw21qJGRTVbq0juYL3ro9t2428VctpvAmZIDxn/rxEK4XE+M6VKZ+48XcCEVfKOsBClDdCljdOsB6AlivAlivApgIT+ff0eNsmqxExZd0MkGBlS9kFE85bBjCY9ijrB4wulxpA3yuAKLdbouBQFLC0KV6pR9P6zuX+KDK+jCJx0eTZklWgfK9GfIBszZ46rnbsatglH7vVheBReDzImeD6RgQDwEkmaLc+Gpfgyq2DNGTLcuvCc+648d38dZxbbsB5GJ1MsYryPvie/ouyBACYU8J28sgKpJ+o+WNSvrg+JCTbbRWS5bIuYPqWdpZHbVDa0cI0zFq3/PkWX2wu7Df4nrLbT//NZf37uMrrrtqjqn02mvOMVVef9XFU9k12JxjKnk9a1y6OD5Od9+V69Sl+vS/+W0T03Gi7JyagIJOwta1vTI3299t45bGbM1zY8VzZyXCT9uRpisurkzrwZ07Lmkg+ZqRXcdF1BdwrPEFFdwqFbdKya18lF4bQeURCkpjFJRi13/yvnrtHE336/vuu/stlvb8uIfrRwULqT5kK87tV4b74b+eD4C28+uHQKG7eh9x/Gu9kdBHiWZexjOJ+6DB52f3jcIf3DusSDlTgLEPqIJD+Hm5toTkGwixxXTegmcLLofxQ/Syg/mGO5FMvu6eozJkAZiPKobkO7MtBjRynDR93niLcgpe4c1u3LcVDm/jkeO+aXwONL7TnnSOMvovtFYW4c+7ZF4O6R4dfi/bUt3EuxRBB9xSNbIM1LZ/ca3SijUG65DmU+IQa+rrRb+tXmDpHuz2vsz2nhwTpqB9B3xeE2YUDH6bar74r/TpQAzwmIZlngvUwg/VjQPEuBkzg0r5bzp59DjHemkHb/E3NmPYOUCM+FShi1ZZxT8I7RwVam+6QXmAkChRPrTqeCeGt797sSydTQwE+9xH6rhZKT8q2qlj2K0M6GXb7QMRqDAhy3sIONn/EnopUR5wK+z4YLk+CH/APsKY5RhWg99IrHgfpZYatsNeDp7YNYKU7W1WGuWDMflH3tn74o8AfOvsMBH9StyBeNBN43/qBm+ip8lSy/ROoCzDcOHyDUW7dOlt9O0QoHv5F0GDOSB5zuhzyBc38B5+ZCX+p+VNalfHUIHxeIoy1V6Wsl97Sa4ncpAwTouBuO+h/8d9GAA7WqJBWkB+MaL9+xXjR47cLl8qlbDDeZ189TMH1xhB/ZDELZQVHNNYWr+vIz+EZSIo3fOuOjIJp5YMK+HSnplJbf7APmgGDp+6Go00nvBgWhUUzSezG5Y89D8aD1THAx4jdmq7B6iH57Ztzq8VBMzkA8ngX2OnizR+ppiSrGE9PyslFkap6Bkg0M6EGjj4phmPeYB3ZQKs58JDWgltl7Go0fL5LTm8gk2khuud1ZYJzX58+29DtNTR+q4ePkCIAXzcGiaeMQqunGIxMyqXrLXMGqxwf8nbxEPg+QXpa9CPh0NYTmqz0E6KkPJwaMblCgcodWJk1cUDZwXOHpdPA6kAsy4qmVnvxHIYwb/LvIsDGiucsgfxVeKa7rP5nfSxWV7aLCAei/QFSIE1xWL6joCPlYCS33Pze123fh8VSjf/cxHWWYqtrrHNromZv1OeqHOD+CzbcqUvaC316DMsZESvqqca4Px7c/pwV3lji6n2PG7dJS7aCJmcfvpwGLbt9wCPXoe9sUMQ1w5siNo/24Fo+F2b3kWPfEe06FBQmKUy3ZU9UDEASBIllGs5e4kapa0b3SdFdfd8e5gQsAeL51PPBxBy0MGrnPsvwAUO+JIIv/J0WkSUNehYBYKfkCgFfFSr873bcRsRFmb6v5rYyBU28m+JjczGRmSxPIKR3MZIXhMjNhfN74uUMgqt2AFlSPtKIirQ4aGIqLCk7Q0MV7s7DWO2wVcfoTcerZC1wpr02sFvPmmqJzGuxWXi6jlrDhd6b2K1DlIIRUjYw8/P/+7Jt77dBiz824+N7HfYc9RHXVZu1XlHWJkxgrzvkSKl/4lP2cse92a4QTMugwoxiKTwjDISD0LjlSc8SUncihI8uqDuI4LXpXDelD3JlGrbTIJ6Ywr72E61cBuIebVCmQhM9hdKcaCESK4g8CGrXs8d+5apqmCYlt1zqPcmcHXkaYXeueeGhUlFGKE6B1VTTGwQPC9wFd772NFsRHCtJ7XtBjoPWiH0m4Dt8pcAZaH/CZqqkgRMrecFX+USVO+F+VQTa8NqUZlBIGRSDjSkvvDa2hLoBB5Z1Xf9X4nSi3GW80cP5Lk8Zxu2GaMpk55rrmJhB2oJJ2M/gsMBp/wMshyh0rm/rNKb1xZGvLkPtkuzv3kzIWwHs9x5cyJsB1PXGbatUod8d+hOtL1RnecI7nxcOHUeCLgTtcP01fYPN/Rfyzlck0TQMGQG9radeYxovSc8vm9z2+t08q1MT4gdw+ZEjibN0xmNAAArWacxqOBohFc8HjDs38VF0yAhs7S99o+z3OFHXsOnCyQ8lnvXVZgWLHopwovo7ZCR081tINiUGSDDSPDmjZGh74dlS+IRrmNuiQtkfyt6WSLvaSWhYsPHEPG3qYqc9N7ebAEaOvnAGSsTPD5u7WxyQJjDqSp3RMdXxU7b0OG5oHbYqW1ngkpupmzKhZUnys4PJTFWzCZJ3oTTfyFqNIQk4c220tjZZZrG5tpHnvCuUZJ5xVfVe2kq0NVoBMUvoFXt1eHKRpURVjTs6gAY5cQukyJ5KU/21hxnjDwa82YgqJEwQPTQqRsUvyKWfQhcKBx9RRT5ELjyQPC1IrdbCynSoPE1KrbjcQy6NM2DJtKjCBs8O3HyD7MzCLzov4YwIbVPL2dnH61olCW8198Yjgd+13A2NMy0XEnCm+qjsaR2NrwyQEjfjPiO8mGTHsOhgVdzdIEhtdtQm9aKlvGneVVilmEqIvphtayDTcaZ8nE8nKMju0lVh/UOWnH6W/jjf5Klt4SAYHVYI7djbzrxLcb9PvBlYpxikBgHF/u7wESNgyScNso3EWwZ9g7GYhgkcHImpx9NJsBhC+ChYMf5cPS2YV8lXDLobKBt9v/v8mz0y2iowFiW/ngIpyU8CE5cFx412l/5aH910W7tN1bHFPH4HC45RrLxOLlhrBG3Agw+tG1+PfE0MC1P5sDLzKiPSFVzaKG5oHB9aZiPLiGZ9DjpTy3/knB+LJI4SsC1j5tA99amYF9/jgtkR0w/u/wtmSAs0WXrHhzLwgHTUxglrrNVmNIpwOhnOVxi+ehjte7Od0jQ2UIV3NmlSzYqg+0Pk3zabBwy1oYmzARvDgUJ3jKZjQErqMosFjjggVaT8KQAnTvJyDgxMO6ax1vj8wy2OAydjFq9SgQV8Wj/I5bR29yCPzW8zIqpEHfZX5N4emnK2vBaVb2OW27h2+drwn4Y/7m+vm4TBsRB63bLhv1SzIkVW1Pix/1OMr3O8i9rwglnrN87GIZPUS0aJFesC/bPlK1IMlghFk/WNGTpRNxM1CWkrJlO1gYD+uqB+4xPDZdWWZkNI2VaI/Vk9YTikrXN61u8G2ftDcAkAFcANt8pFuUEKMGBOSPCx1dvKe4NlNcejVWrUjbCLQvwnY0YhiT9ttLJgly0BYGABYXtcnmKCb0/jbPrMde5CjHsX7Y/Qh+GeEOrKSyIihZdw5W8SCsZF1OSWrLJdLOtAd2vvJpyp9VZXD0szBiBN9OlSmpZ0vIbpLeE7NfhDJcgG6kkl3wQ1h0U9jigclQ8Zbra2WwKQXY+N7Y2Gif21RTUZ2cIxaf8j41TBrTiLs1lVhSGl2txNsQryMcKo1JvIe7kJq7B2C/ByAj/GnmcNggz4AWTPDlPIYBys6RRu5idFVzdZTz8RX0mUCVRe8jSlKpt/muPhEuAeiKuplUK3k3XGAr7YHM3Sw16ZHpRltemHpj+mo7W492fAxpQrh4gRlSGsyR5f6SFtOOfk7M9BqVt0uNARx24C9OwPHgV9VJPJvpkPORv9V04wmRJcEk8EWejdJwV6fTWaqILSAO6qRYX30QbfAOJ8eM+4l0ZfQSfRXiZHUzJy+TOp7eTxIME4UpmKljn6cBTlW2H1DLJC6hgf+PijYczspNNATsW1dDrS/ymATgBB6xzz+W5RW0eocvr8qQHGPCTk15p2UXtKKG+QQpn42lC/MSyC9v3zD4ERIvX4cih//xnVFFpb3MH/rUPEUo2Nbwx7kdTZ0ykDtDVW1b0lbSloZcdvHCEbkSSKdMFWg094Nlh+oVI9C1EMC6FIyhnWc/BHd/3JqmGpcE5jvA1CkL0WB2qjqdf3eNJChEbNqRIjdte/Ton1a9aOFWEZHn73JX5O2Hf9pBwj8AuE7cMWsxsuphXi6vPG2fybv1+IdRH4yqiWSwApAV7wqVybssCH15ZVID7hdeXqh98dqFib1X4dldvWrmXlOmTHKLaD8Mcvkf8U70VCaYHymbTZtPwkHGQ4BcilUSzgEFaV0uMGuVCTV2xptKZyTppN8Nv9UrkjH3hyD+i+k9tgcE3HvE0wD35w7TGeM5m3L9sNoUd5xAMhJxyjKXCXeipRB8Nk6u8lmOM5RvPaV+yB9Fmej1Qb3YkS3bei9PKhnRt1VeSts1IPMNSryxqaUqV4vDXiNmEfNYGTMi5Nnjcw10OVKkyrgh/D/VHny/U59JrCjYAhULU1uD/lXx8a2M+Ts4gV+4rk4eLCfZtgx/DDmyaA+9lrS2hqope/ZtfKXNGYNjZRXhtMf9j5FXbxQVV4eiNng2GNeUPEljp6cHR+vrmwUGAK9ptRVynaAUZY563R8VFGVs8zWfjNfhlj521Cw2fDH1fHFcbVIvTzpojg595Dx6t+ZlumcFOBAufqxPN9n2dWE3cVZWEN90as2EAoGZZnyEA7CztibCk1KY+04+hg+QnloJw+2bVdiDhbSq2TLBX00NWEYrhMXq3+p3VHnUNvFvvOGWWAZObGgM2YDGBCuYeAhK8CObVv3vyJMrOfn2So8POE8bKR7LprwV6ChzzUByGiwB1hQGT3kKUDNIpuNIOkvN4Npye3uift/rndTqYXuo/L5P04tK07J5eJOO9HJPdafurKtlPxgN2Tuae0rcxvFofIokc44/2YR6Piwlj/uOpURMiiOdW3fd5fGv6QQ9jcJncA8MH0+l+0V6q/grHdoVgy2ALCfJnwBIN72UWf0CsueWy2ZL5WVU3vsJNOpNGDtK/J1vFvoDsi+lUXSPloNgZNY3TcZKjBtswHJz6JWWHyc2UfERTVHKOD52ZvgyvgyVJoSs608WScwZq0Ih+JEUrNHcDT5ZoNb8NN781m18LRFoA+OcgEF5sALqUqLcgie9BUKLcgHWWTZnwwGBxUby9E++Q60TRj10mbf4lNxRBtwkzSAxAagwzHpCiAbGRdWtb3sZ7T138Wbc7sXwf1M0Cvwy1bxtMebxxg/3qCi3DuIEkw3Z7kbDTqalrfWbtTmxQtyWgOPV4Id0SSNQbuwEhlubFCrb5Ooxcl0xDUrF3ItcuSi5LYClC9gK7DGFFcqz1jLHcedFjNv52lBPm99w9l63SPliAmjj3d8MsdqlrLvIKHh/1+rv19Hdduz95SNTr69rT12XtvtTJU6+zS09ncR8AVfYYOs0oeAHqxOPBdbh/tNnwUrA6uOalXt3w6yg3HVRO3nv+0pmnZPs4cSSPtlRDiL6f9WcjJi+1++grtDlM4K9mY31t59PagRHMgjRsF9PbYdKeCFqG0zw+w1A/CTnVgeyumW6bXbfTMWvFyYMcu1Y5kirp0NmagWX/MdqOp5ftHGntOvpBO6zbWxxjDLZa7KCF48PT1fE8XV2GuzomXbHjhfRk7Md7TojD0D1cW4gz9+E9p2J3cklWL0APZyho43vWyU3E6CEdRGdDJqc3ypuxGhc4DimjWxJ++3I6YuQ+SEJgkumaJP9mA/xOGgtR4zhj6sqntJjFw/TvKI5wxUYStSL9s2xw244Zi2ADgB3dtDsw1EFOsfsJsDeiXXHFGKvQGsrIKAg9Hgw2r1inHzFxQpLDmYlywUIJeFtzBgNI4XXUKqaqLn+IJg3bRd6HXMPKTRyhXUJHOr9S3wj7iDXG8YTVMu0716iJ9JbNjW5+QX8LuZB0qbLzc7ZaH5Q83JFJF91KkgDLYaxEIidbcZ2iGV2H6urHE4j6AXS/x2ixf6uZeJ+dBfxKUmqY7XVeG1AZs8Y/JclkRbHe6/BcCNdCyalq1oHcadUjwueCHMaK0Z0zY7sjGD3scFyVr+sfZ2vixeneg5Frto4P0Pv8HVfihgzjzm97kC3XxoON7HoMkaW2RvFF4lIaXBnzZ0HXC9Hlgtv5xt4WzXMcKQ7nf8OliskrEdKGPAzxGUWw+AEZrxq0NqcEhq0rGAMn7XxDN6w0NQbvOWzUc1sKzTsJbiVCgnEjMtLOeMUd9LJ7bZ4Z6sVtuL4bKy4k8VAM+uG1+8NUjtmdCqfr33EudGPVnoxuJGfjCG2ewLymJOOLhOnKfu7AtH4Cgad/CHHtj2BoEKcQoZoWJW130B4C92mcNpkbRkQin2E9OUYyCiGflY3luM5YjsvGclw5FnEWm4O58A7mQVbz+N6reZhNzMXkQzcG/XWkV4Py/ERGFzFASFXj8A/AXFvwLjPCVpTRo8t2panWbGolm5rcNHwIPX4QhB7XQeghV7psfB4/AD6Pa+LzuBY+henabBlGpybzK+vsJTuU7wBW4Ym8MrD3Y+Dgm2cvBs6umvvQEO6r2CofrbNynBHRBAQiSx2PNAEhhSC/Jrho9KfD24ibK66SRtkdjMMFZcHXcWNxPH/bOSi935mEKvlKPh6SMuYhnJCgUJNy1BjDTHyG99ByMDA0Y8SIg/is8Bo8QqsqI2MHSLmFAXS/m8MCe//tUToLgZ7gsobnIZAYnkjIvPs1y1U6F30yzb8qcKKWzKXE7H9vabDWXI7vszSHEB69ci7Hc86ljix0/4PCc06Qo7L89DZ0nEIN46G551zHv+eAcI7+0CHiHvvysq5JGy5GvZb/6PfAuTYMyQqAPTPqRGH5A3osHRD8Ab0oztHswoiKkXOe3hjRnNVVh2HilBTzFUeE74SoTTOmKlnokfyuVOM7kh2yCZ7bLt2oi9mm0XQuyrk0rwc0iN+ddkyE+q1LZh263lbrWpI+zMuoGHSDIWtTQgNOeLVve+D8NofBbyTV/FYSh77yDV/XkFheEXFm8pMkqUDpkbYLEKPhJyUpMRCbfhrn3C2P8y9wJkIfImnGY4Xi+vbt7dZA9rhiPWumjSFpiABq727khztZ9OFw+6OACs9mp5dJNIFAqdcpW8li1r+M2MgxiCoHjKEMV2uZIP1RNAPmQv7QvfR6zgolaV7v1WmvR82R4g4Qv7fTcZHk07cJ43OJA2xB1sIYndhhnfFVwDQru6C/+xqe7N0APj8+xQLlzgBXPv+WgBK6F7CmxxApnAHLDr5pOh0mdu8QnAwuepsYZcAI+8oh6qgahpspBvM7teoAQAsJtouqQukGT9Gznwzy+Jr6tZcfBwGHhoCxMOiVELCF+e/9feKU1wvBI6rfVR3ZPtysDYeAQo0ZgLI2mQxvqS6+db6f/G2W5r4Uzz7fFuRV5suREM8LwWj5npOYk0MCD7UPRquld+///XOcj5n4tSIjmU+GcR84JXpTp+Oo8d/qesozzcfRf0MapnHG2SowXtYbzq393+G0sK6gUuL0Ub7pMWFrwsTeTEcFFDc8Is7I/TwXfKSi+uEVds9+TfrTNgOfpwlXnVv6udgkTs0HYvvJ+RDqMy4gIohClc+dEyMg4x2VLRWqd1FIaDpxewLSxB5xJ0d3rrPiRvtWiy+3+ss1Y8tJ1ExJ3mCs8BidvwzjtCi7Mco+KsekiI9LldCRGOEy4IHEBHKS/XLcBHgL2KOaPJA443fbyXgGy/IW4xpksyL5BeK1sH+PKS60NZou10E/720OR/zwaI9mw2nKdvXb20/NTwk8ClhqY9SzY/TdtKGDZoI50yi7nLR/wfBYIITA71flDha82jFpclzS5IPxzoBsdYGHrWJ3kozJq/Y7F1ekjvKHydlxmoOTzJ/RlQbc9wjqFC8pqGOdZlHSx7rSMwkDD2iS8r9rl32F39fpOuJBnSP4EE5mVBbK5t8xQg0clES31LL6WMfjLvMyrAKGzkrhrFQ0LqGuakYRtuK0axvwz8iT5GkJAgCTsoDDTHKdcXCi5ALngLbOZbfmsV3z2K5pHLXkhNU1zGPbtGNwHgtxp3/mT2kgspv7iiZsYJIta1sHLDuD6q8UQFitd0toJFO9IhAxMRiKdg9eSPOFX4OjFfeM9TqcHUNs53oiGzM1ZkzdUuOriysRiryx82SNlIzScagkvgmUiOS9DaL0PBIjqn6uLCLD6SS8i+R+Bn8ywaLbaQYS8mrvaTHVytS/+gktTYZGowBp5NDsZiTQOjyDE6Hr9VgIVyBItCBsqwjxFRA0sm0IKmh8GQSp3YulCSRTFsyKawLwDxNyUGJrNv60s7a9+SeI7qxDmPkrrn16/2nt4xFWlqgrbbC99otqIOdZ3mBrRzcQqC1tcLSzdQiVYa5WXEOlk4mYwBfx7CKxXvvJcNjyFWD56z8ma9wuROKVn/m6T0TKrqxuSIgwIPn69gBcut7DF49CTEpBJWOTv90GO8HG1sHex7Xjl50FOQPYQq3ws0LSsZGwUOdymMTjZGjWBDfebR56YQ9KrWSHVlsmyDI5ALif4ZB4AVJ0PHzHCkFKL4UglhosMhiESoSwV9E5Bn8ZU3Y8EQ8qGRoRRXDMkMOPLwpJ92i/xFRANJ+DvzaSos9K38PA074G2MaY1EPSgwJAJD5CbW3NxRF/6zzI1WuaKVVJPQAG+RtToeQo2mfI2OzoALJqG9NEFT+n08tmQ1PKaWx22zAi3FaNzy/t+ISzKki+bAmasKwWTZ+NB+uiTsAORs+R2CwMfYmaZnwHqC8zUIUAZa+w+ruNCr9LDqKe6eTLOBrj6euQhkIYVsygP5VQBS7mAO48Z+XI/P/Ze9v2tm2kUfj7/gqW227lraKI9HvTpJcTO4nPcexcttKNmztPDy3RNhtJ1JJUbOfe/PcHgxcS7wQlOnG2btJIIoEBMDMYDAYzA7SOxAXaV6I91pC6DGgLgQ2aZByFnqQZoCUa947LN73jvYOdwf5ve4Ojp0eDlxwQqyVEbUxrTTGoU8KpDRai+vMaDNisrMm7/wr90n4dC/cvvIm37M24JHwsZAEXK+JJD21BM5r6D1p5VFP8Y5InZ2Mxw3VZGjMJ8NhvSXylqVLyFnd0cJ7gCwDiIjZcgbCbejfpHPaW4/GNd4XWBri4bISr4C4TeeL9WqrDmiks6745y55QkbBaU/4gy4fqgtNAz9aHmWD1RAg0MS5p8ZTNSKLs6ZVl+eDCoFJrZSlTIvta+zt+21Mu0NBcguyw4+TmH1l77deESzfQ6MljHxQpw2nxENClubupCir/zFS/+oWY3ZeCiDofR9mLu6Yn8v1i6uIO90ynMDbQBnnwTkohX+Eb0g15lN0JFVHlty+qKfL4sOuKjh2VL6yrb/UT2CrqmoJCeUOd1ApGq5AKTL0zGv2eTmNRGXVsx1kFlqeRgyYsVLldhRjObGDukXgYLrP1N6Uu8whbRmsWEF+jPMtlv4QOLXLvgqq0sM5oNWqhmW9Usb5L6uS9kv+Ii86GA5F5jjMtz3OePckTejRuZkhJA9aJTNTKYRyP8Mgo1MdyxiaxBi50QG66JT8a7gVEeFqHii+/Z+DQjS38K4/MaJVs/lzG7u/IrkJnW1daoVcd+nr3IKW4S49I6wZLt4NYrN8V3aH9UD0XSb1QQdayRh1zuLCHyCCW3hiOZOoYx3SJshOCrIxmGx3tssxrNYLI5XbhOhaV3Ddry5f7XufdBchLq75c7ZBHyUVSRGN6BHGX9sgSF5KHI9JPtmfeFXq/5K6ZwnbaMNOy39BeWST0ndgt63jvi+6XKRXtW2XnXrrvZZ1BaneZHO85bDBZ6dvdW5bNYEFJcp7gqVUurNR31tCOUE2qQ5v7BveqFCnLbFMZXmt2qKwYXj5eIw2+OBlmcTylSWjUjjcF/IV2vcI4FtjwsvVBu9dlwO+3uffb3IW3uVR2e4zTqg2vTYbpNhULqPOsm5UL1wKquQSLaePVyk5iLUxcNMviIUJyykX2gIZAKvXwbvnovOP3DM6geDHGbrCsI9Oqdnn77AzfQCs7qdkGKCvydHhkP8icrabg+gelvujpHwah23TS9rjZ3vSgsNQFxjhdekH2JKKXn3V77whNZJKvs8leZuIshq2me91mWORaelWO3RnWgwdVsjDG0QLMhWwSrD3DbrumU1WknlYtrNk/12gA3Ea4wcaB7XMvsmh2eadcBaFDbB/7An64b18t3n0A6K7vSqHMGN+khxTJC7hAuUH/1crCAILQ+yc/inmy+3r/eQT0dAAyFO9Y2I2yD9I9C5qaZw7XM2iqYdS9zD7tjJMLWAL5EfdeplnyCfhgjF+jTU7vYO/5wAHib1mhhfgb7EyGHLzB0Ws7OEpVbub0qjsQD9IIrqV7lV/YgVTrpLy14X08oYm74ePJDfZ05zrJb9X+gMdd49TJdWjhE3rSDlznFedm8Cf4fVOoNzvXNqAVEvXmERnpcEiPi7+Os9MI1ZVwD2i/AZivK/bB5QD3WTLDgQX9LuE24SpXRqDQjTvKRtT7rXVkD5vQHRtizThTcOCGuldIWoEcIhXfGpB3LSHvrYy8ZZB2fYtIm+DhWdCmGb8lwCs9P4czQLKM5a8brqKa2r2zC2kNgJDCnezirBNsh10vXF/vevgb+qcWlm5NgeUIaUQ1VU0LWX3NpivS8f6LlwMXmAuuSTTp8PF8CuaFpiTS1LaQKFxDQiPs90s6rdbCMpHoBRjeaiqbtY36uksqDkaQzamkjR3QCn/JkI3D2LB8ksmJq3RU8cHd8msVlcrFvvBQ9v7SiAMqXbi71+oGpxE3mlFOpCFiCQn9IdWrHk1619x1FHAFLNoHoH0S2mL1BumbaXINzyCQ0kNaGN52/oT69E9voy9soOhAyAVxk1p3tzr9Qh/qwahVf/5AlI5qiWiAYE4f0fVChkxGzIyqF9SoihW8rieqQIA5Lhx0RdqClsPDPdDGr+ASWPV513+vtVPyBW/57EUbEAYNqz2pixLBhZwPEZDABxMIlRbs1tCdDO19OgZK8s3Bof0RAdG06jcT3ANDWez8Z2HhqrJo8r6HCxMzZ3nZh+RvgXW3KIsmSOSwsjvzIoW8O2DCu+noIFci9ZG1feApgHaCiC5g8fOSwoBdbLvQzC9v3e5BvhF6DJOI4cYac6MpG4t0Z4lakwf+2SBWnOao03nc8/23e7sLBXBVckBJh2M/hfrKdBQOwXLT4ZcxvN4WYG8LsbcF2WvD7JsG2rcYal8F2/fGMVo6RmUmtvLBz/WB+A6h+G0E47cRjr98QD5/mbk9KJ/z7TIG5gPzdhL0TyCnvJRC9uuC9u2ApHD+uoB+OzAp1L8u2L8GmJgGwJYIwA6ISxHwWZ8o4BsICa2LhsXnBPpoWCyl7alL7vghvXMVTafohWJZQXdiREvtkA3QvnKGSzdG77j374mBidWs1rhaTUg8PcNGSbqfpceD0F8YBBkcfskNmxaiDypWHaYTtAmMB+lJfIEzLnVgzF0yzC4+XCGqMJ8lJiB+7BmX5Gsaiim+xty2C36P4nERDZSkXwjULwQUmmFlY3AUz2mX2Q0n40tAUPodqo9m6ntYdmPYraKa9Hn1rPL5HUb4vrO962GMLY8rAtyzOZwjyFIVD4w0w16xvofgWFf2+R//oE2Hmu6EMCTu+S8enBqRsfC9mIayAZElyiJnixjQNHgk5KyCV094q2vlI1FtcYbchsacIktVknDiJciG9VjImlZhP6mG1fWEx6LI5Ze0Mdk6z5Q1DLPWNNRI2HHTkAkiq7THylhn43iXO14UJMTiquXSaiVV1twdDyobtTQcboP32c2/hH+nSYMr7kNIR60eJLKx3Rzxoduov8O0fS+OROvDr7cRVPWrWA9Rw4TF3UOiVHSWqOtNxSZqYkvXljSTQx+ZUI+Pz9aQGFvdz7KRgxZWDdyzLIZTWEJW4BFx+km8suKcNqB2C1jTMD/vlz1Wbpw4gdrbYDZT9JIkwpWCzrsVff7bQjtPgKuKCbywlks+u85TEBrwuriZxdJFnkF1LyTVcQiVkKJc6RD6OydDU9Xo2lJ1FJ9H83FhqDucZ8a6nwWdgtDYqLb0yRJE3fpWdIZRI6EEaT+uPAMDEPxPyALw4IEL/fdxamqcwDPvjCuT1Wch06I4zTj9akIkF7d5X3whKtV6QQq8r1aLqjH2De1/2Fe2T/f/ZwqZdiGp8E8GIfteTgleAi4Tp5tO7OjKI2w1LOVE6cU3VeZo7xhhYFnwXTXY//zH+662YxLNjXBLsI/chyKaJdv3Y1zePKY9+ygJbjZZPma7Dnn9/y53juQzLenv9ca2pRd33cJeszKqKBd1XX0jki7j0AamIU0Iqxs6laG83BKwTurybtANFg390mGWg+/hwJFkMOZ3Dbp+0yWHyc5qL+FQmOgZAiGUlUe/dLXTdbLkOXZdLOzedWXpbKXvlF3c+i4Vdu27NAmUzjLLpoNzPX94gS0XZF+HtEVii6nyStOgi16Uf+iYoitIZQ899KiR5le/K51R6QSncN6tzSItmX7QILWrVjkcsdXPnNUO29NAP6l01SZjjDPgeGyQQ1qIh5RYGG2lHefkhkLUMVSYpFMA6qh4IPILTDSD9JnYn9JtomYYSKJOh+C1ncRXneXPbfTMJOhyldL4HG7+OEg+li7j+OTifJyCu3Xp2gD8hr0d8A2g8apGcyR+FHCLBjlI7YiQu3JLP2lq00sMfk/TyQqXr7qyPmqMxnQvcAm7oiF4AI12ieosu7eKWGbgo/xmOvSM9KPNidYvrGxTLmnDe+KLHrQ1Peai5yp5kc52y9kxJrtCef2FLkZj8TDmMspGV1EW74/k0lNcEGpogpRI0yU4XCqfn+Vk2GgfM5WggQSJriIkMU8rCvaeI8icgKAQkc6DN8LkqS+doREoI6PKRSKy5tORqqfo/aMor5QS8U/ZgEjapcXe/fkeX6a+Ii0frElZ//r8NxHMd7igWJv1AJsVRzqzSs3JvzwEgX8Jwlj3kaxBEIgnKubCAoneCedCphTP8dEoTF6gLU++471nR8e7+4cv/jg6VERXMRG8zg2S4FF78sIJDOqVcBYCj1+jtQTNGOmQQopo0kOUxLqrQ7/OqlIPgLFWtc06jK+gF0/HKbfLIp/gqYkPbdiDIqU/yX1V9Mc5KlZRdKE4MxEEbGDr0Wa48mwsBEV9ZZHdaGfIH3MI+EZbGYkg/GGMeAgSiHKnhd2N1ehk2aJouEg+gtEIVNHs9Cc1O/3Jm53qdgCS8enP90qLnxfdLjXHBdnzfNu4MOy/GiODbqK+ZWR8tqyrLAMbL6WG9JTuK1itlhJcTV3r2PgrIc4WH8GwO6uCD7mjcqJLctGjX2PtZAEz+WKRbDp6YXC9sxvM5HrFinOKE0oDu1bXERJs1MWYSUuJhQcEh6dFjlrFw3FG1J+MlowXMbBFNKqYgp9UHP35KLjPhgCssr1fPHKpK88/SHXgfwpeAUsej2FDKr63tOrCQ761yqGtj62uP6z45jx9rrzKzyxS/hkStpAcY9Q5WUDb1EyARv35i88TgzZ3omhzor16FmV5vA9WSdy5cpsbhKIVUSN3T5io5Y6YTQsQZGqviS4hEtawlKgvNcGhchFtEKRciI/sld9pJ9tjz6e/8AaDM9yhSfW3hw+99OzPh9konY5vHs5Kfns1vZgUvT9znIDg9O1kTDMvk+wDumwDUtIRIU8zS2NDD1LUO2uhIP7nkLsWFmwiQ7hpl13ex6+AGY7Z+N/Pj8RGe7gCdDavfB3xMylWJX+Hn5aNMrckNlZaSYxZoV1GtXV9xBNJ00lm9lqgk8QMoemXU8eiAk2Os3kh3ZVYhSJWebRVlMKTD/ENPIrHWB4xaICuvGORQ1BNL34A7/AWiZv3KuAOfaXzixWH5u2oQ+P5SR69cPUWlao3O8MhUaH0TC0wdAH7PDmlY657eJ5Mo/GA3Rde7aAJmDibwPvSp0p6TycgZnfubdn1UTpHK8lhNDX2+qPou8Z8xw/nk7M46x1Gh1xSGtR7pJB8xAfrc8S8qOvxyJdTNinZWYR6UwzYl23qrN2P9tpEeks3DJNXvnIUYhyMMQurWAHhxurjJJqumb7AuW5X6gHtQZKjPnS4tpQMVb6asuwPltdJvohzOMZxniI74/yXjOqdKuEgf78u8X3RXwYu39xNy2quAy9JVtWQJgwLtceGc8NKIF8JnuT/ypIikvKalS/3EP/oLIqaiVVNeUXw09lSrh1iv9FyBhcnu010qg/JYvuMTUnSsNAEl4HAipeux998quu5mF6EJQgpG1PURGNzR1fcFbOEvPzl6/4h4ipyZ7SQohaXgUuKjaHmEGBO4s3pPytqfV1w+QEkEZISy6jXZyspJJWbYfvGt6fat+wG2NW++q68+zUUX4r3kgs8mAJeoTJ6gXH8yIThqYhhauQukqF3iPY2kH0Kp4o45CcMm7icbZnWQRwWzWK4p3U+zaNzuQZ5WMafPHz3/3nf/f37HzoPHj3+9cGn9w8vul5niHUL/x9/h43XEKkgEaLRKN4p6CbrkW9MJXnLkSRwlomvsJ7gU5AOu+yDF7jsmTaaZEx2xGyrxMp2JZpxKXmgWWMtTNiul/I6UykU7Yyg7aqw+Zrxk9dh35cKx5ZE1YSbyWkjPVVJrk1fQptS85cwX3+l0DsG4r2UW4cT7+KerWycqLq0ddJR3YleVezx47LDqkUSH2Yx3YrfbKbdqtYjTaVX87wAgmtOBVkX/MO0OIk+xqP96dtXB+Vq42O0cauPzk7KgeeLvjPBfF9nMMWZ9ShQXYPwXuWe/fwErwCQt6xD8LSiq62fN4Q670pSvC+nAgX1SAGk8ZxXSTUgizlV/MizR4YaEb/IKx3S6vU6MHi6QrxNxNECP1RRX6rDhK84U90zRIB0ormYQK5KmkMq3ZvZDBzTc1DGwIf08M3BAfYjpR36TlZs1a7npVNA/iqaRnC2uzMaoQWbdIO2pR25LHy5SdH1ckMVCwnt8MQ+ItSBZZN2csXU2N+MHdCT4BQURIiiMyHN2D8Cqwc2D6poU8xpu2btRKl/mzrBvCpEZd1KKWO/R837R1JXUT3I1kdI08Jth2z9IwaBsTSFMqqr+e8lZocd2+D4jegV6zBawJjQ/Q70sQtNL0AoomzaMDAUlVqRMx4ZJ/hQPmKS/+PgPkU62IeGaED6GNn8LTBmSHNpGzLNLsmTER7pBSE7PSfKO18HP7NVgrSmyVCqRR7aqp2l45FUCR7Zqpw3WPypOsJ2WoTSpkIUVfjjO9Eq4v3Kpg28has9g/6jhmyGUWjsIUP6kCmOqMkhaodnK8YmJhglDciXZpP0vEdpAR9NqlqXEOY5UekC5vUPOwswo9DPhkKWaVSzNmoP5eXWqUFrgdZFsbpcL87SdBxHU0s3sJpTcnQzStuRuGjPDe4NfAExMlqnlmbpFUy7y2g6giMzKu+wPehnD6eNrnRKtGvtVI96nAGETHf0fsVvoIj8re6J+PtzA38GbLMeDI4rI8Eff9Ac0LpDEZ+kh/KKpBjH/iMLkGdREV+k2U1lRNeDsgPBR2TPonkOYUUZ2ujjHD75pREqb6PQjq2yidl6hnNX46M8bwCe42Sbij7TAruAeOmU3VbQ9RAMJNe8CbbaXMbjGfZWL1IvGaEeJ+c3XhwhSXNFDsM8YcRl1/RW0vI1bymt6mispbyxR7CxitgojWl2ckOxC5wPh6y9fi20JenO98uNVJgfz6R+9lQkl5AtmC7LKOiuaptwzpsnbYivrJA1qMcF7WjnYS2LeKFfTVDP9bProZmK5mA0zWd4ulKNDc2FSzQZELpiWl5HoKoHNhJVpVQicRCMZBKswBZCiUbgP/7QW0zc5Y8Mz0Z7VKpHtD203Hho49Hz3YAuyQRKH1344FX0Ic6pdBM6TRJvsq0ZMEFpwcbliGztYpsc2zh0IYgnvcqh9AQB9iIGOeKTxXjpcDif3eCIH7DdAF+hFTpHkD8m8RVkbkN7OABRwJ1Z/Hti/KYd2Of6N8HZ0ct+wyDwaMj5E2JnL76egd8MWv6TqfeDK0mWXsM0YPUTRCyjTA8JhGaGKAcflvlRnn4sPzU4ULZZcRCfF34thCWnAN+XBrrCGPWNicK3JROpQq4EbxFxZRmFglVtk3jjz6QciHfaHvFO7cQbpDO/FkBLtDttRrsinTHSnTqQ7tSBdKdG0p3Wku7UTjp8crg82SgYu66PivjW6ksSjHWiAbGulE5VkCyEwe8VopBaJoKwM1oLMchR7fLUYHBs5CBlfDuAJQlS9qMBRS7VfnGwLDQhBRSi0HomqpSn4xaycCfly9NGAGYjUHnJkLe/6zvAWpJWYr9cCIaqDZGqBtrQFRN93lmMd7RTUMFAR4+m3svBqwMvHscQ6YFKokkQefksHibnyRCNDWldWRyNbiBpUQ5F0imGOYNUg97+ORRBe+V4Mituunxr6GGCQzSQBhUVXpamsHB+BGX3aQxBhRlsEdCbt91TpNadI5bIseL1IZ4hfQ521ZOoCgAHjkHQJ/D99zhLdVtrDkl6TuQKKJzIV9awo+iPIbAj+PKCM7BMAc8HZ4g4gleSK4VwRpryPgapPo5EzhFDzzGhdOXBBulfUt4sT0y+TSBRw6MCiZgVm0BixkMF1FPywg4r1Z+/udcRj00btEVOb9wrVOdy7nXEszJrPer2gnj86IplaL8hzq/pCouielJlQZEknAqW40IAisHD8cDrCK2OMEuJ2yj4yxSXvPfJc8GntCppCQXAWZX5xFOmKABUkEvBw/vaVwmfWZ5KMNRxjkP4d9XICsSSrW3BcXdtyV8ee+ubQjof2mhZU1eL5i9T0kFLwQB9EnHAV5XTQ1Z5bBRfUxHZ/DkT90aKaVBOQLAvA6TLJFR2BmRrnoPXrQIhSDiDNjM75T8OosSFEG6IFjDRIfqPk+eDDtE5WGMncVEgxJZt0/LEi/mQuDZKLJuVdyqI0Ks7TlWnaniWa56ZXKoxDLNHtfa11uVKmori4PHIForZUTvAZTb8roOnnjRR3zMnrdI/S5Iu1A9eRBYV/2p777RtvK96wUFBOE/xkLHDijMs1c2N75kzGOX0RowB0FBywdHKcLRLvoBlySlf5X4TpwrTpuKglHaeK/xOBfpenSdslZcGpCNfKjtK8nBSA7KxSx+HPSSkAxNihEUnUBYdNe5Dwo2MABnR7x/xUTASBfg167MJTY4tWNFYC8OG5trKBjKoES9UXNPF4A+WMgIUWBrPFmNHPlUAS24SfFlFe4QakteDifqcAsGBrN7JKsStKxCLqA8NlYfPf7MqDixeo1x+SsZUycAt+bQaXwBV0a/vdSu3oEOyyPLbXKzFKe2ytCparmWp5rMxaQtISJMK6Ia+sqjwat42kVErspCqXbJr1uYVp0XWUcALUd0mQSuvp/xWIdWSXSOnZLq/678XkrukqoOdMqGa0k1O+O+5dzeVCSik/Zc8mFS3ls/SbsO8iFvWHx4T9Wu3tAOpvK+ndq2lSjBWFa+SjP3xh79iWYi5KpUAnSI5G67IXCLMF44ZZKhCc7eNM/tyi+Thi7hgErGRcO165zjGB+cg5yVtxGJOVTZsQaRXs5y1o9Vu+S2SsvqQmrxo79Jeq3QSFqTZDes63kG2gi550cH+rJpnA/MukAW1OCK8cd85pM/EBdGclIYNa0ZYlGZdLx/m1UOcKoFxOfUExTMa0mBrnq9oo7BmIjlnAiXht7x6CM7InPtx2RXBjKb2SH19yx2bcSslM6TyHSpNhYt3RnTul7sm9amFwUoZgbTzbNDSPJvdvkSqzV3HkVCkFhByxsl6JeScucIq7MJF7ZE2eEFnJQcO3/nIr/MNKGmIM+cH+V05+VdM8eda5pZEAIcWrRDgnflnWkWTGqOIN1/873k0boCklQURRFqTQx4+W8Zt5QjT5DbxxVfgiEaD1QtXbsA28YrjfCyDxu9DSSOzj5zH13WvdORC+LgOq5//+Y933Svv9kFvhKO8hgi7rkdYM8op0vUWRLTuKl0SOcmfZ6ql9q5pua5GCLNw8a7XL3Uu5tl2a00F1X1yAIK3aSPpz/a4/EpwjiQ7FxyIS9B01mTlGSUZwjIXoIb1iaocf0i3M46yyQktbshPSqo2Dafm7grCMb/P0HI6SMkgcKSvDJZFQPPje6+NBiYXUjSs/k7swXt+uog3QcjZ276rCf/lULsidrKkBIgS4bI3nQpgUTdIcL9IeW7V1xyL1TXwvGkDpr0vlAqpBaOXj5MhFzSF35HMSr4vbFSLZUxZ1Z5XSIBAS/jsVkVfmB1iUnKJeUI3ntaBKy0laF/Ox/8rTRjSAOSX6Xw8AuIoEfNu84YBfsd14L0xil5orikoeQ7p7k6phE0dXC5hDeRALDsm5WoEvsIsxFVWM9AtJj35lU2QpHxbqlx9JPcvn2HGlwx4Xe443Jh+lWw2kry0fqB2CxomxvMLi3zmusw5S1QJg5T6XKJpkpvH4m0xsuQag9p68x9OFI/e4mtywFMnFu1DkrOGWuHCXuFznY9HxUn/LdiTrl+iZrkRCDrTyZEB15/dUKhJh8InABa8ntS2xQ0VNjP3LqOcw1DHr2Bzrn3PouFlzGe4pF1M39nKv9ekwS1SgTiv4Ql0++i8zOyiPYChOav4e0ZpZpYirR7RjDzSDbkXaMmAFI833HN6ADdTT+vL0vJNqjNjz2fCqYaQXbqCVptlmp0h5nb2LSHyeab5M8b+I8s9O7gB0/EAS3KKrwGD1BycmRibj75jb4U0qGAUF1cDSgcmcBOSjLvfLSnK8UrZYtcThiaIbwyBz+HLje4DJE6kDfJI/gBIJgec3gc1nTcMllZ79+E9jYcnp5+5cI+fdkgfxFXDHvCqJ4XYZ424+Y51j+aiFZAO/rhIACGiSKX0hLOBkumnz6XDrX0cMJLPVoKuufVkJJ2ncrJcrixe/lbl71VuIGGvsc4ywpUhieaILzESE+7phlUuSrXDkgHTZH3pO6nge63HqFhbOslRQDyS7mZhNSS3FrVpRaBJLapVDKdBt8bXdWz9h5pLeRZWk7yspz2Vo7ZTuEF8fcV6KMn5bCg9Kg/v1pGSEUr3BUFqDmsl1Dp/5Cc7lTCWpQxr1hPUPssHuDI0fhcA3Xyv+lqYmXrR81zyb40uQI7lTQ49VsPMOTXCKBaTRfLHcQaPknn53UZNUjiaJ95qzdDngOOXaL48x8YyF5Piv4j3StKUEMn0YzRORqVAxazsi4wKTdBkY0KLgnOPnP5byJBnrJiw22LkmhEOXXrHya9qa6jZFxpy+NAQH7DylmN4jANJJr7mFlN5W0nsJEXtZlK1p1i3kZ/rur0zvZiPo+xFNL+Ilc7zL+/yIHaTC8iWQyOOlGHQ9BN3eQQnKZoZeiJUr+7yAPDFAkrf8dM70G3pYgBV6L6djJ+j7dVvcZaTHMAPAktqfZZVn8J5CbfocIl8qxbwm95u/PFZOj3fOT9HHcSXSPgejnWHjP74uk1y5nKVjMdehEvhWLBR/BEp7uSCz4t5hm8vgPQGAvBnl/Hwwwm7C9HfJyH+9MpDiANjMWCQbwI1haBNcTdINhZI0wJGAtQtVJ5+i8orkrveEOB7b06eeg+9w7i4SrMPYo9g+YEmL8bpWTSu6W11DQNhGCxk2CMPbh/ped4b1NP/+Z8pXu2GUZYlcDk3WYHznneSTiDTAHqKlisS9BZ9jJIx/PzZ+3535/R77/tXR4eDl+jzdG/n+HsMCK5T7nrfvzx6cwzv9w/fDPbQl5O9Z0eHu6RIge+8/X7ntxe/7Ry82QtIuer7ztvy++HOK/z55nB/gD5x9XO489Mjd2t45Ar6ElbIwQo5WCGFFVJYIYWVxwiPIx4YybKQejje2oDTO41ODgMcAuj46fC/p4PHzMvupIXRAyPBjAPJYkrWXRmcPOwdEY+wzVW5XoCs9GVKbtLa8yz+dxvASbyjUKRszdiSVAG0EVTHD9cf5n4XvgV99q18tMa+rLIvYVmafdnoP5zQQuW3IGTfNtiXtbIU+1KWCTgAlyWASwbgkgG4ZAAuGQBWGn3523uC6Rs4865BML0VN/kk3hVyA1epDMVrsbBf4tmfdJuO5QloW9yqArtKIWO1o8EKQaUViPGpTJRNzum5RNnaS3b+ILfsoOHiS3bK1agaBLMLfbYYdqvS0oaUpeNL+HUV55zr/yyvsyJj0ROzIM8K79QD+L5gIZByw6mXIJphhkg6uYIM3UCuZk4gNTnrjDA7Cd4AcDc3QIY5pP/XtsPvG2U+7lVMK18sWis2sNXMBpCxj6VMZ+WRqwhSoKiSh05WfIA/iPPitqWiqSFN1/xdcln7yO96/hP8z2P4F//zC/nXp/0/T6cFzGaH7huK0kF8bmmchlYMsn8H7m4mIvRphljXO8EVvFcD8vBZOkEdOommuffqhD2aI20hQ1raFXnwIsqiCVIj6K84zS6SiPx4GY8/xpAhivzcn8yiYUG+D6LLdEKfwzXoOQD0jtGzKX2YxWdzpBYWZctIbR5F06gU9GShe4308QTU6S+zrpqa0/FRH1il3wvoR8g+V31hBHDY/2U6r2lJ1++djxdkr5BDj18hzZv7FV2zX3QQeNMoLoll95FqGE9HueZCEvkikupWhZS/kiSfowod8oi/QkNzJ1xNonFD7RmjJ2i1QCtDOd7TqE+VAf5Zp7/iUDPQ1QyEmtVG/I9JMpXvKuHfRmAxC/qm95BEBNHuFS5WHakq5bCPZaDcwBLHU1uFsKpwHI8MJUEY0RFD8mle6jHR44X9rpC5uEvOd7u4yxbMoHE9dwAfLAKemnJekcvpOLNJb7d609vdP3l9sHO6bSLAme5+Gy7pt6HC4DIZfpiS4I/QVLJMr/lMop7rDTxmYKERWL9f/WMCVvC9Xzez7sksxmpMwBeJxOsT83Kiic95QjPJAs97L9Ms+QRJYMY74+Ri+jrNe8/2Dgd7x5UTIy73GwihIVfq6dFgcPQKn8RS9vDJhtHvKrhAZYJws/pnxakIx4ciVvvk78qKDRHBXxQRxht/uDKwqEQXaA9fyVyS4rG6MM1ShPeCLe/qkS4ENSw5zNF2oStaV+gRibhj5PZp/JmL5DyqbAUNq414XAit0sOwPC6qKqbhaTKFCDmvlAr2ZFxkHVZTZ2nA1OfhwtcmkeJOEF+DjsrAnswnk8gGnSpL1eRyayOL965n0XQUj2oHoE1upsNEO/m2daRyyU92miLdbDYflpbecyS0iTk59i7wgiim+FIa0uuoSjE+05cKQ4gPIHMt/siuJtUDs+mJ8hVdDgLkorw0Xd251Y3NcKe396vnT9Np7Hs/m2riW4zO0W5rOhpzd3axDiU5gXQcR6Oj6fjGsT+9JGc1bIyC2OzfLjPag4J+PaT2JjWBt0QWQQXWPsYIHL88i8ZjMzByFaWI9Xro1k2b2Vqr2chZKeUyoSnJiKV/+O95QnMrA4h5PB3e9OCaBNuxkmG2AwBX/iNcTRusWDrXQNQk+VPh5QI89dJTGV/lls/O3uVO33cE1h6H8z10IevL9MqbRNMbbwRH1DnNHxmds1TbIwRuEo29WYpI6tqyA9sajSFG3tU1Vcs3ZUkDq1SQ7PzC7/X1yUpNG34nQUjzkkM9L/AbwG5HlElAmXxqC1573C1j1oXDdwhWyYkfnGWPqsa6kAcezi3h5STN4p5JJxFarmU7obSB9USIdvaTTUiNWDBozIKh3wB2+ywYtMyCwW2xYNCIBcMWWTBoxIKBAwsGDVgwMLKgaGizM94rtCWfzCcEkl8Lqp6E1A6dgQJeD8/tQgy+j+yaIOz4fHbDbWWE1sSGDNc7CGV48ki1dTc7yGbeelJE1zWkiK5dSQGg2iQF7prb3STXS5Eiuq4nRXRtIgWqXUMKbCyvJUVlWrdTBN9M5SH6PkSAfVeILRJG6KjTBgF6DHQApnzoTcrTHiNJqiZqKVMVNRCIg2Wnk3C2UUsucsJRK8e8Z/qrnTSQWiRR2TkX8pDDBLzI8DLNSBwCvJYwpJiBKBSGnSDlIZIbMcJaSeZKjLB9YoTNicFLNTsxQjdihDZihC7ECF2IAQd0dlK8mSaFh4/X/HpA9ZQAQLkDpMVUR3VkbrcwTAvibUjwwAycGHsP4fR9DvckjJJhVEgsKTVYS1soZKAsrm+nKz1OdVHa6OlovcyDqVZPXh5iG0Tm4S1NamG4ixKcLtLMt8GsCtKmXDRCWtSsGDJYtfphddhdS3zu7NpOfRbHANes+c4QHfZgcPDu3kMXggFIHASboc/8MprFJgJxsGspxJU1kIiHZqeR6DFQS6Szdi6dNEFsgUhnja+fxETiL580LoRndRdL6ssaiHRmv2TS6JDhSKTSHcOJUJX7g98IdGsU47vrQrXK24Re2ziqyGinX1nTkYZleSsdK6gutOR9ZerpKTnNNLtpV2fStQJvg6Rqj91nYtX/iywaJdXlr4F5Ykrt1VNWqmAirQy3hraqd1NT4oYNiRv6zYC3T9ywHeKGrsQNmxI3dCNu2Iy4TtuUwk0GY9RUErjzw4pdChetyt+iDcnbxS4/cTZEFCUBVNVlvUDouVE1LZzFcVEjiAtHEVw0Eb7M5a9+459jz8Ba4lUAW6Ad1zsH0v3IrJikq/zCaaYeqvMAbbjo/fXo7ySmIZPjZIL22H4Rj2O4JxnfEhfj4/a896PZEIo77GINxQXNJlECp9Yuyhw2BUrv59Xhwk6eJxdTtUvfdZo5xqzYCKV4iNr5iQtTtC/fGrj1bFVBz5sCX3rTq0OEk9EK37mXfMI2dwjd9Ga4vkmsKO3oOU4pZuA3FZyG8XRuwLUCRnGZdeaM0G8I9/Y4I7gFzgi+EGcEbpwROHJG4MIZkmpIY235hBLfbGDKFws44bGlCzkR3+uCToQSc3DZjgB1sne/UAzU1jkLJw/6DuVOkk+xa9kjxODZMdaXaLXtLYdqxtALQ/m62A5DteethsUIjeTzM757JJJ53a04xZRjaR5XgWt/GqBritSNcSxVkUKNtBWmBZoGUr3dKPvgXNdtZKTKAc7lBbNsu+9UFPY7wXpNUXbReV25V5Va1u+t26ekC8+tdXmEvciiG1e2w4ckt9uGWziVpgpPTzOSlg+psoFbIKhKAPcpRQOowqHwm9/RMx7HCMZ6JTWqML4aqIEdKoDcqsCexvhKEDvI0A4SwAX9CiaamSt3IgyMlboPA7sPA7sPA7OGgX2Znf99jNl9jBnEmMlBKVw6svvws/vws79G+JkvY9y/k1FhXyYI7huNPbuPKrqPKrqPKrqPKvoLRhXJdual4opUYPVkJImPwRxpOpnRdPG24ovkpgzJvKRSPLEUCBoiaWz7LsRZMtJIBdY+cW414khuyoU4YlCLAqGWOJZQFsP5ioPj/jku6LtDbJ1QQned/JtA/pEk1WdAr48J2uwSWpUprM9iJBHhA/aJlKSQahoXiUBlzL08mczGcVb11EMb8g+5hdBVVx3oXRU2kp2DV0d94dDMgQmqM5W6iYrmfIWBvIhndQTjQbfODUK/3bzd0A4jQ8o1ULu4imNEjKsUH9DGwzn2rZmIY8RUNhO56oEDkavCRiJz8OqILBx5NiIynMw1IzQc5XV+WPGbtXCL9KZDcJPYKkHJiCrvqq7gW4VdrzTucZa+NKI+VHDgAAzXnQvoeWsjTpAOthsxBUFQI7ZQmrtFDlGHtjCzpACKjbclppG614h/pLoOrCS35s5VqutDIwZzDHeQ0F66gvoLtHOLPNU0GkLLTYbB1bTYiEG0sRG1LbgzRX2chM3DpRErGEKV7PBvkQWahDBpya+JZbI11YjuSlyTFbI7ve0xTha3pEakPteGjVqh3yKhl4kmtWPEOaZ0nsfEWFPhaBydyT6UlsYaMY8cW2qD68461jjTGl+zGmvi/OwBLyfmtdyja6F1DtIOo1HWtVwYWOenYIWKjtoty9xpz6L20IFP1EpGXtHAr+MXrZ9hU56p12BFlnHc1WjauF2maaCuigNqa2uj9KYpf1i1UhV6I+5w10L1/qVNOMRVDzW1dLt80lQb1TGLgzKqb7MpS9SrpIZ2GjFHQ8VUdSdutuTUq6a6Fm57yXFXUHUcUaefqo01Xz1sWqoGfsPVw1lX5XzC7XQ/xAWdCC7ArKc0gdwEphNhaYfPk/EYbNp1NOUacCAmV9pIRR5iHflE1/wGdKtc8x3Jhys0IiPfRMvUFHrfgKjCMByIWrXTgLZVpVoSc/BdKS3EVDQluONKLmHLdSk3NXUbxF86ucZUGKMjKzRZwvUV3VjCfQk3hss4swaNm3HiCLxbctT9JeitMkHVZxfak9IS4WdRVpAs3NjDNeVUBhz5/0NdwL+5W87MQcvX8ASD6sYKVRhUQw4InTjgPE2LRTggvBUOCJfmALgO+Va4IGzIBaETF4SNuCBswgU40s2JB65wTJwr/SncVqnP+upCexLBJ5B+YdJiWM6ExaVryEoguhGVxSI6k/SVU6aPUrZzCT/8ZuBbJe6rZhlAaPeFRCAaAnfQ+B5MkunKMmk/LL115opXmjQgNrhuvPHKkBbE4grklnD0IJnGhqyUBpD1zDCAlAZodxXnzkBbOEzgBt3sGIHed1+wXnsjXP8MlgwAWuPH5HaYwIrafZhcDhC4GGMXO04ZL1xjvyHJV13ZgQfbAu14cC3ylzD4JZkCOy96BKLFBFS26GL6KQubTT4VvFpTDx8Z7sAZLWXGNMNcNFuUpZctZMc0QXeglyFDphFiHcVcsmTaouyXzpNpB94i/W4tV6atLWeK1u/eHTJm1qRDcKFu61kza8C3Q+AvkTnT2qILnS3ZM+2wayntmkHTmrNi+RyaNeBvg9S3k0fT2mJzUoeupA6bktpx903yidgJDGk7aucvA1RPSgCXO0JrQXkrR+jCDGSoYJxBiCjizKJLEbgOJCcFjYSmcOrIWyZ+cSVq4EDU0HcD1CJRg/aIGjQhauhO1MCVqIGdqIEbUYMGRA3bImrYKlHD9oga3hJRQ1eihnaihm5EdRS/raYxrYO8ZLrKOvAtcMCtJjO1t7RAOtMagEslNLXCXiqlaR3k2+SS4Fa4JPhiXLJIatMagAsnN5WSqZUZTeW8pZNk2gXzepcotGJTH5M8AWw8Jum9+JQ1JEqYxhqXD3F0Ko1xZQ+H1EQw5E0POFUNSX6kRxpr+teqvV6RniDiTS9QjZ88v4fTjZQN829/xtfWACFHKgtSyPZJ8hspZKndUj6kqjfOyxqukoyT4kbcfFBQVnzyrMfKa3isIrxe/iwbl09C8dvBoHsAPsbexNgzY3i9FFFvCKK3xc0vGypPouNbwpdzTDzBl7Fnxoh3KcjdENduC2Uf1ht2DRf/DRsYW/H4VMvw0GxRHcrm06HJVjpUDaNi2ulWBPSVLgNsWoX2KRmN7yX6vUS/l+j3Ev1eorch0bleckLXPsojPuhc680ignIeNh/NbrsfiAsVEk/VuHb1uOIK8Bjj62nwJi5Heuxd1ft3/cvs2HXVwOMKo4p4iS2EpCuzl9WV7FJ1ZfKfulKdpahyICVEN2oFkJm3i30dqV6ABlNE42TY9c7S8UhsDicHfsylDCaPcxJxldOgLuPqzl6QBtAb8oV/BW2iF/DBEDCoFm8NrnCX0JLvVSs+9INb8p31imagMMNAFTu3YU8EKOYbKlsTVULEM4B1TlPJAW5pTaBDdIo/AATSo2olVnuqwU6Fd57bcUkNs1Pu00/8vDa2E1MCivmGyi0hLG8QnQkTx4Sw3BhXmUvRk7khRpLOy1dRcdnDJ3adoN/3/unRog/ZvSpN11eMyeHyiyzx+eDG3/vSiy0RQPbR7uMyvrmuy1D383KQXl7cIP2ZVP9VHDJ5qB9zJSzZoGlpzahLCasfNojXOreZsWZ/ROstNmCoLA0XHukHyy8AOSupGShdL9T1b5RcABLoGL/ZW5lmWTxEGy68gPv9HjmN+Zq3N5073LmytqW5FcR86wpNqGe5EUW5dcVQJbRUucw+4esmJjEewOmuwCC9l9zr3vH+i5cDU+Wjc2BI1VRydH4M68crvNcD/IzSOdooH0bTzuF8coZIfhgdrhgq4Q1Pw0r2u4ruLzW5v9Tk/lKT+0tN7i81+atfakIXy/trTdq/ReTOXZJyf63J/bUmf4FrTcptkZ23X7NiviOw9tib72Gj5G5445p7+SXSoLzovMDBKxCNN0wm0ZiEcfdcm3ZglxJHi/BM2VQt45QlDbxSQbIzDL8hbnT1yP3tN/e339zffnN/+81f5PYbZiE7r4151sc5i/VdAqdw+TpAi7GTNBi3cCtcRT1W4WHpaXcuhSILNTS0ObcFG5uMm8uHNZoht0CtheMZCdadQxpN7ekpYyqto5ZLDKPF8tyImi1ELpoht0/NsDVqhk7UDBtRM3SgZtiAmmEtNXnrvp2SL7NPaGVmpwiTuLhMR74j3BboKHXUbV/BrNf2juua0JONL6EjlQBBQybpIMadNPjgpQl90nOo4TcB3jKRWJcXphQZguhf1PMOU5q5x7u6jKfe8DJFeznvUgcA6TjktKKW2riv9STHxeroTmDVEJ8dpNk5QDhZW8qz1ACxnuS4rAfpB7N07AzXhej/7zjGPtxehpsQHFB7cD5BNgMXaZx74B6XJyNwLyN1SCXqtkVuMCM0S7FzIDhWZLTn4KrRO4jR7sA7G0fTDwD6Jp17o3T6I2IimiFqFJ9Djpd8Prz0IlK35/0/Hd8IQzX6+FVFdPwiwtD7+wlnqs58sqRHrQHibfCJq7/tfwGfmDyChSI1fKL3FpaP0V35xCHpjwY97oBvgWGaZQDChkRKdVgnCJMk+L6qclh6DU5qso50SjYgExwr+ew5gBjIVmOZLUCXDFC1QF5uE3yrwcvGRhaIWzbDWipk2QR2qWhlC9Bb4oOgbT4IvgQfLBKZbIa1cFAybwMzurYn01F8LXnEEhNrE2c8DAXV6Ose4k+bgzmccw/LQ27SKnFiQQNAgn+Ejwg7HFTaOPimoIqo3RXqOsJtQKrwterx3tQQ1Obi88HZXL3iZhaboSxhZGYgHA6loD/NfN4buUsQM3DOndfSsXd2PsZZBMoSU7HAFize6DyHWAAPcRxsy4o4Q4/FUBKbz4TEAYLXUEX+0rFb4zkhwMmNcLqe4RR1yJjOzhGDGI2vZFDfBmYJluCgWLkCDxK61IwpOPAtOejw2HPnNPT24gInYtThs3zqxDJmoVH5wrMS9YyjhSbzjujiRiBY5aoaygrwHBjuN/2OjFZfgtFYB1xohjtBj4hiT6CgGFQL5ZxohiEa6UXg1NNKgWKZ42gVmo4gjW0N0iljRkPTLOcALTXP+Q65EOH/RB8jUszLp8lshiDF13CfHclKewNXdpxl6VWOeh9HaCNaJJMYE4ycnKJdDqUZJMqGPewwmkJSWxqWAHID5DjSJhJYOPOfve9P9g5Pjo5/2zl4s/d91/v+zeH+AD5f/mt3fxe+YOdd9Pns6HB3f7B/dAg/Bsf7L17sHcPX3Z3BzuD0NS5zePSv73ve3nUEt8J7P3u/FMUT3LPOj/+Ksik0TeChSSM0/N2PK49+eYhK97xT2ushuOl54/Qih9032nuP8A6O7M0zOuBhirb8V6ly5TyHekf5gstDtl+LhKlgusgYLUQj945i0Bad+BYX9U0QlmBY1genW1ypqoDr4FjQPAYZnHeFCxkxmXKcmH36AdE1i8+RynnjwZHzJPoA9pQsxpx6ha0twyxGOw9KXaSyQ2VRR4f2nGi6i0uaqEng1NNRgSJSkKrmaKHNipM4S2KjYj6Kz6P5uHimpKEoncbBRR8hR/BeJxr3g6DdOBtQKGTtvuAy1ob8i3F8EU8h3sj3dYGu+kCMm53rJN/X7SK+RvwO6ytPA+cI2dv1Y/V+8jpm91u0USYiDMEGuL73wDt6/vxg/3DPL9l5f5oUJByri/gAQd9X9oA8j+HvGiarqjo5GNuc/u0hE+qkaxw3UXX8LxhA8SViHNLZzSAdRNmFejpWpr75lsMDLrJodvnfGxwAPCpN/O/I6sIMK0vO7vajCpZy4scu1F/Y836pOXLvvP8Xc94HHIOR0YmlobDvBu1W7Iralpbid274Tjd7IWX0kvAlLMVUgKM1hNnV0YY4nfKSHE7LYVMBp6FQDu2kkzG29sP0wlAYuSDU/Zfg5SeTpyvrq5m1AJsGDiorG7iIqt5usrrUHVrSkmwaRIa2bxmsj04cWpa2sikHsx3JywG8FdnJwV+K3XlkuvA7Ocd4CNyNeZa30pew2MVEo/hjMgS+fnCWRtkIlxqnYBpoJK513W0iTblKhrlQlXAWqXIVBcmF2w04A/PFtkXDC2nwvVhlJdEaUdgvnCl0t8sUtqtkitp7Y8h23D76A1zGN9d1Ug4u06ygF6KRdFo0aQ3eKEqIIJD1WCDveBTQ0prxl8aGr5kHD1Ncc3/UF8jNU9lNapZ2XNB9Refh2rB36kWooG+v73Tgfpmmeexd4YWcQCXCC0TaFdoze2eIk4bRGK3kRSriuWpMj+zqPY9xrpYG7YJB6r8+hu4+NO2/NTTtPuKrNLqTVU7OY2M0wIstxcRzRJfKOf0YZ+Nopns1S+kO+THfeu81fazmUHLJHLVpyGezGrL/V8x5pM4upIxIFYx+v+thQOwfsaJwA6EpgRQpxWslwlHELBphzRQ9Foz8H2laoFdIfcZuzOLrymnfUKDIoiG5FPl5BMRj7ToZ7Blpf638g+wZsGkFuzQwuhqVtVuyd1a9cdTS5uMRXlqp7oQd2/DqiqPpEfKmqRgPQluwYo+fway8ZsJW08iQ2JfMpRqHY1LIt9R2Ujkisj8iCGCzuLQRYCHYBXzkBGdXMYjCcTJMivENPY2cIb7DkjEpfhXT+xJwBp9g8lJI60vL63x/S/mixxkTMjVpHmgp31bfBW0MEFPveTYSgDO4ehywtzwSyhoaLHCiVI+GRYN4l4m5bRBre8DPNrTOFGi+5zjyVlSf3UNuFwq1pfK/YSymb4HTePBnEnQp3eWFxZmevhSSXl4Yneartc6U4XOBa411uGh88bCID+MFxLV3DhuuGa65WdjlMmFpIV/6/mAV3qJ4KrSmGgm+DV1aK4tc34i2eosLVXJqxDHVhHxLdcfwY+xbUHnRlCsaxRfo7tVDJnlESU2aNAhq8lKQ07S8TkyXGp4eOaKmV3OJCC2L1lqs9fn10JxcFxnYkRPucKKheYYFFhqZiDmxA4arQ4QyglOjWFt3kYisGOuxKivINQHAVQysEbMaiO2xoxWlcsuGaFupFI9WBYIuxlbdUuhRK28tHKyJ3j4a1jCCfQip47tAdUEv3d2gHQNYwZCiPYbzBmphpetTwhpn+bHoMYBRT5P7YrBNS6UEE7UMQWepVrdoutuaTOlmjdt0FiwNXk1d72NWcL9IYPhpl2nXXRzKQ949JcoB/VGtiOQB6FCQeJ78AsWxfNmGXQBHFD3GISXxz+ATe/r9w+9fHR0OXqLP072d4+99cduMkDFAdfDYOJclbE0oX9CUu0pNlrZZrmhM2qszYRxhXL6V3fNwA79l+p4p2X4HR6/NsE9l2C7GkCBsYA3BH3fSHLLOne3ezMBTkHEqHO76SE7icOKRL/jjMD5iZRUgdAJYYahEoLVUaJShbdAqpuc2uQIUbuJZIVWk4Wqo0MSZa4co0EyqqUDmRYAVLL6UgV4jwVdSIApipB4kO/kRqilAeYlnp7M0U/mKClReqtZD5QQMX/HeAldjgaviOP8rrXAtoXcxq56CW97AR72CPLgenDfxye8wQf49j+NPROGSjH6lcvvVbH8g+etCxtAS4ZsqOmBU8A+pFDRBg0TADFojeiNoilBSpx2Shcy0oebVH4fhltlz/HpYrnlncQ+TnGQNgnAp4IUce96Ab403mY+L5AG43+ekLLga9aRtNt+2abfNlxE33UJt7d5bUhMt6GQi247Nt57FbCyCaWmyy51zOr6Up/rb0pKs4p/BtqCfFVGwX9Y1IZ9bCO22eqpN12H/yJCcSwXjgqeKmlTFw3FYP3heh4mZCcTHAeOuaC35tDm7QZ8W0tn1WX2Leb/aZliYl2kxdb4pNcxbgWmTebnOLcS8pxbmZbAtzMuKKMxb1jUxL68bOjDvaR323Zj31DU8ox3mPXVh3lMz857WM+/pt3pEhTftajLY+xOp+xOp+xMpYY7cH0V9q0dRtYbmF9j3Q7780GKY/t97w8S9YaItwwT2PJItEsQd6d4UYTJF4Cl72/YIKjhwTFaG9IU4a9WJFGYXTghxSC5w1hYYJJP4pIgm2jMlcFd7zV38ou9pb5cv1nt9vPds/2T/6PCPw6OD/Vf7A/ECUdQXuFtHusfzEhKVxAfx9ALfqx6u36YH650/s6G4QojCvsflKogK9O8t4DULDXY0LwiXyotM72utMsJcrPH5R0W9E3L8PjZEUcnglkERwMJPcc9/zNnRP2lbxJjQriEFDl9ESKon1NWlvZHklRmTpdBywCSUzaGsXwuqVSwWrF0Vg2WbZgyWRWQMVnUNGOQFuiGRKy+uF77ITYbiZJjyrqIb0DTGySQpCAKri8VAA4kjSNF1Ph+z+9hYwCmHaykbE98Pw4UXfBEhA5NQV3e1hbQAmjLjkkWtzlsa6RjeLi3r26A4bY0w8jBMVhObr2bJtZpUlrw3XQdC3oqpY2kN7XUf5RJu8Bzj1vIarzFc0oODbr8OjAtO8Ik59SEn1YWN46hCGds2ksgq1YGJb9zgLcaVEDzF+Jo6LzFR0/kmrXq7vOQbR2fUxHf3vc6XNfH9VrGL9+1a99ow7vGY4EwxdNbd2/mao+y/yvL3ZQx/5J4FGvfytdzPlW1aTcpvVrz0FfedQDplxKQZsxlkTiHoCpicpJCRFVAY8aviOUv4wWQ7UslAp+x5b1DxT3GWksC06XkyTYpYPwKl8wa1Qy4mpsaUYegUEc3+WLSudM7nU5KMUW+5CAlAYmcRrBh70/lkv4gnpbX2tHxCusBbZHCjXe9yPommGVp7YSvYxYwZJdM4q3Lo5PNZbCouNC8lyzH0vqfv8mP9UB7pRyqOEHeVNWmx6VBzjLahjq8U97tI+UfKfE5SRpqAB65gAwAY2IH1naH1Mbh+rw5gA4gMZL8WZhOgJVQebC1jyAzx6G+fVwwTwvvPf7yO0R75v59XVojJ8jD6mFxAQECrBkuq7AQ6Mxw2voXcPzr7XbhATbyaDEymOTf73nCe5WlmNCGiZpkRUUwnS+o91bUh9n97g/2/oqS4fUlyPMMCVZKld8q/6e28GRzx9a7hrXHM+G3dkJ0c6fsLGWXvrZsWo9OUkfjOmDbZrF3+Zl0OkgtWDitUuF57y1qwbs0Czd4ssGzOgjrUtHBNLQepLdSEWtSEVtSEGtSEFtSENVuywWJbMt8BXCM0abZcA5ct18C85RrUb7kGtVuur7a9rxjo6V103OEWXDteqnGQKt45XMNoQJMIdXEG4uAYUrVVBYSEbVw9Xdo2QcuwIeapK9so6BnH58XDLLm4LCweW8aWlkXZ0zqOUoqp6Htq5y6dymXJg8dUKJeUdeReR78WkAuW9nNupafgP6XpxIvmRTqJimTo4Y34ZZwlcDXLOdKvvAnabnofE6SSIXQUEAX9q5rUjnXEkteOFVFS25V1TdntOF1Uj1RR86zzVacp+4xSX4G2OAOKoPTIEcvw2JFqa9CjqNwW/DhMXIobgyAToDQT9zzgnoohy9ys3iuYMc5GYaux6FHI2wcAxfuqJyIKAr+Iy7OQha75VrxIinGs3KrSMEQa7wzV5HCiOxY0VO/I5RsrNnA3LmRAGIbBdQteCb5buKzOeYui6lvOE/UlWfI0EnPD2i8L7ZKdrJSnJMmTs3FckwMRGzp6L7NPZQLEg73ngsvZBGfiAHYepXME8DCadg7nk7M46x1Gh4I9ZYLvsXYqmhfxzLXs0GbaCcLN6p8V03VIgey39yJLtDa0C/TcakoKwSrD/lmRqxqNQg3tPaJUUB3uyiTLAFCRX+J1URA1m7PLmX5HP/iSqMn1qtkD0FxfZHE8VSEEBghQfasCcRpDFmO1emioDlWDflX/OB4JlSs2xjxuoCO9AUnOhFHxeVXA+9XA9N7PmhdlOlAnqxrrrLNVjVaoSbpECllqt2RVq3rTyKoWFQRxpUntV1HzoWCtKBNyMNHyuuRLJTfcicSLpx4ed8lnHdj/eQ89vANc+ZqpFyd1GafY7X8f9VeXTpzzSxHST3hwXbQPjj7G3tk4mn7AR57VtussvkS6nqwcT0xJpSZiHqmJPnXUxJItCi1KNZjg70n2DfUbYIIHtwAmIkPKdPRCwESkTZJOlmCD6ydac2s8PlEJzT6RVnTHAV7dwZus+fihqsGvE70R3DmhpM6Lk6gWX/P6ASoXnn2VCwi+/P0aO2Y7w1e4XoOpBQ7OzVDMtwFwXAevPFD+uCx3Hs460dWeLTHwZu9leCs7LuMaBp9lqgTp0VFqtHZ8YBgG1udBuGDkhQ4ZOptICViPi/I1j4yqjgYbvPpuRoejAQ0Pw2I+k0Etjhp9IwJ8M4a0FjWxrgFT9fa0O74z3/lipqKvcX0PHp0mhOUL3dRD9o32ccJuTncUzeo+i4r4Is3MHIAh5GYAi7FQ2XUXNJMxeLMoI475Ym8IKD2yyTse2bS0BtnlLtyC7MAB2aFvrLscsoOlkB00QXZoRXZgQXagIDswIjuwIzt0QPaqb6y7HLLDpZAdNkH2qhXZoQXZoYLs0IjsUGvGfBVljlG59F5vMGM7+7uxlK2+/JDlzCHNW7OxQphZFp+j/4kDLIR/PUunkOQZaqJfx+xtb+fpydHBm8GeNl/q9C0W18TIhc9lmJWhI8FM30yTa3jWoW6LiHArOiPfDbfL315fKN422A7r4213EZqky98Xi7htFmhcZ+Ok5OU44967rc4ON8EcbzLEfUGvNrfUA8tkHvDJ7MYHVsTB/n/+Z0quxCrz/tGXJ+kEQtUQB6I+5+RyWXLXHmKj4aUX5d73r3aO/+/e8WD/1d73Xe/7g70Xe4e7AXz9befgzR7+9uZwfxDo3obfe3Ex7PW8PfAFz5OPMeQDh0g6So+q7UlycUkSRVRpJBCfoMkG8ylHQio5T4bRFO6zyaGL0o7plvM6Fu2kdCy+TjbHwp7IsdDlcCxs6RuL2syNwvpRgzRU1CvL+nWgWpIlEtQlbrSTh9rQ85ZOBYBSGcyRoIrO8nSM6nr4TuJxVMD0KVLvPMlyGuNcxoL/6qH+xz9X5QjQ3LtKpz8WAG2URVdTbz4tkjG0imY6sNSwmMPlEgiWxDD8kExn3FwR8aybr6s98xZVC+7CaK3u0CtHRcvCcZVNHzneO9gZ7P+2Z07nRwA7sOWs9kSkgtVANpd0Rn+JY0dPnwiQAK9JBEgKaRMB0vq2RIClgibTQUunihi/OtEAqReuqqPo3OZ2YvVbVnCnTD+s+FZAja5cmUmXh9F5SsKScT5H9KK6ix3nN+p5v0MwGxz5pUWRTkQ3OftR143urOvGdth1U3va9XUSFlImv89VWKLiPkuhI4bK2lyIae8+ZaEpcnkiII8ln6BPWQSzEZVfMJj5jtvLKRM+/4KebG9dPdlEeBAgnUTj38Fn+7G3Ibj10Hckta9n9vkhWhVaOktvnqdHg8HRK9n+c7yE/QdS8J2jfRrnuU2aPZJe9E6eHR8dHNxFvzbw4KJ/vwmHNqr0M5c2xcjYYXxOo3ylekFtvVBbL6ytt6qtt1pbb01bb6223rq23nptvQ1tvY3aepvaepu19bZ81aeZm+B2gblPCnpQ0q8B42YURyJlHH9E2m1UeNEMrg8muT/RwpMV8xlaR3pIw72Ci9GYUgxRIQ9mKdLC0RqTx0hujaRFhuuIXpJyBXiBytfTyFVRDuoXHUEeuiHTlAheBuWCUCqHKaa4bTtJigGLcpwN0QodXcQ8PjE6MZZ7SIRANA5d+SNvvf8D3QJfQbzZbF5wsEuwWAdIRpD9RQLb85Dcyr1hhC0M7G6+C9jO5WALzACdLFvHOL244NQILVnJGK2EJUU0pKV1zcQtF7I74dP4VvZpLNKZ95Bu9L6qT6OwVi9vaztuaMvaybDBdkSERWmTyo0WrPgaMX4CFlIiWnCdXz3FAnVcb4E6NlmgjussUMc6C5SSM5nXVOpTOUNpjxX3XQC64PdfcICB0DZKvatLpPjj2ACQI9hef5bO8dssjoaXvPGcC7ZU8izzvTAnXOZLyZmXBQiGFMyS/vc1HQ/f3jse/hUdD9mdxPduhxIq7p0OTYi5dzn8i7kcLoaZRg6LdPX5ei6LzDJQF/BBrQOW+othq6pf7x5GepHbOuF2ATneFFFbqMHVi4E0RZaQt2J4Ca2hjTEp7S9WMgROZAh9S/2lyBC0QQZXx8YTbBRwo0NgpUOgoUNgoUNQR4fQiQ6rvqX+UnQI26CDq88jWmAyRzKEVjKEGjKEFjKEdWRYdSLDmm+pvxQZVtsgw6qrVErnWXHpRodVKx1WNXRYtdBhtY4Oa050WPct9Zeiw1obdFhzXh1cqbBmpcKahgprFiqs1VFh3YkKG76l/lJUWG+DCuuui0Ny7UqGdSsZ1jVkWLeQYb2ODBtOZNj0LfWXIsNGG2TYcF6jP8ZTV0JsWAmxoSHEhoUQG3WE2HQixJZvqb8UITbbIMSmq79njK12TnTYtNJhU0OHTQsdNrWH1Pi6sudpNnmdpTPYJ8e5ct8gvemMK6HmYkkKSP7b9dIrLm81yVpNHvHHZ7jRP8htQews89lllBX4Ep8OPTgdQLR0aqwYGCvupqOLOHs6nsfGyqGx8kkcqWlA+Kqrxqov0vFIV+0yvTpGOnI2ikf4/gvNITUpqY1RoJlJohtTeeNBNS1Umxu5X/2zYqyvy5CMq6/1q3801bMYouGP5zh1BbBQmsEMica94/JN7/n+271dte41F1gie1N0NG3d7FxXDCUnEoKEL2WSKU29wFQv0J3acxVDU8XQXJHs5sn9rfzJv3yhp26UoyrLNpcAXM27ratbpQYkNXXpuMV6kXjZaInemktL7UCCBYCAjAHOezsZw3hLmVMesO/n8PMEqd/DeCfPsS99KUHHcASHuO8gycHYdHT2ZzwsekjYHl1NqWDDy0/egcZou6xC7zzN9qLhZaczRUVWvMdPysT8ybmHH/bwOVf+L6R0dnzc+ZzKC3+lSuNP+gEsDa28g4rvey/iAl/wgVvuetP5eEzbZw1818l71dj+yPFHeWqcnnuHqM7pSTzN02xlpayqrH7sZgD0L22BFijlkbC0CWK6xrRPbn7TGJYkIPUrLRaRZKR5LbjXWbx3PYumSLTWQtbqAGZ4S8FZTCGREe5uBMOnhaRiF05fI5y1LfMmaRaLZwBCG3oFQyjCaxliXY2qIa/Per1PKOXEV6FfB6RNvgraoF9D69liBAzqCRiYCBi0Q8DQiYCrfh2QNgkYtkHAZma3xegX1tMvNNEvrKNf6ES/VSf6rfl1QNqk32ob9Gtor1uMgKv1BFw1EXC1joCrdQSUNhZ2SkKcKOf0BV99Z8D11MU1GwBMZzeDdBBlF6pzmVUbUcfs5v79AZ/8Mt+ZcRoRT/ocK0251h3O2zmH2ypHOHYaPFyARN55HCGYcde7Sedo333jXUVT6p9DPCkImnE27SuwQcIT7KvzYDhGOzUC/xrt2ePpXMtZ0hCtLCaV1fCaDE1gOtAurXvV7ygLVjpszdaWizHjwGMbAJgZACDWcDmdWCzRk4EOcTjoqLMiqbB6Bmnp4gMNsCXnQPPQomfR9GOUUw8vrUOHAtnGK4Y4IxWGUSy5xBxpLRPLXtJhANoKRZq6lEhUKXttpkyNW4m2qIlCVjcTk1XISqnWLuGR4S1LnWZ3+jx1vclHhG4lieZWH6m2mQh1N/yIxrXl7/mR4bWD/XBp7IcW7IcO2A+N2A9rsV+nAVe2yXq3K5zU0yiaeEhLYl7olKt39nnZQ+88uY5H4Ac5SkH1uPHI+kk8i6+S6Si9gvBl0szoVw11qh7Y6FOVUinEQTDSSDAM26h0XR/JT9yvfDuAerq8fQjpS+M6QMvsTa4bpBIg11MouxENxa7NOQS4Aiqdrk25A0T7u406xOZec8sNhmNcMhiIZfDKYCxP5HJA7tY3kvTWadtIoNtIRUqotKI1jcQqDz9qqRW4UCv0a0AsTa2gNWo1tLU1JVdQS67AQK6ghlyBC7lCF3Kt+jUgliZX2Bq5mlnWmlIrrKVWaKBWWEOtOnWCO9RzcVj2cEnfBdgyxBMALambiCN0oSE54qQ3WoMNJfJGXEg8JFgZj3njG6QSqyU01w8btbliKsl5GEa6i+e0NuJzp7I117hz16T7LsCWIb4AaEniiyN0DtMZ3UyjSTKkUa04uU6OlNFkHHMXysPtAelH4A8IK6sMdU7cwHXMxg1cMZUbeBhGbhBP3m3cUJ6zO96i6NfDWZJ6HKRlGIofmBMLTGB+Q+4Q4vVB7a9g4yMWVdiYpOOYiYAC5zjBOQrx+9T79zwZfhjfsFsNYy+apOgNTmnmwh1lj228URZSOaOqb+QL3qvCxhWKL4WdOyrvCLPurAFZzygV4LwB3GXYRjdyJ2PbPC/SSfIJJ+DCVvMZlsWBhtBKG3qCK8VUkquQNKTXOcY0IX7gTPzQdwd5K8QP2iV+sCTxQwfiB27ED+qJH7gQP1CcK//28KGXnv35MBtBts6H9NDnFZz5/Jlj18tn1aOTGDxBiQBxyBE0OIbswOlwDhH2vWEWI6LvjWP41fEHx0KuksHxOz/F3k6gePjvqe+RUKKH2wQ2RG+5bvVO9l7vHO8Mjo7/IEli+Vq7fwwjltfI2JddsS9lnV5e3IzjXpU/jh0q8K0nCAFPX5QHFiYgNDPVAVxA9djzV2fXvkPxY+yHK5QH36zLzDKcl8em4QzT8QliTlQ31BeIZjOkSD5Das+oc5lJUGCgjbAIFZxQSJt/eqFg8VjoEg94pb4YBVu63hXpSZFpMg34JWNLMaPDOc5HbT35neHUrzCMJH82TvMKPoMzSifGA9LBseDnzCFlv4gnT6M8Ns41OJjteoCKrsdGKiYDgHPclwnayAA8mFGZmN8UqbTZiJyHwmGnkDqI1ICPR7c2o//75qa+PNpGFPEJ5OWE0tP0Cklwf8G5BWfVuDA7oebPu9mcS6bTOHs5eHUAFysO02nb03LHgXA7At3KGkLf6DNxJpOe0fvaEb5wOiG6Ca1KFdHZPrkyUkgvV9ZP5wVOMI4RPo2FKwjQkv8hvhmlV9D/jugpi6ib4SiUXZLWvjrPx3VpvQ7zlv4swcX7RLw5VCDjMvh9BjlaakDMCzuEeaEHsLN0F3aW7gFxINFXjoZF8hFfqaAfPRa6+LbAjloZv9yfWuvSfhsqQ681tWEBGY32gO7gSQ2RJB2/RKTf1RB4xa36vFBrz4vayhiFZU2K0tpalDv5Fukj/Vx0GfOOfsj1QLiR7+gHrtc7RPArt6IN2JBIOZBHIn3kVlUiOXsmZNhjK69e/Wdvea2/rKFR87l1XNjamfQdGftYJMv3dxi1H1xbuhW2mtWl5oPryxuCHn0qqxpItU/z+GR+Bj/o+xLIfpW/rPTUqtcDjIqAsGIaW19M39gBPMQafcN5zZUglEjAgktAZkua0BLaAHQuiydINOzgbKBFlt5oSHXcIzryYTqK9WoLX6JHIPJz91iaeKTEQrLPVLuRrLdAqBf3leB07EitAHbrzs4ivXFZhrQVnYWouXadHMWJ0EjnNUJRr3Aqli8GQCfjNCBY1UoN5LgdKa3A4Ujy+DtZll7tAjtqpA0TlodwAQwXx6WD8WZmg/AaqaoJoqoFyh7WnVdsKphcI0fDjn3ZlbYSlJVKXPnl4rfVVhg2r/JUFwCJRcVl4bMRG7BB4zrm1rzswqsdiXPnZL9eQZteQj63vnK4LK+8Jn8H1xZX40n9LfbltnBEbNnAHNW+sP5ee6U+uwHmV8/HN5cJsOwmIUwLeNmJKu4EVo6kZZEj3c54zBgwHuexdWKajElKwLzO2ORgZIIv4zHQUwyg19mjhGzqtBbe95OvTlZKjX7JT33RyiUgsMI0F1HN1WQd0ukk5Vs7UtGcgq9IymY3dQh2Q25OZmktboUQXDMKxQT0BDZ6TL9pXspiVDHb/UEK6C2EqtFRTiKAehmBLG9k88M1lpNFPAj+2jAfB7345sL11j5Smtcz/H/8fXtjfe2RX78txZVdd9ZMH9NZVuCwmor4ciV1hVuk8+Eljg1XgZOFGJeI8944nl4Ul7AkB9LCrlh2VnTc9YlZ7WReYm9+8gKjloUng2KD02kKmFqyDiP3UO4bXuixrySvilh3OSIAQakQX41YxUfcSFSwRoGnJ3F12SZ9qE0dW811vNLxQLTDcKUROYviTLDw80b8mRQMzoCey43SkioI0mNUopfiBOvY/P6f/7DaHgLFvx6kM+Ethly+JTfwUapRx51OUmhpARjgZEYHBqQMlVwv8MAL1rvQEW/daJQgtJRsk80ll8vOn2uKs2QuLSXtSouFy60asA4jPIYR1XZjpEzFIxg62oR1FLnD25okcWMUdzbFlm9+CFkpxmIP+K6KWNYpANbjuTP08iT5FHe9FAn9Z1Sb6OIYiOfRJBnfiD2jo9Sl3SnnY9BH/4XGtVg+xFNWcrmA5QCQ7zR6zf/kigHsIiLdNq7mO08P9oQFvazFVtjqYgGf5er3LeXpNVOodDC79lD5ZOT9fasPf3xOybuZQdKRCt9Iz0NV0IyIz5NpPBI3xXIbXLXHHAxLr6AQEBxOH0Lvnx5jAO+ht7qC1s/nEPHSCVaQLPFFFUI/PjgwJAnr/b699PXJZTTCGpXvrSGMsP8BO9nFWdTpd/GfXn99xQZJkvvkZ6+yIiv3cqt8o+Hi6pYvnhtNl33xZcQ7v4Ta2qu/JG5XjD1fxupebdj44oJqUO1BuPmr3YXw8krYCOKWdBJM2SARSinWkOE4jjK4hiOdF3xJSTdS6fy5wo/YdDRUfBDqZGwJHtZ32hdxFYiESp+73nq/v6JnKxtL8QrQSNLhwC2zg3UVrLqgj1/k+TEElR2s00wBRqV++qlCJtF0yt2Stua75L3oEVEpMvHEoAryxjAJcI1NXVdQNa2XpUTlhurAdwU/4PJQGuJwbzmbXqIx0TEW0JvslGMx6F2GMwr6VDx+7SGT3sC/P5EBMn+Ln8oufuZZHZVkBEzyt6dHU6LXIs2Vlwff6dQp2aeJFL32nij95rT0f/wD6e6/2Er8pH/3L6xVo+o3xgZAz8cFfrEUMIAneSsrIiiZxT7fKY7mk6NZDEsCu7PJwLRxmd5uidWM7mzC4QRJ4cZPk3McPC3oqHcGmUi7EztMekc6LOAAG1FxRfIasVubAkY5nlHxOKOvhJX1bmMS3pbdVs52vHJIbrjSivW/ybDwDp8ogmIqFbw71y74Wokj6GbVOYiioNFZl+9dD+NZ0SktrKxZohLrFQ3yjtceaWmN7lhq2vJd54uo5C4HIDLcBc9BTGCsxyFU9XXUC++ENqY1hvAriGmzIzGTdN6Wxedopb4UFA9sxyD+x2QL3L5ojclWvAYdvBSgNXiPe7vLPS8oWGWZRaSRKrxC/rPhQxDdhmZAiVsxQxNVASytR6NyW1lz0AXInHDmFMivLC7bNDuqCY52pvOnAgx6j557iglQJ9LG+ILrT/4MLWVFzeRXuUUSjLz0G6WHaQHcH9+1nUALehNIPnWAnAjQ2vT59Utc83PSbpIfIWKCuBAXUOMSQ4s9qpiRFtDxo3I2qLPX62z0dqblcaZnYNZwy/yLbRA74/Ezmsuu5F5qv6/jLe+J12/IWv1FN+Hw/w6iDgsVEYU4FxklIZirUIu9EowefeVr/ihHOMgoN3zYXC2ZqhWhDRvenAt9kctzpwRQ9O/nI/ijKSi6b5CyAfzRlOWOOXDB4VocnJ/7gnGdMqTtQF3rrVDZ3KsFvN7+To7YHez1RsN71Ro74qKm8LN0dKOe+qpWFzMhFzQWKuJI8hDTGPm1IPkSpFcWZXVM4md4/bTe2A23Fz/2bqx1KkWrWr6x0YaeyZvNEA+URodZOh7XmiiqNsi9yp7FFmFoo9ZMUVGDjOMJzXtFPAlwN6xHFBTdnWvUAwrigQbEigm10DIdndg0taLY2iZU69xA0xTGAx0MQ+O607QlZnvLM7ycvhoHDNInmGOqpwSwSxFdTEmEqu8/Ej0ocBZZNs3A5oAHE0EO1+P5FGbp0RStPVmajLizzhIeg4A+LkAlF5wwaSnYzu0fvn4z8AWF3BjTxJ2l8uIHjMYX8duuR76crujT8lvwNDobG3xVoLvVwFG5+BkUfAo8kr+Zcd1YWaiTDp2zedHgd1Vg08qCAp2BcbO+PpIKcTY9ZZQrcn859fSzw3ICTPoJbkn5F5mtqNyAzTKk9fyeMCsG6dAnpOL3db3ldc3H3qf7ZeGOLQuvouKyN4mu4UKZr7dC8L1YdLFoR2Mhpxq/PPbWy9OF9RUlPpDz/tLlR8jinGzYcpYeoXoieILkkHZh6J389uIyjkZI6OR44cnxQT0Sw12vSIpxrJ5A/fhL/vHC864n42n+2L8sitnPDx9eXV31rlZ7aXbxMOz3+w9REZ+YQB/7PyJMAXD08aPvXWJMyk8hy/fT9Pqx3/f6XhBuefCP/+RHxVkCdwqvIqqbBH8m5f+CSz7xgZVxHXj2kD6swJbj1QH58RfURP7kl/NkDAnMk9FjH+0YPOim793Av+hd/CKa53kSTZ+O56jM9LFPcvPjLBjJ0EeYRru1jwm27zz2Q997+OSXhwQk+oJb+JHtovi2LyC71TQ/T7PJYx9/HYO/Xb+LULOCWhbe58NoHHeC7oNgxa/AyUdvFdGfp2mhpnlCGLp4Qv5HFHziS/XQQrWPVsYBNItV+eGNDAG6nYJfSAH46a3TzqhATrLhM7TfVevPIrhF4LE/8ba8cM07QB9rffSBvrPP9Q30iX6wT/wc/WCfuBr6wT63SDX6gf563u++h0gwfuz/fa1/fr7WBzJl6Yf4sX82RvOS/XxAeXirfAAx22g3+djHrmv+Q2V8oxjNldhxiMG6h/sIXw68YNsLt/HPtVX4ue6tw2P0DI8MPcS/0T/4PYxwm/zG1dfWMDD0LNjiBgjDW3yAyvjwyDCH48HxYgN9xpOkKNmj6DJqdzm0sNLgD9slR1EYlFHicDJNL65YTXla6+e0YV5tdB9swNwBuVT2j0iNC0FiiEPUtcF1WDtl1NleYaFRQ3LfaGtufSrZs6pfEakGhIbJ1UGJdGMSp0Y2YbEJgBfgLGmice23wLTCtA2JbAn6q9WXoL8J30L85RObfmNY7i6y6AY/QBh47M+zcefv50hQw0rAAS2hVp9BsOoDapC+gtYeBPBnOIx4ROfqzyXwR8J0/nltdv2In89/psn0ZzyfH4mznD7U9A0JtoXHjETO+Xm8jceHc1xcB4/9NTSSG/QZrqEVNKS/0SeqWcmmv8er8EeWTqFJOn3hFjalFjZbbyEISQvrAWkBIZk0AQ9abWFzW2oBHrTaAsaK0MTSeBLYcRN4b3XN26CL4hZ8bvbJ86Df97ZXGUfiI7yq5efPwU/ZvWVpKulH3ZeY41ZG3VxG4OV+WfmApMGKrESCVzPSfS/iuy2tXwGLYP0pwJ/o3/XQ2/HW+/CX/AnIwwMPf8OFt6tPXHy1D39RUfQHIKKHv/sC1ithDD8fMC2431vTy9dfcCq+ayqnHvsPVvuMXamKZtDvy1bTafEz2uePR4gXwM8clX4A2X/PHy3QoSdBuIo2SKhPouT/Yvijq0bJuISLfY7/XbqCtN8tUPRBRd4Me+uIwarG+8bGs3gkNty03VZQcBsT9zbZTGAaWUAcR1dwQnjndTm0XyQLxmb1heo1G410uR8XAKybAJJWs0mXFbqY4t/uq4qov2yIsPDvBWEFFNZaudzRjsGDBWFt9CVYG/2FYcHYBFjwwA3WEjTEM3ixCSwv9dvedoBbXKu+wP/YTgBfZPY5C+FPKT/+vnEOfxp2QOG77UDmO56+pA1XvmOwKr5zhaVIl2fp9Dy5mGd3XfvYonpp0A+9LbyEBKtAzx20QgVYS11bxwuIt7XhbQKdVxGr4ffrqCy8DeAterQKbIeKoIKa6ggmgD6AVqCxJbWTH+/kKC6y+ObWNdvd5CIpojHNKv0N2CLWMGkImsmXrW2yN0Cfi65e9WBtytsiso8pKuE2UVTWw4UVlbW+WVHxFILvTC/m4yi7w5uZYZINx7HnDRF6NpDMHN6QT0TDtX4TAtcAstqI16z2HYBCdv1UIcAP0Of2Wg1ckPAudgXMF+hzizawuqUaLlppYE1qYG2rpQa2t8QRwHrY6ghYA2tSA8uOwGQzX+turClnURmkdI87DzZxTC+8rsQKiPkD9D9IlAch+/VgXZYnRH5YhEloESYPn7BzLGWq742S4hvYkaxt4cV2q/qCN7XoDfpcwLa8tUnMRZvrZEu6semtwiq9EXob8Hx7FXayaNUN4RSJ7FnD7SV2PnUDaHvtaGOofJ9wRmxrj0J7jzSrzHh81zlvo49JdeCtIS2OnL1ugk1jldIx3ILV/wDKrcLndgi/KTIxfcEs24cnqDr6uygH3UpHRJ6L47X+arVZ2g62wn7QjOsUEg+yKL/zh1erqwR3aJZsr7ENJp4Z6/DCWboY1gQk9QNI42BYFALNovBgrY8XggerZGGgH/jpAsLuwTZZXrbJOMuP9WoNtAFDc7dcPppiTmSxLfizlFg7kM+2tkK6G6eqSRiUjTZphz/645thShxrhulwLTeztSE2s9Vvs5kvxphtU9uRhduxFxM/JIOadBJ9jO+6HAvBU8zbAW8ZZoPfgL/UNIfNC9U7KB1Q/6HqC15jtje5L/gVNrWhbyJ0VAbAEnUGtSG/XsNr0IIr3t0djcDlq+tbq6PqqOTvYbhxPtxamM9x90nvN9ahB+veenWQs9knsnWzL74Cg9HGOj3kRfXVubgJf6peDjfgT7MdBCf2N7DxA3WlX33Z6gv4ArMX9UZDn/wbVHsLSwuxi/E6/Fmii4DILB5ii8nGJraYwDaS7ueCNeZq6SGxuuWTWFMbJRt3QCs0DuN4FI/uuujYIjNrg02eIMTT7ZNnspnWOdwEfTOiyOT/2TL3Td2RuPr5zt5mpaLKvx16Iu+UnJqtXWPqmNSwHD/YWOui/1c8Ysrr99CE6aGfVYlwo98Ng3VxSf425KSApyV1gVuSkRI3LWBjuWUJuWQHl5WPSzZPtw/+bjr9EbLS4NCqIvVyJCR7viw682k0yy/Tb8E0tYr32ejL5hai4gb6Q3kx9LbWyI6dfG7B3gixZG9z3VvthevMBWN9DfPkAQCALzvkLS7HymzhjRXs5yk0mGfoi9AizFUEA+/2sR1AeIkqhMBvqF/hhvgKDwL4bUHj1n8RCgSW3+zDn2qBWduAPw0F1zNywoAPGNbJAcP6Oj5gCDd8eZJtba/H2xs1LW40tMLghAkLziTJCf32NzFBD5Fiq4cl42YvQKtxb5WQbGu7h/ecWz3glo1eSNbqLRCv6N1q+RDtantbrPhWH8HaWCsfo+rbrEIYMiCoqXWPAMePg4Wnw10agGJUPj+vWKvfX4u2woYGPj6ygOOwV+nHeJDiFN53ms/Y+oc9ctE8DMv1Dy1/ZShWuOZqY2Pwwr4Mb2speOsbGB647rD1eYMDuL3R3AgI8g3746FPrHesb5Sf2/C5tUW4bH2DmJDR53rYbPfujt7WObMBKW6v7e16srXfeBsk/sKCAqJ2vw050bagCPotS4rgFiTF9gZho23KPpth+blNdyyYjdBvzEab4eKS4muKCgdi3GLjX1lWLEzkLyYr9q5n0XT0jeitZRgu+tykspV9EifVzbD6shnS/Uv5ZZ3inn2Ga1zoLsjpjcU10lvvmcHaYyPu0Yc7Tdght2kTvcLW8aatsYOZARL1H+v3z8L+uS/7O5Mj/jVw4cBH+xshcc/YJua3bbJ1IGf+BocNGw2eR8k4Ht3TYYPz4wv6QSzSYW3V294mm6xNvPFaJ7/BTkEi7LbZ9qxP4tDR03CLbsu2SZx6SJ00aKA6rQFPtiAipzntdtNp8X+n6dU99TjqBWcRWtI5z9nVdTnEB6O2iefs9obsOftr6TdroE0yPU/v6VLSZTcdXcTZ0/E85kmz3r8F0iR1pHmWjqPZt2MMk1ZueV1uSyPQwG24nO+MRq+i7EOccZjFeaka4gqnDjZ8+L7NYRvzXF82qGK83MTjcXr1yJji47E/Qn3P4pHgdb9GFPQHa4uHB24o4YGQTSORMoLTTDzAt74Rr3ftEIQQo/Szxg5LAcYp778ESYtUJDtmWhE3LBv9apXFX7bwaabEqrQNwqzlXmuN7vOqvRZ0kG21VkPNKfcp5hmXzmsM7ntZlMcQ6zlOLy7uKu20Tl+r68zpy3RKvb7RDdfEI2g4CKYZMLbgrAerpGv45BlOWkIc4tuHh9t9Wmobu6LiE2TmtxqQY+w1+EtigjdwxiJ5y0muDZMovLWFKQxbdubAz1E4DJXg5oqyJBWCBth23wnYGSxsGmhfED+Kf4IS3KBGrhhSOFh84BATxsVvSXz1Os2KOy6PAhb1uk49KsmDkNima7GjzUDCIIXNAPF8gM/28UaAfRLn7JAeoYbUBQV9hltU2JVfiFNHQG23eLexpds4LE58kW03e2jns9mDvSe4jfQ3e3jHD+dbQbCGn29u9SCcMaSnVvhVfxWfd0ERCNRF5fAvALQV9EjMMByJbWyQc6w++tgIAMLaNnzFGb7Wvc0NAiZEMLfgcOt3zzpWwvZoADoFAWZ0RsK8BVmyMRxubZ5pZq/HO3Ns9uAcuwdn2yEOeyZnxmsbMPj+Vo/u9TSBHFvxaGN7S+2kZ+tlsKFRv2r6uAFeOzve+jaYCx6s0bPwbW+r7y8iHIzJ3Twh98oq7H138HFC4D0IyGH6NkSUtNmqNnhkF8/9e93om9ONSErkO7wBq99mrIXyNoNkSDHvLyjLs2UFswXeq9zQGAMSwwBwb2iUwdLwMX8J8CHKoB34N6z/LEaCBFWGtKFW4OP+C/Bx/5eDbzanFeTvnWfM8vyIKKmr3PnRVjVvgy3tGsK7GKwtV3+7v1B9EwEO0ovnyfhOxlhI4nxNzGq2ykJ11gSfSZub5NbsWsotsioBXd8QgDrC9PQB6GVyvrUWgLLFjAHd2moBKO3oWl9E6Vq/BZQyoAylFOiCKA1EoNv9FoBuSz0NgjagUqDrGyJOiYF3SZwyoAynFOhyOGVAt9oASju6GYqj3wxbGD0Dui4CXayj6xsiUOKTsCxUFrW4JQ5/a6uF4TOgjPgU6HLEZ0A3wxaAbm6JQIP+4l390ZhZfoxWrDSbsLTy9Kcupzxc7iBc882q/kFS6sMVeOJV32NyTXY0yen1VOh/cvvDa3haXQdCCvVmaZ5AOvXBzSzGF72Jr/GY0PMt75/qZQLeQ7Rv8J48UWqxcAC0ufynJvm/sR69ziBo1Bi5fCBs1hJJZP/Y86n2UN7foiAYI5FeoNEhtVeUwkN6qRkqLgEgvaGXnu0mH41V6VUK1QU10Lsh0j+yJM58l2pw3w1c1ING/E/uvpkLuAglGsPbZ2l8brx4wQw8/Rhn52OMDD+aF2lZQXdHYAkEJpXhYsCqKaQ2QShzR6z1Lnm/orvEWMYtmR5qVnwMMi+kS3i9x9XdLsMsjop4j1wr2fFfH+/5tEVUkA57gvabyXSA2QvtWfSvn7K7QYQSmOhw1QpchUlv+VCxy98tg2rRDtD78NTi+GY72mV8AaT3xAviVW7uK1X4S+DVt+dwAQZ+Kd8pQzA5i0YnaNNdIFR2PUJI6dK+vGC38/0iFQAgBCuQBb7Q3GNOHvLp/hFFBow3R5JiPkJ8XDxHou40jrKOzMQPoBU2wLLbHVzpFRruJS4W8NW6XmipimvuwrGFro5nrvMSzdhcW+lnc6VXyXRexE2qkXonMaLlKMeDo4DG4yQvnz7E/IGAPk+u41FnFQHdkKcLAs1PFdoQ+jw8GpyUTCPQBiQiwU2FDQRCBYxBqMCpaJjN88sOrSetbrzsMHI5KZTPxskQ7vLQSx7vAa7N859uHZWul5HFUzk6tJiLzSAef/devTuGJGzlV3nukW6lv0y46y3whUAcCHm111zRpCmuu7P4s0W3sLXYln4RGPSL7cX0i60FV/3j6ArETVSuZNqx25Z+oQK3/OvoYFABhKJAlHmOFVHzMrW7/5u/UlOdrk4M73jNPsvTMRIwvltVqoVVGgSj72iEZr9ZfbBDZRd1tQy2ZAWBfU8GO4M3Jwf7h3sv9/ZfvBwsqBDZmy6vBWt5SDNSfVBdqoUt9531WxkFbe2AEN1fb1rxmOK/QU2mT75VFMqWWpQ0rI4BrGEqxdM8zXK4QnCxqVjVbz4XlbrtTEYFbKabNaQYlCLi18JuqLUt4b3QrZWF+0U2c37oXoMx02kNMykV9ZIDdeAVVuxbmWwqK7jONlNNh+mmVD1Ls1GcabhoHxamp/itK6ho+OECiyN2q7MeplhsgUlatayfZSm+hXrxWcrVbzxL1bpMjVl0OrkylNpyO8uqCpdOxL57jS8wnzREc5xPxpr180mtWs4nPwAvTbi9xeMOgxZYk7g2KuMS3DyaWbr0av/Qwvr0amB7/V5B1HI/mc7mhV9TeHgZDz/EI34/YSlNcDUiqb9JG7Do+o49wo2dpde+UzOlxyG+5x771sKu1MhxEsOtuLVCTD6MZdpWzarWNNcYX0bTixjuMRauMRYhZPF5FqM9dWU7q5d9Zm5EHRF4EXH3lP2G7xbeO3m9c1ixHhQWLGL+/nQ4no9ib5JMk8l84n2MxvM49107CwBL6GeZpSNPj31nFJxltqI7v71YarKh+u6TDQpXk6268NhYeIG5xnfIZa5VzdzmXKta+RJzDVq7E3MNdWSl5bkVIb04uoi/hbn1auftcgvZztsGCxkq3GAhQ6UXWci4HjktZGUzt7qQla18kYUMtXY3FrKdt21Prkl0vfTCVVfYNu/aBYJturbTsQolM8amCCE74+QC75aGqBR/RomvG8YUfFpMqRn1bF4U6bTj0xeLM8BMODar2unR7gqj2ruepVmh9iLGz2s6QQrV96FsROlCHXVm+pJgmeZMys03tzyAxrtbTeVWjFAauO1sXjWAye61+UYUNbO+vFlL06HSVtxZM8OHi55v2Yit4wzHLbS5av0eWlPX0Qi8TKvWLTcP2DyLBhE5QDPNwcHO04M9v6b+QlOQr2l0wLDWorPWbMORKzArFriS/eBWpc5MJJc/q9wlXKtwri0K+z+n7xpwv9gbMOQ8S8c4tJs43OCvTaqfwP1vaPI2HVPl5VPF+TrMAWH107YhHHbrziMrtxnLqiuE79HnnD/NmBhe4ezb5AlEbbivoinah2ScOVTvFARH0N91jJXeJe+9BJN/GKfn3iG4gpzgtyuCYxHAJ54FFkha7yLJAD2Oh3S22gY5No6H2UwO01Es21FAn+Sf4V3LIw4RiffksdkWjz2BAC7zcuAxwNp0VnM90rz7FoxWMOy52FvDJou9rttVyY0o2ygRUGv7JhFs6xslBr7BzqhGNeYV04r6gpzATUqF6JbGlUW0cBkcrpyRZ+V6AKwOvtPu5bMXI/bSTwCHGYSkgToRyt5w5frvtQjUFQ3ei/KFzml+WqyYMEbFDpFhY0lcERAJTCr6Cry+/riMstFVlMX7o46weYUuChtYvtJ5liBEj28Oo0ncEdYM6tznLn68J7wcrISREQLvl2gsNI5U70QR5jGZC9S1Ju/oUSkvZ1/YrfHNNLkeJJMYtTmZDdKcyAWkdHKr6YjuT7FXHfzTezN41gm2N/tdD/0NGLeP0DJWoFfM8Q/tD8HNqQs+bkggwe8fqtLurpM84hZwn9RWd3ChNNercaM0V6x1pbQMtQ13Spklc5gYPKkHL23biZd7O7tM7OLST22lnx7tnvKlXx4HtuLHYtnQuSzOO1P6Ohr1PbMuRAFQxYxJoeE8A1Jwnpq1YqhSpHVCqG8QPVUto+CpitSLHa4wv1oNXmp0alPZpxx6c8S0oppEnkbXmqc7Hy/Up4jXL/H2sP9I786pHOJyAo20zp8yEXA//SR7zdqPqjiQpJMLguQs9HwvMTbqQA5eCmhGE4LiWXkRcgQYxuOxdVayyfD/t/eszW3jSH7Pr2C4dTvSRVZsJ9mdi+NkFVu2VWtbLknOY2dSLlqibcYSqSMpP+Ym99uvGy+iAZCiHGdvtu4ut2MRaDQar0Z3o9EAfAQNFhRZK+DYLMOx4qqqXSUHpbcSlokCogwoxENuM2fC7yy4a2y0RNdTyDIHIf9PF+v4z3dBMw360G1edHgnWUUHJRbEOmW5g2WNkhWjzicxLiFdBVthYBxD4wM238h/WHdVdBhbor//ztfVO8/3vderY1w+1gSeHBow268GV7EsqBiNlD9iZwO2Gp3NmORDu4l2/L9ehwPFjzm7g7s6Ha7m52N1/B+9s78V21EyHbP7XduE+4OAz/lusXFBXyrVotj9VxXOmG7KBDQ0sr3d1uUonk3qeeOZEtwvRfEvbRT5EbhJTBgGpbUwaBaOkp5Kk1vZU+vadr5I0Q9vwO9wgOJDLtYRSkBm9P785wLPGyK8gSQy6Hzc7Yw6g/7HITXtpeqGSCdNg/uGHDRy/hjDnHAM0MpDxLHh2McOe1r1+IlFXKfD8bqP3j0UjWiS3ozyLVBI4cntLzEGrlRz94s++LMotmhhR+qa8rZloIylwGfOjfIdohYtrn55DFoM5lmvX4K7x6ZFzh1dgCa6GVSytqbnfDNmUOUUW2WSvaXLwu4dc9WsyCxM4r89sX+xwwbWJ7R65wwvm9/uUfR9SooxMGa3uibr4yB2zLzvRPzNIR2ozUqwUqGKvqUzhLDk5UYHXTGrNFPsmrLGJhE2dGbutsMRdgfL6zDBswN7kXHc3yOGbzqUj2L/gikHYk4FMpB/fL8EYy1JRY1AaamGIufP3kZT0iSja79egtUUbza13lPb3Ve+3X3FjRbKyM3uK93svBUH3jn0MNW/frFhaghrFaP91fs3ZWxZdchcaKVw2vjKDKyPhp0eMM+SOMnmwTik8PXGrlj+o/cUUJXXz3/EFCpYiCxvSICEyZtWIY1dPDVvILtEJ60pll3QEqWcwLi96APzvuxyp2N9fzOo14aw7CzEukvqWMJ7exiueOndSKJcHSfsXjO73B1jmDI8A/GCHLhpkIG+EEEialZQBeqhwicNZAAvvwph7s3XuE+WPG1Vzo3ilI2Z7HSm9QdrYBKHwu9Atok5KgTnCb4VS5ryULrNCVFy1430VD21omYXjK5CID9IQ94+bDY72BCVGec7vLsgM2v7pUemP7ZezzvNeCHuUuldAC9fIJ7EY2/5Qs7tVQLKGR/aMNdIdQUmgUI7NxkCc5GzxcwELWY0aHm64OMyjj/+ica6FV+CiYtOO7WS+cpzkX5nLveszYoPmHGLWXwQBuI+GjLUDBmq/6BGsQMGNALrQretcpgN9Cgdz4CQLXY+ylDBXGiAold4WJg9sLx4AMC0uNZFNWoHYJ8e1eLI02Ke/2v6q7S7rmiFiWJ9ZztezM7DtH3SH/ZGvQ/ds97xXu+4N/r8GMYZ2/bi8ABiFhudprcPstjQVj2CxUYaYHTEb0q7i05LERnD96vMK9U9/0OtLrUGZlVTjNZRTnWbrEHp/wb9VKyBh1ta7FVaWcHq5hN7HVe3YGWbSB2TR7UKvfr4rjLCb/7AdhD39FJD4215/taTZZOlGtwa+hLwZUaH5hOCoJbSTxbWM1ZQSaGwNzzbFsSQTcFiiaUqTBFM2PAOkVdKNOkk5Cptha4b6K4YTEKCPsK/r1GLfT7ObrbGV0EKYtP2Ir9Y+7mF6yaMx6DWnA565IRdE5zcvlKtJXe/W0uuq7aWXLmTrkmi1ejO1MlhUM4Xedjwr9Lwwm+xNlbCgdQdT5NgArA+1IfwbegG3yxkupiy1wSEJ5Xs7PNkck/U2pBc4pG4xtNofC05DC2s+5TohVm0MNIdesQw992UbYzETzPNMBLb3qYJQhUKFxLrLgliMagzXZ6NmGbceVy6U4uoZvxCFQloxvSjdDHOk7QxDuZ8VgVidmXCQ7Z/E6Y4gnIl5FdR1j4LY3SUoXeeeU4RyszMEVVosoGZLn7pmYFsJ/9RLK/9094Y7wFtlzv3FoI6uiYnF1abvKewd/ugD4YXMN4TXzKoArdZQicN5sh1BTPoyEleQBMtjTTeguQrAraPjKvg8yTSru5ZgJZ39vk0GV9rMrK4imO7Rou2ljpCY+GZnPJa2Rc1ympk5sF5D/fAQrmz2lCQOFe3rLj3Yc3vEryKevFDlqrzWYJSXUcR9hH+XlXZ4Cy1+loliFHQeZeG51YUVzFm/7LaQK048epHLNKK2i71s2SRhXh5yvKqZ8tX5zmFFFGno7lJXGz5zdqULPLHJoSOeC1S2E62Oh2cUzKY5gq1XYf3c3xUASsMq2vE06NG2IYSqPz4XTZB0AekSPP8Zl26UOpC45LknEY82YJoJaKhqUjwkwZ5gdLNcBiILHwB7DprOAqIDJ0isZe5KRKZOlESnmk7tIpiW2SZS9k4LSXcagqxSFIoBsRNocjUKZTwNoU8R2TIIvMwxZs6HT5yegjSp84pqMc5dQ86IwS0GNBk0ny8yBscw3LU/JNq9whNy9u77cHo6BDX35vFW2TrZNdtZ4tzoWgw333+Smc1oPJ8ppbZ+pu8tJCKDkd9gzSfJeAaqtnDhSjGSlbtvBz1O28d5tLahiYekZpcbareFR7CAV3oJSR/SWZZP5dXFK7jv4qKVDtA8gsW07wGTX/qrOM/Xx9E0BpQtKaBdUtF7EqJmguPx8z6rc1wlieD7a/rkhO/z0vT3E8EsCx5Y/glKaAiwb0gyVF2lEyCqYMUvnQDHnTXEPAxD29TBJHa+TM3lDKDG3kq6i86a/Eu1eWO8TThzzrbJa8YxveXag7o5fhV5r+H4XxnGgap0TPyvu4unwp7NS4xV5deUXDDVgFj2QmmUzygIo5wDMB5eFUiRApYR9g7h4xKQxqAnmnlaUKcqtWjK8GCdtHZwX9+FXpKrGLAbjIsRHxCuapeX//r5jjwS0o4xUQbr6s7bcRnIGXv1FJJrRoOQvve6mb14xAlmLTpyyT/VSl5wATmlgX9hG4VlZtydmensJ5wa+I1eqCyoDZmbrhvmrAlYN3ClsiUMg6s6jgk5sMor4zDjiAgPGM39s+/huMcRelMl5ZdZyIIU34chbloEn+KeyofJb+QyqP8FwHwRUgq6ls3kbqq1ce9pPpc5bODV71EcU+WGGGjfEvfVUU499LtVIR5J1L2JLqx+ecZ21bE3Rgzj210u9HN8CoKpxMHQHYb5eOrYTQJd53IRZvUxucAUVH4RXB7MTc4iGhmmxvtDlVQBG3ghRC5UpwhHH5ZnRQtmvrMh+0mGbM7n1vWkb0HrUEB9iiMF+/DLP8H06DUbHbNCEczSqelDYtHJULoaGh6o5gYUlQls2UjfAWbBD4mVF61tnaNyP7uNSy7WC9oCA/ugqKnDVhd8TLROFRENxKqMRbSupoOltsVzbfCGpHKzKhGVZSUWo90HpnAclje0RP+tgIWUsOuqUDaYna9o6FLpSZaU5FGUZA5u+oNE3VWqfo/gAynpUDWdwNqmZKPgYrXQq5lj43oinODSfK1yHSsc6+cRCUzFzgN5vjUgd6AKUXK+T9MnnyU7KVJrKK1abIC11EMAcEaPKrkbOONcTrzi7ZJpYf9XTZ7i45y9u3T8hddCkA6v0zCrL2mVry4im7W41Rd4E13v0YhV7CpCnBH3KgKaBknri68O8pUVQFbxk8vz4PG5qtXLfm/9fbPr5rFwXT5AaKrHiKZ6FJFjcGqWFvagSaXKIwpo89q7d5wkIXe+mvDkFpUUBmozAYXQ08qxrSqIDgmDj4fCApIWgWDXJUER+USdWFRpguChqdW4TmH0bve0vt347H713+lBWUr68FlQHqUJPYxRd60BqVaHv63+S/Uw5v1epiysPKOq6Q6dQUbtMEKxvPqB0xWrQu+PXFXL0wKDmnMPjTTylnsz4XA5edsbVKFKa/5pKyP7pStz/dezu/U/9AOwtjueov9a6+/ahKHTKEMjWxmQSTOCtK4Mq+xwqU4idXgmYcH1MtqFm7HwuxYbztG4DrsQQd0Md6aAVR1NPmS7qyHJXUt6wfgcfMHeyzqYataEboZzlm2zqpw2ghd2Mjheyki0xRGcYyX0VFZuzBfVdZdHUyTzNLysLE6GDOBYohMboFPbtNgbgDWPaKuEPf1GHi2daZejDujnOPATX9F0GiCJf4pPMRrnuBRBw+mxzHL2K0rHjI2JkrUEzAMaKd0bUE5JHYLRm5rmr15OUd9VRkt0ajh+7mDhVIProuKcTlkxZTXYG2fJAeq8jNPC/T72ZCGUj+8RreMZJGOw6y9I6dio36/trilouSPv4NrGG/4sLoZzeKpTufErc8EPNOGYQfBrMBa7o+ijv4NDxTqpLy0bpshSGqcwVXqGiHKDMc1GYSj8CrKiKvgD1js5ZWl9klWncpWqOExOEs59gomUzE0VfymvJiTU5eDV7Gi8lKPwZVc2EsY1BF04CjBnvhBXApduL1wEuXQFlgMTLTOcKCWLKKV+VZRvD4HcVRsMZNCzSIlEZd1O5Ha48mBGw3cUHoYtYKN0SxdS8upKqmU7GpmsPzRhspa6nGc76ykIgxB6QGpe9ysq2sl9drTiqLDMzPzGZMlU8xZUb1JULwZufnKVKzF0ffSri054HpG/cpL0dv2lPovpzjhH6yVO7E9XK12ostlzENl9Vip+I8873N3ftkWWAXteBnEPuG0FGM8VVpy3FmmRZc4e1WdDS0hSVoKahLlNiyUepFV7gcuh7ulx8DlVhZHvAw3jjoCRfnjwk6HzjIyNY8rYW/0xP83/RWJ9P2lDKRE9jO5qTEZmsvuqany6iCXqyX1j5pXOV563ONbJ2LNLKJ7LjorcMMaDuHSCFvhFiGNtE5niMKGVOIN4TYWabjkKTC1WWnuW7irSEeUH+IAI12+Cy0Wq4xMDhBDXeuu2eEgAEYxGoeNuKXiddfwNvqexrk9e35TFzFoX+Ow/+a4xfHgBaEqamysw/9tCAchjty6fV56bL98gWgVKTckZy2smZoe4WohkUZc24jjgNGSrRwHYAbECtob25aZ+mb6oy6T+x6oxHGadS3OuUvYHbG8F+yueoga+0/qB0uZVfcM7JUl/G3RVRIovIhSevNAePMF2XVjBs0KLqHe+zBreXHS8hZZmLK72xqDU16K5T6qTuOXt0EyibFpFpGue7le7dPc0hWBDBTWMBb4/t1bb/9Hk5JxRZymjao2/rJ6VQIh1vVXo67iRkRx8cA6rKT3JSqENPtZgM9h9l5e0Nafv4R0y0AhRls9EkZtnMhaYJzNzdjDwW+ocaf3ApGC48RJwHHygPrjxK4+TspqN7Rkth+p/qiAkRTLsP6ULNEOsW6ktzA9oxbutGaDDF9R7fGGVd4YzJe818ceDRnUftljtFsryOJo167SV1klzG4X2vr3GIR2g9X9vF737awWWxdl7E4RN6BPa+wqoldrm6FrbhYGVAWy2g1qUuyhTxgqJMRW9HWR5dHFvTEGQgAVnLm6d3L7TZJBMefttwZz7WlBc2qTBwW5z6oBQnzw4wRojy5UEAZre2H4ojEGjBBt+cNtKfo+8qgbCNk1/rnbRXLtZNb9v1vMOpiGab7p5NVV/FdWIEAolhVYq1H9/w3Oiuvh/xne/w7DMyacg99RCMLueJbic0Ay1JEZXNDkfgbfk4/LLeZoO0cAbaPdC6JpOPlx22zBhUm7ovgi+YGt6l//U1tkRjsKz08gX8Y5+vyRf7t2q0selZM9dhd8iMJbvODUy8OZeUtFImmfOcEdN6ayOJhDv+TLMZqQBjKY2KAcBjgo+9PkPJhGcZQTw0GB6ihIr5GfLuL8JEw/BXdRZoT6Rf5214H0kzSZC77N4HZD2L6iOY/roDtDzgEQMwF4H4ctGmNRWBdRiAMJ63xaJDQU7qZ1GoaIYgzsGcUKafucvVxlhsCUoMBOgjTPPkb5VcOfscZlehwRz6tsuxnJ+pvdZTMeFMs0Ktn5rKfow8S63aigg3EkflVOYdXsYU4whnynSCnQnQdZiMsEtnEWiOYTzH/8+9k4oi4IxlmU9YEZ4nIyyqjuaFXtCApsyawHup3twZN1Ne01tsCQIIITjKRnNbGmtQQy/QFiYsHmbgCd48ReISeEu3wOl7SxXcRpIVFE3Q3vTCbDEMUfvI/arIYt6aQBj+vGGOj3dBELnJwGt6yXHD1E4tRpm6K7b0weterQy/Lf3yyBqGrMsTJofl7dpBpUHyaXe7A/P85YTJPLrJJqAIIKMyFEW7QbgbRNcKllAcl0SPUyqmM0neyWjKU50G1poxEPMamRtJBXMh5Rn3tZVq81MqyENCe4+7RCoABJHXasrOysgkKxcK3FJFEnVU6e+u1J+ewi735rPWbwJrOPShiSHBAXa9PHWsWePAgy/kC5jAqlQXVn8/x+ANonSk47qPhfKkKEXMxmkv85GefJ2ocoW4AA8huTRrxumibpr/GvMS+4SHkyyBznCShEIeL2gngCDQ0mHtbQ4q8TcBODKnABa6ztmw0Isvt47MFkHoeDEOMvCPJgq/x0dEiM1WLOw9+Gz2HRmaGITU+qa0tlKrgNotzY0ttjdHQ4WJxjvN6G6wCsZC7hE7g42d7ySbe2Vj2vJmGWp8m9Y4+QaMVRXdQyntZVgNjMvTSZQWfofWL0Iu+0HTH+dt8R2YUA73AzEOcvjlvldUpR80JxdBre7gx2iIY5TscvNs12COOxgNb6/m42xYkPya5TQDIfOHVsjnliGXjn4RXQ5wGX99At4KkeI4EHG0vFklituZrpGI9ZfLouroJMUQCfsIxvQlg+H5PFdOLdJwtvGl2zhxVSNoW9KH9XtV9UrowtG76a7iJEBZMOS2tdCQubMM7ju1VaYcz7Yuy53Aw/jDmvrwwBrU93kWQerToa6+SOpmudPvO+6ZbOTKkNu/2jE/atx3aZJGMeAQTS2+wP0ixECkEjzMP5NAA24L95urb2FoMm4w8P1WBfUwyfA7xuwUqTJCfDAZXpz+sAR+sG46tGI4ZPK7QjJrbxP6iagZhzOgftbgfEngZ7Wcof9Psjn7+9mOSm5uSpygEBtSvyd1XsIvkVvsiI78MgZnzKhhVGPRGGkAuwwmIDpR+vHcPu8bA/GPq69mlsB7DD4jlIPOTJDWbm/DSbYvW8UvMp0OaqlLJI4vzAly4geS28ohnkbSS8WOvv9I/3evv+a/2xKMVke2g5qGiCdVlXYt0fdE4O9vqDI4LY2rOYpRjxX6bB/OojS3XU1xLtrVFx53j/9LAz2O+c7ndXqB+402IapPvB4jJ8DDJWrf/ysSre7e33Rp3D3d7w5LDzeQUKJtFllKOfCnPc+h5SJJ8zVkYaXqLffMq3AhSOcSttlKs3TnnUVtB+NAMqk9/eEDPZwzYDQ0VLF7Fk5C2vewedFQdTfQNteVlwE+4tYmZyJb5APACKq1B5wDQsWFLCkN2WjKZCIkfVhdX5BrJ7lzbFPLkpO8S1TrGpecz41/I+htNxMmOSkUsLaaB4fhueN5VgTxC6ioDclQlNBQMLFuSdL4Bhf+C5pcjmi3HodU56JprPkNaOZrOz/TCHnwJNo6lNvqKmwSJGPbkfd+JJmkQqnCup7j2+wQVSBFSQcngUHEUJfb9nJ1A7xsWKzfarl8TqPglvQKUYslNK/iDBcy2Xn17unvQ0vPwocyXE4gpXJWaqr+G7GiAScygWdc8eGIt04wjqrhzcefcLn52jRRSR/AW0OShejf9GENG3rgpl9xh541nT8yvbOo/uwqnH9ALZVnE+xSk/wfwBZmuoHRgL8qPs5CqJw346wrOvHANEn6TJOXzc63Mn4GdpOb4iGHhzLNJmgaTdwCC5XGMwF1drtMovFxF03F6AYfg+BhkGTExB8WOvv2OPosls4v2WJDMv4XmYiQua1W2AXDA83AcYIJpkmPSqoG/2MEJIY6NZ2dvikJodO/L5ta31OEsunVM6UNktwqZhqCo5sRHBfgzGu4gbZnmX/uI0jswBupdNw+AGyQkt6w4/3uI7FrH58VfUCleE0ldveD24SyGbHZvHfxKDVgL2hsk0HEIJkHzxQJF3RAO93TUKknkwjvJ7qQHtQZvzRuGtKbKb3pqHsUQKDirLvdF36/JHXSbadTtbUbPqA3LEL8s5GKYjPhiULHJDxlHDVtVyUWsL4zMXB5eWTRk9XX6uDtLq3mHXtQwh2Ah30MKcKM7PhotzaUu0YZwHiAR7HQMAHrsejEYnafifizDLB2G2mOalcTsnTD7iT1fKv+gdYETy5K8nFaZo4bvLwEUo80VmZwk/g+JDD/LHnlNyByQU9UhIXt4NW1RNobG2qhIFNeJY/mBx3tNP5q0Ip2mSJ+Nk2vKCySRtecjf4L+wM0O/pTdoGcZTU/YxBwS3SWo804MgJyLHEc37LJjMorgKAHbJifVgDyCNmHOTkVyQ5IqjWtBIcsX5L2toO2NG0DX+pLX/Wt3olwDIPyjsestb2yDh1xywtMkT1LzxDymFr51usy5eARmOBeNpPNioCOCv9QMK7zcgvRVXNlx9pX0RNKrDKtBonap92TccWGRFYgGjuW18mayTN9Z53z/37SuqorVaGT4GG83S95XrVk4HfpXK9QlgKmaX3A2BDVtJ4FZtUGUJnBpuaDlpFG79iTiKV8wjBQkEl4WOpYFq9SXrLqFDULq1xVzWAA2EcDC2pEu4F8sj0OnNqZivJUXIEmCrXcY3JXmvtbCoAnF1A+iisBCrPAPx2dXi/DSdMg905KCUV6KAskincnapNQ/i3uvnz30rTiliYfOZRilVycY0d6V7rMJn27wQVsTfsRLkQ8LffNeiEqV4ZFfkZLKoeP8hzcuvOWnL8AmhAdabwqA4meh2AJH9yIXDWXAdDvhG3yjpwDOzB9VFY5vks2qaz+oQfVZQrTLR5a39NUv0d4JB3p3D9io3uPS+eFlc5ODGwI4JL8J8fNUAbC3vv2bJJIT5NAYx3len8x5Ie2it1XyZZLTqF+aVPYm9nVxTzywQAHaVgEMp8mSmIklhwVZppigHJVbkbBrJRmBm0wUnrv7tDC6hPMPyRG6Ueplf1r+w88u8gVu2GYXD3ELPRBELTuzAqB/04ryhAW98KYlwoCQRSQ5P4K8Lm8EH2P4hASeRkW+KQhKQpDuMk6PBade4YGZIXRKTnrwMkaFwOWeTlIXxUZeXephkc8XIybC5VYVknVlYaTqXpp3Br+U0L3RJvaB6bSuSTrowrqCytbxY8/8rdNNCHuRwDzz1YbQaDoaiAmUdNnVD6yjHUo6xEf1FvgOyMJAG8ytDdZ1rRugwtOTUsez26uOdGy4/HcSelOy5GBPA3RLmdePMjsNX087dLNyYJQ6868jAfGoWVQWrq4Clk9nIi/KAHkF05LzIUrTD0HhPdMqvVGJxbfIV+dxJDLL30Ci63Amp+qF4+T60PnGxKb7JdGPeveQoRxTWOC1CBvLVXTnd2+od3syAFCqQym5fBVn/NhZ+vfcNHyGAlHcazC888YsSrbSNgXPuCnwIYeFjiQzfz+smxmLPqMIqoGzMMsNJLd8IqvAChI0TE134ND2uAidCWThZoptGtXtU0smhHLSKDBfuYEOov3QP2iIe2cEGfRvvJd+jPn782CZh9jgyHfilOS03lVi4tNLNmpUiSgL80iIfSwIcbGl8vHXNsWnH+jIUcqqNl2vcsGLbu+E4vZ+DvCKSWyx1mlxG8c79/KrY85tlL6WTx+TYmROyGdhYDpiJMS01EF1xAxKx+aDnk2gFMc/ApiBfJNeTr/LZdJiOdzibIVlIwfA+y8NZZzwOs2w3jKPQaSX6dHRY7IbCVmibgMQtFEE01SqYyVw8xgdsTsMmg6xYqgZ7rQEd/PAt8i1nBwCgNknwC7oxZ7Eb+hcNZmZ4pvzt2LorNhuOpB1J4HfkZR39OXuzVoqAzOh5s7TrlVFb/hD3wdoJrGl2s8zSQ6v6C2Y8VVB//30ZvB15opgzP715Bx/yCHTb32iv+967t7/Gb5gPj0rfbG/4mMorwF+4oYq/iq1v+z9J3Y3paZq++JPPeJMJIRRHyMVdwypPdUgGiBANDURJxcArf2JMwcKCILzoa9YX8Ntjpwt4hrbt73UOh13/OTbmuWzV86Khz7En4MdP5QEsiv6sGgqn/7c4mcEj8trrBHQcsdmptYLfBWNjQOGF2L+LbZjJO7BUruYJe26K47EWj2arlMBEbSzqlxiUyU4WcLsLFgV9KxBX0RQlI2C0pjyfZ6+1+as16+XLF77prwdMSLAjlKyEId7G3dK4TJLl3NquNNQCHGt659Hv15KGZks2iHgiCxLaxKBS9D8ykCvF/5n8Z+8MDYGEINZKtpfzVaL0aEV1s9ydLLlbdoAiZrZ5R0Br2izMrxLYHJlNpTi6MG1xAim2FwSdWQRSwoVwmEGlNZneQKE0xAfyjFtuV7KfYDc6gOlg9GlhizMM81xGsAzt0qJHbJgmqOlmA0S0QTqLaWv5DUdHm7dIwdsov9J0THJiay0Rd12WmYQBifP5o2gW4v36ho9XFZ7Pp0EUb6GLMkznfPtuDQlcU25GWzqGGI+V79nzwdyXC6UAOSzmbT4sweCH8iXjl00rdjOPsMqND2/xicd1ZcEQqW/wUVpakCnzOAWYa5t15NhQLjmw427CwhCkcMsEXjUt0LdYw7TTR+IRZ3X28rpxKqxSgy0L0h4P8bZFWTc/Gimk0gxj2xlPs+Oxtc132ll0GQO2NBzijoRc1gnFtit/CYouU6d/khvorzFMPthEwzvGRrHRnWmQzoTG3iq+8xy2+0wljKAHcH5rV1tZnuYcit4ixe1VLfcf0OFWuTjJGT8/CeJw6kiqLqDl7qN/LIKAbJzmwzCNQvZVXBoyPvG03pH0HpQmR7I44u/GeXpvZKvriVq6AGcpiyxPZp+5uzMmIINXzcWPYXiJUmjxKWjHj1EajK/D1Pg0egXvmRpJJUMhrhvjjWLtU1Fj3UZmidizNiprTbDExbn4g5s9/jwML2HKF78MOnmiIkD7NAC5G0Xxy8oGwfTuxd0L9sGvsyusR1F8FNwVv8TywITj4Ca6lIOnPgzkx7DYtQE8wcjg6sce+6W6Bt1xtZR7iUoUhVRYcYA3YJSxpT3Mk/kwD+eYgA4xMIdgO8k5gSSBmS6L3sa8CafrA4ZZZGn26vwQoibLekZeFdYX9ic5G8xL65iG7F7+FXNbfp7tdj/0drpn70+Hn8204/7obK9/erxbZPRP3x92zzo7O92hSux+OuicDkfdAmyvd+gq3Tv+0Dns7Z51BvunR93jkZXB0VvJPQfoYf9430ocjgY9R/IpQdA/6w4G/YFKOOp8Mis+6h2bSdia3nFv1AOM/9CaiunD05OT/mBEUs+O+oPu2W5n1FGJg9EOAx90O7tFXw+HhwZBw1Ps3qJ/R72jbv+0aMHpced0dNAfEDo+dAfDXv8YSB8edUY7BzxD4+h6AjJx/i0mzef36SJjjPcziwIrfsUsoCzIJhPO0viswd+HyeUln9rscwDrPUy1BB0WtM0wmMlPXvEuccNnSd14MVM/JF//zO5SHmWX7GMvSme3QRri7kgSTucTiRnZKP8h5AH2IXii4GzyczjcPREOhzxZbj/8VzTOyMfwA59byDTfJ5N79SEkaPZ9CFIhdHkaTCLYDop+PQqDDPZw/juZLEQLjsMcJNxr9vsk5MQOYKmD7CggCpb1Gb3d9vivWZKA3BJfHqFxn6XgUBXVsc9i4LnGj/w/4GRye1U3vqFfB/mMsbTPKP3wUYVyB4JVSmc3+XuYwD6Wy07llynET3R8Yz+FLZ79BsYy6u6MzjqHh+T7uDui3/3jLkk4Hb7n33unxzsjmOe73eHOoHcy6g/kKmf5Lt6HEhWbReqLyleYLBeEQ7oRoW6CjP9iSdYtGkzlYaHw1ziYo7jGwneFOboWcghxB7L1RLt7hB/0Toq9SbvurLD0ZHE+DY8DVinGJ8IDEsfWcUkJ1S4h4Wck9njhI4w/aQQyTGHvaHxiXEsLkMA+VViA1hPpxcuEHJsOnrkH8kZpJggj4ygT8c2cEJm2YHlQFRERDRPuO3QCoFT+/PmfxJnUUTCfw2w+HRxu39+8vA3P16QTcPtr1p4F8yf/A/RYGHwPDw4A";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string")
          this.DEFAULTADDR = options["addr"];
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
