/* Yocto-Visualization-4web installer (version 1.10.53008) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.stalledTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._isHubWorking = false;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    await this.signalHubConnected();
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub connected");
    }
    this.notbynOpenTimeout = null;
    this._isHubWorking = true;
    if (!this._hubAdded && this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this._isHubWorking = false;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled");
      }
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Hub connection failed (timeout)");
        }
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s");
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Retry hub connection now");
        }
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
    this._isHubWorking = false;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        let TryOpenID = (Date.now() % 6e5).toString();
        if (mstimeout) {
          this.stalledTimeoutMs = mstimeout;
          this.notbynOpenTimeoutObj = setTimeout(() => {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("WebSocket connection timeout [" + TryOpenID + "]");
            }
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("WebSocket connect cancelled (disconnecting) [" + TryOpenID + "]");
            }
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("Opening websocket connection [" + TryOpenID + "]");
            }
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Failed to open WebSocket connection [" + TryOpenID + "]");
              }
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  if (this._yapi._logLevel >= 4) {
                    this._yapi.imm_log("WebSocket connection established [" + TryOpenID + "]");
                  }
                  this.signalHubConnected().catch((e) => {
                    if (this._yapi._logLevel >= 4) {
                      this._yapi.imm_log("Exception in signalHubConnected [" + TryOpenID + "]");
                    }
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed [" + TryOpenID + "]");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error [" + TryOpenID + "]: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error [" + TryOpenID + "]");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open [" + TryOpenID + "]");
                  this.imm_disconnectNow();
                }
              }, this.stalledTimeoutMs);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.disconnecting ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    super.imm_disconnectNow();
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (!hub._isHubWorking) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.53008";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(this._networkTimeoutMs, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.currPos = 0;
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos >= 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.stalledTimeoutMs = mstimeout;
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.currPos = 0;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, async () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                let newlen = xmlHttpRequest.responseText.length;
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                  if (newlen == 0)
                    return;
                }
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                }
                if (!this._isHubWorking) {
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (newlen > this.currPos) {
                  await this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                  this.currPos = newlen;
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.53008";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.errorMsg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
