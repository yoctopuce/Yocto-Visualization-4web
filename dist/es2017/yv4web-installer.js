/* Yocto-Visualization-4web installer (version 1.10.51983) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      return;
    } else if (this.segments[0].count > 1) {
      let delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      let delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        return;
      } else if (this.segments[0].count >= this.segments[0].data.length)
        this.segments[0].grow();
    }
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      if (this.segments[InsertAtBegining].count + points.length >= this.segments[InsertAtBegining].data.length)
        this.segments[InsertAtBegining].grow();
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      if (this.segments[InsertAtEnd].count + points.length >= this.segments[InsertAtEnd].data.length)
        this.segments[InsertAtEnd].grow();
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (!(data[0].x < end) && data[count - 1].x > start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 30 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        for (let i = 0; i < this._series[k].segments.length; i++) {
          lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
          pointCount += this._series[k].segments[i].count;
        }
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                for (let i = 0; i < this._series[k].segments.length; i++) {
                  lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  for (let k = 0; k < this._series[j].segments.length; k++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[k].data, this._series[j].segments[k].count, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid)
        delete this._hwIdByName[currname];
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId)
      break;
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!")
        return iter_hwid;
      if (str_hwid == iter_hwid)
        str_hwid = "!";
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0)
        end--;
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0)
        baseUrl = baseUrl.slice(0, byPos + 1);
      else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._hubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev)
        return link;
      else
        return "";
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._hubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key])
      return this._dataStreams[key];
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services")
        continue;
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._hubs.length; i++) {
      let hubUrl = this._yapi._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._hubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this.notiflen = 0;
    this.lastPingStamp = 0;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.serialByYdx = [];
    this.retryDelay = 15;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.currPos = 0;
    this.missing = {};
    this.disconnecting = false;
    this.notbynOpenTimeout = null;
    this.notbynTryOpen = null;
    this._reconnectionTimer = null;
    this._firstArrivalCallback = true;
    this._missing = {};
    this._rwAccess = null;
    this._hubAdded = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this._connectionType = 0;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_setConnectionType(hubtype) {
    this._connectionType = hubtype;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  async testHub(mstimeout, errmsg) {
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      errmsg.msg = yreq.errorMsg;
      return yreq.errorType;
    }
    if (!this._hubAdded) {
      await this.signalHubConnected();
    }
    return YAPI_SUCCESS;
  }
  async signalHubConnected() {
    this.notbynOpenTimeout = null;
    if (this._connectionType != 2) {
      await this._yapi.ensureUpdateDeviceListNotRunning();
      await this._yapi._addHub(this);
      this._hubAdded = true;
    }
  }
  imm_testHubAgainLater() {
    this.isNotifWorking = false;
    this.devListExpires = 0;
    if (this._connectionType == 1 && this._hubAdded) {
      this._yapi._pendingHubs[this.urlInfo.url] = this;
      this._yapi.imm_forgetHub(this);
      this._hubAdded = false;
    }
    if (this._reconnectionTimer) {
      return true;
    }
    if (this.retryDelay < 15e3)
      this.retryDelay *= 2;
    if (this.notbynOpenTimeout) {
      let now = this._yapi.GetTickCount();
      if (now >= this.notbynOpenTimeout) {
        return false;
      }
      if (now + this.retryDelay > this.notbynOpenTimeout) {
        this.retryDelay = this.notbynOpenTimeout - now;
      }
    }
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      if (this.notbynTryOpen) {
        this.notbynTryOpen();
      }
    }, this.retryDelay);
    return true;
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.url);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._connectionType == 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode != YAPI_SUCCESS) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return YAPI_SUCCESS;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._connectionType == 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  imm_commonDisconnect() {
    if (this.timeoutId)
      clearTimeout(this.timeoutId);
    this.timeoutId = null;
    this.disconnecting = true;
  }
  async reportFailure(message) {
  }
  async disconnect() {
    this.imm_commonDisconnect();
  }
  imm_isForwarded() {
    return false;
  }
  imm_disconnectNow() {
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < 1e4;
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._reconnectionTimer = null;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.url);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI_IO_ERROR;
    }
    this._connectionState = 2;
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout on WebSocket connection"});
            this.imm_commonDisconnect();
            this.imm_disconnectNow();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          if (this.disconnecting) {
            resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
          } else {
            this.imm_webSocketOpen(this.urlInfo.url + "not.byn");
            this._firstArrivalCallback = true;
            if (!this.websocket) {
              resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
            } else {
              this.websocket.onmessage = (evt) => {
                this._webSocketMsg(new Uint8Array(evt.data));
                if (this._connectionState == 4) {
                  this._connectionState = 5;
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().catch((e) => {
                    this.imm_disconnectNow();
                  }).then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                } else if (this._connectionState == 0) {
                  if (this._session_error) {
                    if (errmsg) {
                      errmsg.msg = this._session_error;
                    }
                    this._yapi.imm_log("WebSocket error: " + this._session_error);
                  }
                  if (this._session_errno == 401) {
                    this.imm_commonDisconnect();
                    resolve({errorType: YAPI_UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  } else {
                    resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                  }
                  this.imm_disconnectNow();
                }
              };
              this.websocket.onclose = (evt) => {
                if (this._yapi._logLevel >= 4) {
                  this._yapi.imm_log("WebSocket connection closed");
                }
                this._connectionState = 1;
                this.websocket = null;
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_dropAllPendingConnection();
                if (this.disconnecting) {
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              this.websocket.onerror = (evt) => {
                if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
                  this._yapi.imm_log("WebSocket error: ", evt);
                }
                if (this.retryDelay < 0) {
                  this.imm_commonDisconnect();
                }
                this.imm_disconnectNow();
                if (this.disconnecting) {
                  this._yapi.imm_log("Disconnecting after error");
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI_IO_ERROR, errorMsg: "I/O error"});
                }
              };
              if (this.timeoutId) {
                clearTimeout(this.timeoutId);
              }
              this.timeoutId = setTimeout(() => {
                if (!this.imm_isForwarded()) {
                  this._yapi.imm_log("WS: connection stalled during open");
                  this.imm_disconnectNow();
                }
              }, 6e4);
            }
          }
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: multipart/form-data, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.disconnecting || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next)
        pendingCount++;
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next)
          pendingCount++;
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async disconnect() {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect();
    this.imm_disconnectNow();
  }
  imm_disconnectNow() {
    this._connectionState = 1;
    if (this.websocket) {
      let websocket = this.websocket;
      this.websocket = null;
      try {
        websocket.close();
      } catch (e) {
      }
      if (websocket.terminate) {
        setTimeout(() => {
          try {
            if (websocket.terminate) {
              websocket.terminate();
            }
          } catch (e) {
          }
        }, 1e3);
      }
    }
    this.imm_dropAllPendingConnection();
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._hubs = [];
    this._ssdpManager = null;
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._hubs = [];
    this._pendingHubs = {};
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  async _addHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.url];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.url, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._hubs.length; i++) {
      let url = this._hubs[i].urlInfo.url;
      if (newhub.urlInfo.url == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._hubs.push(newhub);
    }
    if (this._pendingHubs[newhub.urlInfo.url]) {
      delete this._pendingHubs[newhub.urlInfo.url];
    }
  }
  imm_getHub(obj_urlInfo) {
    let i;
    for (i = 0; i < this._hubs.length; i++) {
      let info = this._hubs[i].urlInfo;
      if (info.host == obj_urlInfo.host && info.port == obj_urlInfo.port && info.domain == obj_urlInfo.domain) {
        return this._hubs[i];
      }
    }
    return null;
  }
  async ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._hubs.length; i++) {
      if (this._hubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._hubs.length; i++) {
        this._hubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._hubs.length; i++) {
        let hub = this._hubs[i];
        let rootUrl = hub.urlInfo.url;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.url;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      await Promise.all(update_promises);
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (currdev && this._arrivalCallback && hub._firstArrivalCallback) {
        let module = YModule.FindModuleInContext(this, serial + ".module");
        this._pendingCallbacks.push({event: "+", serial, module});
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return YAPI_SUCCESS;
  }
  async parseEvents(hub, str_lines) {
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("WS: closing stalled connection");
        hub.imm_disconnectNow();
      }
    }, 6e4);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      hub.notifCarryOver = "";
    }
    nrows--;
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        hub.notifPos = -1;
      }
      hub.currPos += ev.length + 1;
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length)
        break;
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0)
          break;
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0)
          val *= 1e3;
        else if (dec == 1)
          val *= 100;
        else
          val *= 10;
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9")
      classlen--;
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0)
      this._fnByType[classname] = new YFunctionType(this, classname);
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0)
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0)
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub && this._pendingHubs[str_device]) {
      hub = this._pendingHubs[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.url.length) == hub.urlInfo.url) {
      devUrl = baseUrl.substr(hub.urlInfo.url.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._hubs.length; i++) {
      let hubUrl = this._hubs[i].urlInfo.url;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._hubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._hubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._hubs.length; i++) {
      let hub = this._hubs[i];
      let hubUrl = hub.urlInfo.url;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.51983";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let i = 0; i < this._hubs.length; i++) {
      await this._hubs[i].disconnect();
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/")
        dom += "/";
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
    } else {
      url += host + ":" + port + "/" + dom;
    }
    return {proto, user, pass, host, port, domain: dom, url};
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    return newhub;
  }
  imm_forgetHub(hub) {
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    let i = this._hubs.indexOf(hub);
    if (i >= 0) {
      this._hubs.splice(i, 1);
    }
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this._throw(YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this._throw(YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    this._pendingHubs[urlInfo.url] = newhub;
    let sub_errmsg = new YErrorMsg();
    let retcode = await newhub.testHub(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = sub_errmsg.msg;
      }
      return this._throw(retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
    }
    newhub.imm_setConnectionType(1);
    this._pendingHubs[urlInfo.url] = newhub;
    newhub.testHub(0, errmsg).then((errcode) => {
      if (errcode != YAPI_SUCCESS) {
        if (this._pendingHubs[urlInfo.url]) {
          delete this._pendingHubs[urlInfo.url];
        }
      }
    });
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl("http://callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      newhub.reportFailure(errmsg.msg);
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
        newhub.reportFailure(errmsg.msg);
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let urlInfo = this.imm_parseRegisteredUrl("http://" + authstr + "callback:4444");
    let newhub = this.imm_getHub(urlInfo);
    if (newhub || this._pendingHubs[urlInfo.url]) {
      return YAPI_SUCCESS;
    }
    newhub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
    if (!newhub) {
      return this._throw(YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
    }
    let retcode = await newhub.testHub(this._networkTimeoutMs, errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this._throw(retcode, errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = yreq.errorMsg;
      }
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._hubs.length == 0) {
      return false;
    }
    return this._hubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      this.imm_forgetHub(hub);
      await hub.disconnect();
    } else {
      let pdghub = this._pendingHubs[urlInfo.url];
      if (pdghub) {
        delete this._pendingHubs[urlInfo.url];
        await pdghub.disconnect();
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let newhub = this.imm_getHub(urlInfo);
    if (newhub) {
      return newhub.imm_isOnline() ? YAPI_SUCCESS : YAPI_IO_ERROR;
    }
    if (this._pendingHubs[urlInfo.url]) {
      return YAPI_IO_ERROR;
    }
    newhub = this.imm_registerHub_internal(urlInfo);
    if (!newhub) {
      return YAPI_NOT_SUPPORTED;
    }
    newhub.imm_setConnectionType(2);
    if (!errmsg)
      errmsg = new YErrorMsg();
    let res = await newhub.testHub(mstimeout, errmsg);
    await newhub.disconnect();
    return res;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      if (errmsg)
        errmsg.msg = yreq.errorMsg;
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    await this.HandleEvents(errmsg);
    while (this.GetTickCount() < end) {
      await this._microSleep_internal();
      await this.HandleEvents(errmsg);
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    this._setTimeout_internal(callback, this.GetTickCount() + ms_timeout, args);
    return YAPI_SUCCESS;
  }
  _setTimeout_internal(callback, endtime, args) {
    let delay = endtime - YAPI.GetTickCount();
    if (delay < 0) {
      callback.apply(null, args);
    } else if (delay < 100) {
      this.Sleep(delay).then(() => {
        this._setTimeout_internal(callback, endtime, args);
      });
    } else {
      this.UpdateDeviceList().then(() => {
        this.Sleep(90).then(() => {
          this._setTimeout_internal(callback, endtime, args);
        });
      });
    }
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3)
            c = int_pad;
          else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      inner[k] = _shaw[k];
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++)
      outer[k] = _shaw[k];
    pos = 0;
    for (k = 0; k < 5; k++)
      shau[k] = 0;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++)
            shau[k] = 0;
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.notbynRequest = null;
    this.notbynOpenPromise = null;
    this.notbynOpenTimeoutObj = null;
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
  }
  imm_sendXHR(xmlHttpRequest, method, uri, obj_body, readyStateChangeHandler, errorHandler) {
    let body = "";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = uri;
      let parseURI = uri.match(/([A-Za-z]+:\/\/)([^\/@]+@)?([^\/]+)(\/.*)/);
      if (parseURI) {
        uri = parseURI[1] + parseURI[3] + parseURI[4];
        shorturi = parseURI[4];
      }
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      body = JSON.stringify(jsonBody);
      let qpos = uri.indexOf("?");
      if (qpos > 0) {
        uri = uri.slice(0, qpos);
      }
      xmlHttpRequest.open("POST", uri, true, "", "");
      xmlHttpRequest.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined");
    } else {
      if (obj_body) {
        let blob = new Blob([obj_body.data], {type: "application/octet-binary"});
        body = new FormData();
        body.append(obj_body.fname, blob);
      }
      xmlHttpRequest.open(method, uri, true, "", "");
    }
    xmlHttpRequest.overrideMimeType("text/plain; charset=x-user-defined");
    xmlHttpRequest.onreadystatechange = readyStateChangeHandler;
    xmlHttpRequest.onerror = errorHandler;
    xmlHttpRequest.send(body);
  }
  async testHub(mstimeout, errmsg) {
    if (this.disconnecting) {
      if (errmsg) {
        errmsg.msg = "I/O error";
      }
      return YAPI.IO_ERROR;
    }
    if (!this.infoJson) {
      if (!await new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        this.imm_sendXHR(xhr, "GET", this.urlInfo.url + "info.json", null, () => {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              this.infoJson = JSON.parse(xhr.responseText);
              resolve(true);
            }
            resolve(false);
          }
        }, () => {
          resolve(false);
        });
      })) {
        this.infoJson = {};
      }
      if (this.infoJson.serialNumber) {
        let knownHubs = this._yapi._hubs;
        for (let i = 0; i < knownHubs.length; i++) {
          let hubSerials = knownHubs[i].serialByYdx;
          if (hubSerials && hubSerials[0] == this.infoJson.serialNumber) {
            if (errmsg) {
              errmsg.msg = "Hub " + this.infoJson.serialNumber + " is already registered";
            }
            return YAPI.INVALID_ARGUMENT;
          }
        }
      }
    }
    let args = "?len=" + this.notiflen.toString();
    if (this.notifPos >= 0) {
      args += "&abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (!this.notbynOpenPromise) {
      this.notbynOpenTimeout = mstimeout ? this._yapi.GetTickCount() + mstimeout : null;
      this.notbynOpenPromise = new Promise((resolve, reject) => {
        if (mstimeout) {
          this.notbynOpenTimeoutObj = setTimeout(() => {
            resolve({errorType: YAPI.TIMEOUT, errorMsg: "Timeout on HTTP connection"});
            this.disconnect();
          }, mstimeout);
        }
        this.notbynTryOpen = () => {
          let xmlHttpRequest = new XMLHttpRequest();
          this.notbynRequest = xmlHttpRequest;
          this.imm_sendXHR(xmlHttpRequest, "GET", this.urlInfo.url + "not.byn" + args, null, () => {
            if (this.disconnecting) {
              return;
            }
            if (xmlHttpRequest.readyState >= 3) {
              let httpStatus = xmlHttpRequest.status >> 0;
              if (xmlHttpRequest.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
                if (httpStatus == 401 || httpStatus == 204) {
                  resolve({errorType: YAPI.UNAUTHORIZED, errorMsg: "Unauthorized access"});
                  return;
                }
                if (!this.imm_testHubAgainLater()) {
                  resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
                  return;
                }
              } else {
                if (!this._hubAdded) {
                  if (this.notbynOpenTimeoutObj) {
                    clearTimeout(this.notbynOpenTimeoutObj);
                    this.notbynOpenTimeoutObj = null;
                  }
                  this.signalHubConnected().then(() => {
                    resolve({errorType: YAPI_SUCCESS, errorMsg: ""});
                  });
                }
                if (xmlHttpRequest.readyState == 3) {
                  if (this.notiflen == 1)
                    return;
                }
                let newlen = xmlHttpRequest.responseText.length;
                if (newlen > this.currPos) {
                  this._yapi.parseEvents(this, xmlHttpRequest.responseText.slice(this.currPos, newlen));
                }
                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status >> 0 != 0) {
                  this.notbynOpenPromise = null;
                  this.currPos = 0;
                  this.testHub(0, errmsg);
                }
              }
            }
          }, () => {
            if (!this.imm_testHubAgainLater()) {
              resolve({errorType: YAPI.IO_ERROR, errorMsg: "I/O error"});
            }
          });
        };
        this.notbynTryOpen();
      });
    }
    let res_struct = await this.notbynOpenPromise;
    if (errmsg) {
      errmsg.msg = res_struct.errorMsg;
    }
    this.notbynOpenPromise = null;
    return res_struct.errorType;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    return new Promise((resolve, reject) => {
      let prefix = this.urlInfo.url.slice(0, -1);
      let httpRequest = new XMLHttpRequest();
      this.imm_sendXHR(httpRequest, method, prefix + devUrl, obj_body, () => {
        if (httpRequest.readyState == 4) {
          let httpStatus = httpRequest.status;
          let yreq = new YHTTPRequest(null);
          if (httpStatus != 200 && httpStatus != 304) {
            yreq.errorType = httpStatus == 401 || httpStatus == 204 ? YAPI.UNAUTHORIZED : YAPI.NOT_SUPPORTED;
            yreq.errorMsg = "HTTP Error " + httpRequest.status + " on " + prefix + devUrl;
          } else {
            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
          }
          resolve(yreq);
        }
      }, () => {
        let yreq = new YHTTPRequest(null);
        yreq.errorType = YAPI.IO_ERROR;
        yreq.errorMsg = "I/O Error on " + prefix + devUrl;
        resolve(yreq);
      });
    });
  }
  async disconnect() {
    this.imm_commonDisconnect();
    if (this.notbynRequest) {
      this.notbynRequest.abort();
    }
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  async get_name() {
    return this._name;
  }
  async get_size() {
    return this._size;
  }
  async get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.51983";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.dataLoggerFeature = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.globalDataLoadProgress = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  getGetaLoadProgress() {
    return this.globalDataLoadProgress;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    this.globalDataLoadProgress = this.recordedDataLoadProgress;
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows )");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = 0;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.globalDataLoadProgress = 100;
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (this.globalDataLoadProgress != this.recordedDataLoadProgress) {
        this.globalDataLoadProgress = this.recordedDataLoadProgress;
        this.reportDataloggerLoadProgress(this.globalDataLoadProgress);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
        this.load_ProgressChanged();
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        console.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec");
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      this.globalDataLoadProgress = 100;
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows )");
    this.loadDone = true;
    this.globalDataLoadProgress = 100;
    if (this.previewMinData.length <= 0) {
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].DataLoggerProgress();
        }
      }
      return;
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
        this.FormsToNotify[i].DataLoggerProgress();
      }
    }
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this.preloadDone = false;
    this.loadDone = false;
    this._loadProcessIsBusy = false;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  load_ProgressChanged() {
    for (let i = 0; i < this.FormsToNotify.length; i++)
      if (this.FormsToNotify[i] instanceof graphWidget)
        this.FormsToNotify[i].DataLoggerProgress();
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    if (this.curData.length > 0) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.loadDatalogger(start, end);
      }
    } else {
      this.loadDatalogger(0, await dt.get_timeUTC());
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    if (M != null) {
      this._online = true;
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
    }
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorValuecallback(this, M);
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("--> Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
      logForm.log("UpdateDeviceList failed :" + err.msg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeWidth / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  showRecordedDatachanged() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  preLoadSensorData(value, index) {
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    this.dataloggerProgress.enabled = true;
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    debugger;
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  showRecordedDatachanged() {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      this.SourceChanged(s.DataSource_source, i);
    }
  }
  DataLoggerProgress() {
    let progress = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData) {
      this.dataloggerProgress.enabled = false;
      return;
    }
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (!(s.DataSource_source instanceof NullYSensor)) {
          progress += s.DataSource_source.getGetaLoadProgress();
          sensorCount++;
        }
      }
    }
    if (progress < 100 * sensorCount && sensorCount > 0) {
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (progress / sensorCount).toFixed(0) + "%)";
    } else {
      this.dataloggerProgress.enabled = false;
    }
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    this.dataloggerProgress.enabled = false;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < props.byIndex.length; i++) {
      let name = props.byIndex[i].name;
      if (name.startsWith("Graph_series")) {
        let s = Reflect.get(this.prop, name);
        if (s.DataSource_source == Source) {
          let index = parseInt(name.substring(12));
          this.SourceChanged(Source, index);
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(0, 50, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(0, 50, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this.ownerForm.showRecordedDatachanged();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response = await fetch(checkurl);
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    ;
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let HubData = null;
    let res = await YoctoHubFileHandler.makeRequest("GET", url, this._srvusername, this._srvpassword);
    if (res.data != null) {
      let data = new TextDecoder().decode(res.data);
      HubData = JSON.parse(data);
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    } else {
      if (this._protocol == "https") {
        this._protocol = "wss";
      } else {
        this._protocol = "ws";
      }
    }
    return false;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onload = function() {
        if (this.status >= 200 && this.status < 300) {
          resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
        } else {
          resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub / YoctoHub / Yocto-Visualization server IP addresses this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 15;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.DEFAULT_PROTOCOL = YV4W_installer.HTTP;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string")
          this.DEFAULTADDR = options["addr"];
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = constants.WindowHeaderFontSize.toString() + "px";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    if (!await info.makeRequest()) {
      let err = "Cannot connect to Hub\n\n" + url + '.\n\nClick on the "prev" button, make sure the server is up, protocol, path, username and password are correct and try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < 43805) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version 43805";
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHub_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4web-installer.js.map
