/* Yocto-Visualization-4web installer (version 1.10.57314) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(YAPIContext.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.57314";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.57314";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
